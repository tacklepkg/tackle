#!/usr/bin/env tclsh
##############################################################################
#
#  Author        : Dr. Detlef Groth
#  Created By    : Dr. Detlef Groth
#  Created       : Tue Sep 7 17:58:32 2021
#  Last Modified : <211109.0055>
#
#  Description	 : Standalone deployment tool for Tcl apps using uncompressed tar archives.
#
#  Notes         : - tpack application code comes at the end
#                  - no extra package are required, tar package is embedded 
#
#  History       : 2021-09-10 - release 0.1  
#                  
#	
##############################################################################
#
#  Copyright (c) 2021 Dr. Detlef Groth.
# 
#  License:      MIT
# 
##############################################################################

# tpackTar -- take from tcllib tar
#
#       Creating, extracting, and listing posix tar archives
#
# Copyright (c) 2004    Aaron Faupell <afaupell@users.sourceforge.net>
# Copyright (c) 2013    Andreas Kupries <andreas_kupries@users.sourceforge.net>
#                       (GNU tar @LongLink support).
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# RCS: @(#) $Id: tar,v 1.17 2012/09/11 17:22:24 andreas_kupries Exp $

package require Tcl 8.4
package provide tpackTar 0.11

namespace eval ::tpackTar {}

proc ::tpackTar::parseOpts {acc opts} {
    array set flags $acc
    foreach {x y} $acc {upvar $x $x}
    
    set len [llength $opts]
    set i 0
    while {$i < $len} {
        set name [string trimleft [lindex $opts $i] -]
        if {![info exists flags($name)]} {
	    return -errorcode {TAR INVALID OPTION} \
		-code error "unknown option \"$name\""
	}
        if {$flags($name) == 1} {
            set $name [lindex $opts [expr {$i + 1}]]
            incr i $flags($name)
        } elseif {$flags($name) > 1} {
            set $name [lrange $opts [expr {$i + 1}] [expr {$i + $flags($name)}]]
            incr i $flags($name)
        } else {
            set $name 1
        }
        incr i
    }
}

proc ::tpackTar::pad {size} {
    set pad [expr {512 - ($size % 512)}]
    if {$pad == 512} {return 0}
    return $pad
}

proc ::tpackTar::seekorskip {ch off wh} {
    if {[tell $ch] < 0} {
	if {$wh!="current"} {
	    return -code error -errorcode [list TAR INVALID WHENCE $wh] \
		"WHENCE=$wh not supported on non-seekable channel $ch"
	}
	skip $ch $off
	return
    }
    seek $ch $off $wh
    return
}

proc ::tpackTar::readHeader {data} {
    binary scan $data a100a8a8a8a12a12a8a1a100a6a2a32a32a8a8a155 \
                      name mode uid gid size mtime cksum type \
                      linkname magic version uname gname devmajor devminor prefix

    foreach x {name type linkname} {
        set $x [string trim [set $x] "\x00"]
    }
    foreach x {uid gid size mtime cksum} {
        set $x [format %d 0[string trim [set $x] " \x00"]]
    }
    set mode [string trim $mode " \x00"]

    if {$magic == "ustar "} {
        # gnu tar
        # not fully supported
        foreach x {uname gname prefix} {
            set $x [string trim [set $x] "\x00"]
        }
        foreach x {devmajor devminor} {
            set $x [format %d 0[string trim [set $x] " \x00"]]
        }
    } elseif {$magic == "ustar\x00"} {
        # posix tar
        foreach x {uname gname prefix} {
            set $x [string trim [set $x] "\x00"]
        }
        foreach x {devmajor devminor} {
            set $x [format %d 0[string trim [set $x] " \x00"]]
        }
    } else {
        # old style tar
        foreach x {uname gname devmajor devminor prefix} { set $x {} }
        if {$type == ""} {
            if {[string match */ $name]} {
                set type 5
            } else {
                set type 0
            }
        }
    }

    return [list name $name mode $mode uid $uid gid $gid size $size mtime $mtime \
                 cksum $cksum type $type linkname $linkname magic $magic \
                 version $version uname $uname gname $gname devmajor $devmajor \
                 devminor $devminor prefix $prefix]
}
proc ::tpackTar::untar {tar args} {
    set nooverwrite 0
    set data 0
    set nomtime 0
    set noperms 0
    set chan 0
    parseOpts {dir 1 file 1 glob 1 nooverwrite 0 nomtime 0 noperms 0 chan 0} $args
    if {![info exists dir]} {set dir [pwd]}
    set pattern *
    if {[info exists file]} {
        set pattern [string map {* \\* ? \\? \\ \\\\ \[ \\\[ \] \\\]} $file]
    } elseif {[info exists glob]} {
        set pattern $glob
    }

    set ret {}
    if {$chan} {
	set fh $tar
    } else {
	set fh [::open $tar]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    while {![eof $fh]} {
        array set header [readHeader [read $fh 512]]
	HandleLongLink $fh header
        if {$header(name) == ""} break
	if {$header(prefix) != ""} {append header(prefix) /}
        set name [string trimleft $header(prefix)$header(name) /]
        if {![string match $pattern $name] || ($nooverwrite && [file exists $name])} {
            seekorskip $fh [expr {$header(size) + [pad $header(size)]}] current
            continue
        }

        set name [file join $dir $name]
        if {![file isdirectory [file dirname $name]]} {
            file mkdir [file dirname $name]
            lappend ret [file dirname $name] {}
        }
        if {[string match {[0346]} $header(type)]} {
            if {[catch {::open $name w+} new]} {
                # sometimes if we dont have write permission we can still delete
                catch {file delete -force $name}
                set new [::open $name w+]
            }
            fconfigure $new -encoding binary -translation lf -eofchar {}
            fcopy $fh $new -size $header(size)
            close $new
            lappend ret $name $header(size)
        } elseif {$header(type) == 5} {
            file mkdir $name
            lappend ret $name {}
        } elseif {[string match {[12]} $header(type)] && $::tcl_platform(platform) == "unix"} {
            catch {file delete $name}
            if {![catch {file link [string map {1 -hard 2 -symbolic} $header(type)] $name $header(linkname)}]} {
                lappend ret $name {}
            }
        }
        seekorskip $fh [pad $header(size)] current
        if {![file exists $name]} continue

        if {$::tcl_platform(platform) == "unix"} {
            if {!$noperms} {
                catch {file attributes $name -permissions 0[string range $header(mode) 2 end]}
            }
            catch {file attributes $name -owner $header(uid) -group $header(gid)}
            catch {file attributes $name -owner $header(uname) -group $header(gname)}
        }
        if {!$nomtime} {
            file mtime $name $header(mtime)
        }
    }
    if {!$chan} {
	close $fh
    }
    return $ret
}
proc ::tpackTar::HandleLongLink {fh hv} {
    upvar 1 $hv header thelongname thelongname

    # @LongName Part I.
    if {$header(type) == "L"} {
	# Size == Length of name. Read it, and pad to full 512
	# size.  After that is a regular header for the actual
	# file, where we have to insert the name. This is handled
	# by the next iteration and the part II below.
	set thelongname [string trimright [read $fh $header(size)] \000]
	seekorskip $fh [pad $header(size)] current
	return -code continue
    }
    # Not supported yet: type 'K' for LongLink (long symbolic links).

    # @LongName, part II, get data from previous entry, if defined.
    if {[info exists thelongname]} {
	set header(name) $thelongname
	# Prevent leakage to further entries.
	unset thelongname
    }

    return
}

package provide starkit 0.1

namespace eval starkit {
    proc startup { } {
        lappend ::auto_path [file join [file dirname [info script]] lib]
        return starkit
    }
}
proc getTempDir {} {
    if {[file exists /tmp]} {
        # standard UNIX
        return /tmp
    } elseif {[info exists ::env(TMP)]} {
        # Windows
        return $::env(TMP)
    } elseif {[info exists ::env(TEMP)]} {
        # Windows
        return $::env(TEMP)
    } elseif {[info exists ::env(TMPDIR)]} {
        # OSX
        return $::env(TMPDIR)
    }
}
set rname [file rootname [info script]]
if {[file exists $rname.vfs]} {
    source [file join $rname.vfs main.tcl]
} else {
    set tail [file tail $rname]
    set time [file mtime [info script]]
    set appname [info script]
    set tmpdir [getTempDir]
    set f [open $appname]
    fconfigure $f -translation binary
    set data [read $f][close $f]
    set ctrlz [string first \u001A $data]
    if {$ctrlz > 0} {
        # todo check file dates
        ## standalone file with attached tar archive
        set script [string range $data 0 [expr {$ctrlz - 2}]]
        set archive [string range $data [incr ctrlz] end]
        set scriptfile [file join $tmpdir [file rootname $appname].ttcl]
        set tarfile [file join $tmpdir [file tail [file rootname $appname]].ttar]
        if {[file exists $tarfile]} {
            set ttime [file mtime $tarfile]
            if {$ttime < $time} {
                # script is newer than tar file
                set tmp [open $tarfile w 0600]
                fconfigure $tmp -translation binary
                puts -nonewline $tmp $archive
                close $tmp
            }
        } else {
            set tmp [open $tarfile w 0600]
            fconfigure $tmp -translation binary
            puts -nonewline $tmp $archive
            close $tmp
        }
        #set tmp [open $scriptfile w 0600]
        #fconfigure $tmp -translation binary
        #puts -nonewline $tmp $script
        #close $tmp
    } else {
        set tarfile [file rootname [info script]].ttar
        if {![file exists $tarfile]} {
            puts "Error: File $tarfile does not exists"
            exit 0
        }
    }
    set ttime [file mtime $tarfile]
    set appdir [file join $tmpdir $tail-$ttime]
    foreach dir [glob -nocomplain [file join $tmpdir $rname]*] {
        if {$dir ne $appdir && [file isdir $dir]} {
            file delete -force $dir
        } 
    }
    if {![file exists $appdir]} {
        file mkdir $appdir
        #tpackTar::untar $tarfile -dir $appdir
        tpackTar::untar $tarfile -dir $appdir
    }
    set vfspath [lindex [glob [file join $appdir *]] 0]
    if {[file exists [file join $vfspath tpack.tcl]]} {
        source [file join $vfspath tpack.tcl]
    } elseif {[file exists [file join $vfspath main.tcl]]} {
        source [file join $vfspath main.tcl]
    } else {
        error "Neither tpack.tcl or main.tcl found in tar archive!"
    }
}

## ARCHIVE LOADER END
#//#
# Tackle is a package manager for the Tcl programming language.
#
# @author    nat-418
# @version   0.0.8
# @see       https://www.github.com/tacklepkg/tackle
#//#
package require http
package require tls
package require textutil

set version 0.0.8

# We begin by inlining a few dependencies
# =======================================

# tar -xzf
namespace eval ::targz {
    package require tar
    package require zlib
    namespace export unpack

    # Unpacks a gzipped tarball
    #
    # @param  targz       Path to some file.tar.gz
    # @param  destination Path to an output directory for the archive contents
    # @return Path to the unarchived destination directory
    proc unpack {targz destination} {
        try {
            set unpacked  [lindex [exec tar -xvzf $targz] 0]
            set directory [file join $destination $unpacked]

            file rename $unpacked $directory
            file delete -force $targz

            return $directory
        } on error msg {
            puts "System tar not available, falling back to slow tar..."
            puts $msg
        }

        set tar [file rootname $targz]

        try {
            set chan1 [open $targz rb]
            zlib push gunzip $chan1 
            set contents [read $chan1]
            close $chan1
        } on error msg {
            puts "[redText Error:] Failed to decompress tarball: $targz."
            exit 1
        }
        
        try {
            set chan2 [open $tar wb]
            puts -nonewline $chan2 $contents
            close $chan2
        } on error msg {
            puts "[::termColor::red Error:] Failed to write archive: $tar."
            exit 1
        }
        
        set contents    [::tar::contents $tar]
        set directory   [file root $tar]

        set files [lmap path $contents {file tail $path}]

        foreach path $contents {
            try {
                if {[string index $path end] eq "/"} {
                    file mkdir [file join $destination $path]
                } else {
                    file mkdir [file normalize [file join $destination [file dirname $path]]]
                    set chan3 [open [file join $destination $path] wb]
                    puts -nonewline $chan3 [::tar::get $tar $path]
                    close $chan3
                }
            } on error msg {
                puts "Failed to unarchive $path."
            }
        }

        file delete $targz
        file delete $tar

        return $directory
    }
}

# Wrapper for ::http::geturl
namespace eval ::httpRedirects {
    package require http
    package require uri

    namespace export geturl fetch

    # GETs through HTTP redirects
    #
    # @param  url  URL target for the HTTP request
    # @param  args Options to pass to ::http::geturl
    # @return Token representing the respons to the request
    # @see    https://www.tcl.tk/man/tcl/TclCmd/http.html#M17
    proc geturl {url args} {
        array set URI [::uri::split $url]
        for {set i 0} {$i < 5} {incr i} {
            set token [::http::geturl $url {*}$args]

            if {![string match {30[1237]} [::http::ncode $token]]} {
                return $token
             }

            array set meta [string tolower [set ${token}(meta)]]

            if {![info exist meta(location)]} {
                return $token
            }

            array set uri [::uri::split $meta(location)]

            unset meta

            if {$uri(host) eq {}} {set uri(host) $URI(host)}

            # problem w/ relative versus absolute paths
            set url [::uri::join {*}[array get uri]]
        }
    }

    # Helper function to perform a GET request. Throws if response is not 200 OK.
    #
    # @param  url  URL target for the HTTP request
    # @return Body of the HTTP response
    proc fetch url {
        set token [::httpRedirects::geturl $url]
        set code  [::http::ncode $token]
        set data  [::http::data $token]

        if {$code ne 200} {
            error "HTTP request for $url failed."
        }

        return $data
    }
}

# Pretty colors in the console
namespace eval ::termColor {
    namespace export bright red green yellow

    # Apply ANSI bold color escape sequences to a string and then reset.
    #
    # @param  code Color code
    # @param  str  String to be colored
    # @return String with proper escape codes
    # @see    https://en.wikipedia.org/wiki/ANSI_escape_code
    proc highlight {code str} {
        append result "\033\[$code";
        append result $str
        append result "\033\[0m";

        return $result
    }

    # Make bright bold text
    #
    # @param  str  String to be colored
    # @return String with proper escape codes
    proc bright str {highlight "1;29m" $str}

    # Make red bold text
    #
    # @param  str  String to be colored
    # @return String with proper escape codes
    proc red str {highlight "1;31m" $str}

    # Make green bold text
    #
    # @param  str  String to be colored
    # @return String with proper escape codes
    proc green str {highlight "1;32m" $str}

    # Make yellow bold text
    #
    # @param  str  String to be colored
    # @return String with proper escape codes
    proc yellow str {highlight "1;33m" $str}
}



# Here we define Tackle proper
# ============================
# Pretty colors in the console
namespace eval ::tackle {
    namespace export search add remove list show

    # Search package index for a given package name
    #
    # @param  index   Dictionary of installable packages
    # @param  tracker Dictionary of installed packages
    # @param  query   String of what package we are looking for
    # @return Void: side-effect is to print search results
    proc search {index tracker {query ""}} {
        try {
            set names [dict keys $index]
        } on error msg {
            puts "[::termColor::red Error:] malformed package index."
        }

        foreach name [lsearch -inline -all $names $query*] {
            dict with index $name {
                if [dict exists $tracker $name] {
                    set installed [::termColor::yellow installed]
                } else {
                    set installed ""
                }

                if {$type eq "module"} {
                    set hiName [::termColor::yellow $name]
                } else {
                    set hiName [::termColor::green $name]
                }

                puts "$hiName [::termColor::bright v$version] $installed"
                puts "  $description"
                puts "  [string totitle $type] URL: $url"
                puts ""
            }
        }

        exit
    }

    # Add (i.e. install) packages
    #
    # @param  index   Dictionary of installable packages
    # @param  tracker Dictionary of installed packages
    # @param  names   List of package names to install
    # @return         Updated dictionary of installed packages
    proc add {index tracker names} {
        upvar 2 tacklepath destination

        set installed      [dict keys $tracker]
        set updatedTracker $tracker

        foreach name $names {
            if {$name in $installed || [file isdirectory $name]} {
                puts "$name is already installed, skipping..."
                continue
            }

            dict set updatedTracker $name [dict get $index $name]

            dict with index $name {
                file mkdir $destination
                 
                set payload  [::httpRedirects::fetch $url]
                set filename [file join $destination [file tail $url]]

                set channel [open $filename wb]
                puts -nonewline $channel $payload
                close $channel

                if {$type eq "package"} {
                    set unpacked [::targz::unpack $filename $destination]
                    dict set updatedTracker $name path $unpacked
                } else {
                    dict set updatedTracker $name path $filename
                }
                
                if {[info exists setup]} {
                    exec sh -c [subst $setup]
                }

                puts "Added $type $name v$version"
                puts "from $url"
                puts "to $unpacked"
            }
        }

        return $updatedTracker
    }

    # Remove (i.e. uninstall) packages
    #
    # @param  tracker Dictionary of installed packages
    # @param  names   List of package names to uninstall
    # @return Updated dictionary of installed packages
    proc remove {tracker names} {
        set installed      [dict keys $tracker]
        set updatedTracker $tracker

        foreach name $names {
            try {
                set path [dict get $tracker $name path]
            } on error msg {
                puts "$name is not installed, skipping..."
                continue
            }

            if {$name in $installed && [file isdirectory $path]} {
                try {
                    set updatedTracker [dict remove $updatedTracker $name]
                    file delete -force $path
                } on error msg {
                    puts "[::termColor::red Error:] failed to remove $name."
                    exit 1
                } finally {
                    puts "Removed $name."
                }
            } else {
                puts "[::termColor::red Error:] tracker out of sync with packages."
                exit 1
            }
        }
        
        return $updatedTracker
    }

    # List installed packages
    #
    # @param  tracker Dictionary of installed packages
    # @param  pattern Glob-style pattern of package names
    # @return Void: side-effect is to print package names to the console.
    proc ls {tracker pattern} {
        set names [dict keys $tracker]

        if {$names eq ""} exit

        puts [string map {" " \n} [lsearch -inline -all $names $pattern*]]

        exit
    }

    # Show details of an installed package
    #
    # @param  tracker Dictionary of installed packages
    # @param  name    Name of a pattern to detail
    # @return Void: side-effect is to print package details to the console.
    proc show {tracker name} {
        try {
            set names [dict keys $tracker]
        } on error msg {
            puts "[::termColor::red Error:] malformed package tracker."
        }

        try {
            dict with tracker $name {
                if {$type eq "module"} {
                    set hiName [::termColor::yellow $name]
                } else {
                    set hiName [::termColor::green $name]
                }
                puts "$hiName [::termColor::bright v$version]"
                puts "  $description"
                puts "  [string totitle $type] URL: $url"
                puts "  Path: $path"
                puts ""
            }
        } on error msg {
            puts "[::termColor::red Error:] $name is not installed."
        }

        exit
    }

    # Stay at the end to prevent name collisions.
    proc list {tracker pattern} {ls $tracker $pattern}
}

# Below we handle user input, execute commands, etc.
# ==================================================

# Detect whether command-line flags are present
#
# @param  args  Command-line arguments (e.g. $argv)
# @param  flags List of flags to look for
# @return Boolean where true indicates presence of at least one flag
proc hasFlags {args flags} {
    foreach flag $flags {
        if {$flag in $args} {
            return true
        }
    }
    return false
}

# Get the record of what is installed
#
# @param  trackerFile Path to the tacker.tackle file
# @return Contents of the file
proc readTracker trackerFile {
    # Create tracker file if it does not already exist.
    file mkdir [file root $trackerFile]
    close [open $trackerFile a]

    set channel [open $trackerFile r]
    set data    [read $channel]
    close $channel

    return $data
}

# Update our record of what is installed
#
# @param  trackerFile Path to the tacker.tackle file
# @param  data        Updated data
# @return Void. Side-effect: write data to tracker file
proc writeTracker {trackerFile data} {
    set channel [open $trackerFile w+]
    puts -nonewline $channel $data
    close $channel
}

# Get and set tracker data with operations
#
# @param  trackerFile Path to the tacker.tackle file
# @param  body        Operations to perform with tracker data
# @return Void. Side-effect: preform body and write tracker data
proc withTracker {trackerFile body} {
    try {
        set tracker [readTracker $trackerFile]
    } on error msg {
        puts "[::termColor::red Error:] could not read tracker file."
        exit 1
    }

    eval $body
    
    try {
        writeTracker $trackerFile $tracker
    } on error msg {
        puts "[::termColor::red Error:] could not write tracker file."
        exit 1
    }
}

set helpMessage [::textutil::undent [::textutil::trimEmptyHeading {
    Tackle package manager version v0.0.8
    https://www.tacklepkg.com
    
    Usage
      tackle [command] [arguments...]
    
    Meta Options
      -d, --debug    print verbose output messages
      -h, --help     show list of command-line options
      -v, --version  show version of tackle
    
    Commands
      search  QUERY  show packages available to install matching QUERY
      add     NAMES  install   packages by NAMES
      remove  NAMES  uninstall packages by NAMES
      list    QUERY  show installed packages matching QUERY
      show    NAME   show details of installed package NAME
}]]

# Print help message by default
if {$argc eq 0 || [hasFlags $argv {help -h --help}]} {
    puts $helpMessage
    exit
}

# Print version information
if {[hasFlags $argv {version -v --version}]} {
    puts $version
    exit
}

try {
    set tackleDir $::env(TACKLEDIR)
} on error msg {
    set tackleDir $::env(HOME)
}

set command     [lindex $argv 0]
set arguments   [lrange $argv 1 end]
set tacklepath  [file join $tackleDir .local share tackle]
set trackerFile [file join $tackleDir .config tackle tracker.tackle]

# We don't need network or file modfication to check local state.
if {$command eq "list" || $command eq "show"} {
    try {
        set tracker [readTracker $trackerFile]
    } on error msg {
        puts "[::termColor::red Error:] could not read tracker file."
    }

    try {
        ::tackle::$command $tracker $arguments
    } on error msg {
        puts "[::termColor::red Error:] could not perform $command."
    }

    exit
}

# Only search and add need to check the network.
if {$command eq "search" || $command eq "add"} {
    try {
        # Support HTTPS or HTTP requests
        ::http::register https 443 [list ::tls::socket -tls1 1]

        # Get the latest available packages
        set index [::httpRedirects::fetch \
            https://raw.githubusercontent.com/tacklepkg/packages/master/index.tackle]
    } on error msg {
        puts "[::termColor::red Error:] could not fetch package index."
        exit 1
    }

    withTracker $trackerFile {
        upvar command cmd index ind arguments args
        try {
            set tracker [::tackle::$cmd $ind $tracker $args]
        } on error msg {
            puts "[::termColor::red Error:] could not perform $cmd."
            puts $msg
            exit 1
        }
    }

    exit
}

# Removing packages requires tracker data.
if {$command eq "remove"} {
    withTracker $trackerFile {
        upvar command cmd arguments args
        try {
            set tracker [::tackle::$cmd $tracker $args]
        } on error msg {
            puts "[::termColor::red Error:] could not perform $cmd."
            puts $msg
            exit 1
        }
    }

    exit
}

# If you somehow get here you surely need help!
puts $helpMessage
return
tackle.vfs/main.tcl                                                                                 100664  1751    1751    77          14145011620 17233   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        lappend auto_path [file join [file dirname [info script]] lib]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 tackle.vfs/lib/http/pkgIndex.tcl                                                                    100664  1751    1751    212         14145011620 21614   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        if {![package vsatisfies [package provide Tcl] 8.2]} {return}
package ifneeded autoproxy 1.7 [list source [file join $dir autoproxy.tcl]]
                                                                                                                                                                                                                                                                                                                                                                                      tackle.vfs/lib/http/autoproxy.tcl                                                                   100664  1751    1751    50000       14145011620 22155   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # autoproxy.tcl - Copyright (C) 2002-2008, 2017 Pat Thoyts <patthoyts@users.sf.net>
#
# On Unix the standard for identifying the local HTTP proxy server
# seems to be to use the environment variable http_proxy or ftp_proxy and
# no_proxy to list those domains to be excluded from proxying.
#
# On Windows we can retrieve the Internet Settings values from the registry
# to obtain pretty much the same information.
#
# With this information we can setup a suitable filter procedure for the
# Tcl http package and arrange for automatic use of the proxy.
#
# Example:
#   package require autoproxy
#   autoproxy::init
#   set tok [http::geturl http://wiki.tcl.tk/]
#   http::data $tok
#
# To support https add:
#   package require tls
#   http::register https 443 ::autoproxy::tls_socket

package require Tcl 8.5 ;# ni/in operators
package require http;                   # tcl
package require uri;                    # tcllib
package require base64;                 # tcllib

namespace eval ::autoproxy {
    variable options

    if {! [info exists options]} {
        array set options {
            proxy_host ""
            proxy_port 80
            no_proxy   {}
            basic      {}
            authProc   {}
            tls_package tls
        }
    }

    variable uid
    if {![info exists uid]} { set uid 0 }

    variable winregkey
    set winregkey [join {
        HKEY_CURRENT_USER
        Software Microsoft Windows
        CurrentVersion "Internet Settings"
    } \\]
}

# -------------------------------------------------------------------------
# Description:
#   Obtain configuration options for the server.
#
proc ::autoproxy::cget {option} {
    variable options
    switch -glob -- $option {
        -host -
        -proxy_h* { set options(proxy_host) }
        -port -
        -proxy_p* { set options(proxy_port) }
        -no*      { set options(no_proxy) }
        -basic    { set options(basic) }
        -authProc { set options(authProc) }
        -tls_package { set options(tls_package) }
        default {
            set err [join [lsort [array names options]] ", -"]
            return -code error "bad option \"$option\":\
                       must be one of -$err"
        }
    }
}

# -------------------------------------------------------------------------
# Description:
#  Configure the autoproxy package settings.
#  You may only configure one type of authorisation at a time as once we hit
#  -basic, -digest or -ntlm - all further args are passed to the protocol
#  specific script.
#
#  Of course, most of the point of this package is to fill as many of these
#  fields as possible automatically. You should call autoproxy::init to
#  do automatic configuration and then call this method to refine the details.
#
proc ::autoproxy::configure {args} {
    variable options

    if {[llength $args] == 0} {
        foreach {opt value} [array get options] {
            lappend r -$opt $value
        }
        return $r
    }

    while {[string match "-*" [set option [lindex $args 0]]]} {
        switch -glob -- $option {
            -host -
            -proxy_h* { set options(proxy_host) [Pop args 1]}
            -port -
            -proxy_p* { set options(proxy_port) [Pop args 1]}
            -no*      { set options(no_proxy) [Pop args 1] }
            -basic    { Pop args; configure:basic $args ; break }
            -authProc { set options(authProc) [Pop args 1] }
            -tls_package {
                set tls_package [Pop args 1]
                if {$tls_package ni {tls twapi}} {
                    error "Invalid TLS package option '$tls_package'. Must be 'tls' or 'twapi'"
                }
                set options(tls_package) $tls_package
            }
            --        { Pop args; break }
            default {
                set opts [join [lsort [array names options]] ", -"]
                return -code error "bad option \"$option\":\
                       must be one of -$opts"
            }
        }
        Pop args
    }
}

# -------------------------------------------------------------------------
# Description:
#  Initialise the http proxy information from the environment or the
#  registry (Win32)
#
#  This procedure will load the http package and re-writes the
#  http::geturl method to add in the authorisation header.
#
#  A better solution will be to arrange for the http package to request the
#  authorisation key on receiving an authorisation reqest.
#
proc ::autoproxy::init {{httpproxy {}} {no_proxy {}}} {
    global tcl_platform
    global env
    variable winregkey
    variable options

    # Look for standard environment variables.
    if {[string length $httpproxy] > 0} {

        # nothing to do

    } elseif {[info exists env(http_proxy)]} {
        set httpproxy $env(http_proxy)
        if {[info exists env(no_proxy)]} {
            set no_proxy $env(no_proxy)
        }
    } else {
        if {$tcl_platform(platform) == "windows"} {
            #checker -scope block exclude nonPortCmd
            package require registry 1.0
            array set reg {ProxyEnable 0 ProxyServer "" ProxyOverride {}}
            catch {
                # IE5 changed ProxyEnable from a binary to a dword value.
                switch -exact -- [registry type $winregkey "ProxyEnable"] {
                    dword {
                        set reg(ProxyEnable) [registry get $winregkey "ProxyEnable"]
                    }
                    binary {
                        set v [registry get $winregkey "ProxyEnable"]
                        binary scan $v i reg(ProxyEnable)
                    }
                    default {
                        return -code error "unexpected type found for\
                               ProxyEnable registry item"
                    }
                }
                set reg(ProxyServer) [GetWin32Proxy http]
                set reg(ProxyOverride) [registry get $winregkey "ProxyOverride"]
            }
            if {![string is bool $reg(ProxyEnable)]} {
                set reg(ProxyEnable) 0
            }
            if {$reg(ProxyEnable)} {
                set httpproxy $reg(ProxyServer)
                set no_proxy  $reg(ProxyOverride)
            }
        }
    }

    # If we found something ...
    if {[string length $httpproxy] > 0} {
        # The http_proxy is supposed to be a URL - lets make sure.
        if {![regexp {\w://.*} $httpproxy]} {
            set httpproxy "http://$httpproxy"
        }

        # decompose the string.
        array set proxy [uri::split $httpproxy]

        # turn the no_proxy value into a tcl list
        set no_proxy [string map {; " " , " "} $no_proxy]

        # configure ourselves
        configure -proxy_host $proxy(host) \
            -proxy_port $proxy(port) \
            -no_proxy $no_proxy

        # Lift the authentication details from the environment if present.
        if {[string length $proxy(user)] < 1 \
                && [info exists env(http_proxy_user)] \
                && [info exists env(http_proxy_pass)]} {
            set proxy(user) $env(http_proxy_user)
            set proxy(pwd)  $env(http_proxy_pass)
        }

        # Maybe the proxy url has authentication parameters?
        # At this time, only Basic is supported.
        if {[string length $proxy(user)] > 0} {
            configure -basic -username $proxy(user) -password $proxy(pwd)
        }

        # setup and configure the http package to use our proxy info.
        http::config -proxyfilter [namespace origin filter]
    }
    return $httpproxy
}

# autoproxy::GetWin32Proxy --
#
#	Parse the Windows Internet Settings registry key and return the
#	protocol proxy requested. If the same proxy is in use for all
#	protocols, then that will be returned. Otherwise the string is
#	parsed. Example:
#	 ftp=proxy:80;http=proxy:80;https=proxy:80
#
proc ::autoproxy::GetWin32Proxy {protocol} {
    variable winregkey
    #checker exclude nonPortCmd
    set proxies [split [registry get $winregkey "ProxyServer"] ";"]
    foreach proxy $proxies {
        if {[string first = $proxy] == -1} {
            return $proxy
        } else {
            foreach {prot host} [split $proxy =] break
            if {[string compare $protocol $prot] == 0} {
                return $host
            }
        }
    }
    return -code error "failed to identify an '$protocol' proxy"
}

# -------------------------------------------------------------------------
# Description:
#  Pop the nth element off a list. Used in options processing.
proc ::autoproxy::Pop {varname {nth 0}} {
    upvar $varname args
    set r [lindex $args $nth]
    set args [lreplace $args $nth $nth]
    return $r
}

# -------------------------------------------------------------------------
# Description
#   An example user authentication procedure.
# Returns:
#   A two element list consisting of the users authentication id and
#   password.
proc ::autoproxy::defAuthProc {{user {}} {passwd {}} {realm {}}} {
    if {[string length $realm] > 0} {
        set title "Realm: $realm"
    } else {
        set title {}
    }

    # If you are using BWidgets then the following will do:
    #
    #    package require BWidget
    #    return [PasswdDlg .defAuthDlg -parent {} -transient 0 \
    #         -title $title -logintext $user -passwdtext $passwd]
    #
    # if you just have Tk and no BWidgets --

    set dlg [toplevel .autoproxy_defAuthProc -class Dialog]
    wm title $dlg $title
    wm withdraw $dlg
    label $dlg.ll -text Login -underline 0 -anchor w
    entry $dlg.le -textvariable [namespace current]::${dlg}:l
    label $dlg.pl -text Password -underline 0 -anchor w
    entry $dlg.pe -show * -textvariable [namespace current]::${dlg}:p
    button $dlg.ok -text OK -default active -width -11 \
        -command [list set [namespace current]::${dlg}:ok 1]
    grid $dlg.ll $dlg.le -sticky news
    grid $dlg.pl $dlg.pe -sticky news
    grid $dlg.ok - -sticky e
    grid columnconfigure $dlg 1 -weight 1
    bind $dlg <Return> [list $dlg.ok invoke]
    bind $dlg <Alt-l> [list focus $dlg.le]
    bind $dlg <Alt-p> [list focus $dlg.pe]
    variable ${dlg}:l $user; variable ${dlg}:p $passwd
    variable ${dlg}:ok 0
    wm deiconify $dlg; focus $dlg.pe; update idletasks
    set old [::grab current]; grab $dlg
    tkwait variable [namespace current]::${dlg}:ok
    grab release $dlg ; if {[llength $old] > 0} {::grab $old}
    set r [list [set ${dlg}:l] [set ${dlg}:p]]
    unset ${dlg}:l; unset ${dlg}:p; unset ${dlg}:ok
    destroy $dlg
    return $r
}

# -------------------------------------------------------------------------

# Description:
#  Implement support for the Basic authentication scheme (RFC 1945,2617).
# Options:
#  -user userid  - pass in the user ID (May require Windows NT domain
#                  as DOMAIN\\username)
#  -password pwd - pass in the user's password.
#  -realm realm  - pass in the http realm.
#
proc ::autoproxy::configure:basic {arglist} {
    variable options
    array set opts {user {} passwd {} realm {}}
    foreach {opt value} $arglist {
        switch -glob -- $opt {
            -u* { set opts(user) $value}
            -p* { set opts(passwd) $value}
            -r* { set opts(realm) $value}
            --  { break }
            default {
                return -code error "invalid option \"$opt\": must be one of\
                     -username or -password or -realm"
            }
        }
    }

    # If nothing was provided, try calling the authProc
    if {$options(authProc) != {} \
            && ($opts(user) == {} || $opts(passwd) == {})} {
        set r [$options(authProc) $opts(user) $opts(passwd) $opts(realm)]
        set opts(user) [lindex $r 0]
        set opts(passwd) [lindex $r 1]
    }

    if {$opts(user) eq ""} {
        set options(basic) ""
    } else {
        # Store the encoded string to avoid re-encoding all the time.
        set options(basic) [list "Proxy-Authorization" \
                                [concat "Basic" \
                                     [base64::encode $opts(user):$opts(passwd)]]]
    }
    return
}

# -------------------------------------------------------------------------
# Description:
#  An http package proxy filter. This attempts to work out if a request
#  should go via the configured proxy using a glob comparison against the
#  no_proxy list items. A typical no_proxy list might be
#   [list localhost *.my.domain.com 127.0.0.1]
#
#  If we are going to use the proxy - then insert the proxy authorization
#  header.
#
proc ::autoproxy::filter {host} {
    variable options

    if {$options(proxy_host) == {}} {
        return {}
    }

    foreach domain $options(no_proxy) {
        if {[string match $domain $host]} {
            return {}
        }
    }

    # Add authorisation header to the request (by Anders Ramdahl)
    catch {
        upvar state State
        if {$options(basic) != {}} {
            set State(-headers) [concat $options(basic) $State(-headers)]
        }
    }
    return [list $options(proxy_host) $options(proxy_port)]
}

# -------------------------------------------------------------------------
# autoproxy::tls_connect --
#
#	Create a connection to a remote machine through a proxy
#	if necessary. This is used by the tls_socket command for
#	use with the http package but can also be used more generally
#	provided your proxy will permit CONNECT attempts to ports
#	other than port 443 (many will not).
#	This command defers to 'tunnel_connect' to link to the target
#	host and then upgrades the link to SSL/TLS
#
proc ::autoproxy::tls_connect {args} {
    variable options
    set peersubject [lindex $args end-1]
    if {[string length $options(proxy_host)] > 0} {
        set s [eval [linsert $args 0 tunnel_connect]]
        fconfigure $s -blocking 1 -buffering none -translation binary
        if {[string equal "-async" [lindex $args end-2]]} {
            if {$options(tls_package) eq "twapi"} {
                set s [eval [linsert [lrange $args 0 end-3] 0 ::twapi::starttls $s -peersubject $peersubject]]
            } else {
                eval [linsert [lrange $args 0 end-3] 0 ::tls::import $s]
            }
        } else {
            if {$options(tls_package) eq "twapi"} {
                set s [eval [linsert [lrange $args 0 end-2] 0 ::twapi::starttls $s -peersubject $peersubject]]
            } else {
                eval [linsert [lrange $args 0 end-2] 0 ::tls::import $s]
            }
        }
    } else {
        if {$options(tls_package) eq "twapi"} {
            set s [eval [linsert $args 0 ::twapi::tls_socket]]
        } else {
            set s [eval [linsert $args 0 ::tls::socket]]
        }
    }
    return $s
}

# autoproxy::tunnel_connect --
#
#	Create a connection to a remote machine through a proxy
#	if necessary. This is used by the tls_socket command for
#	use with the http package but can also be used more generally
#	provided your proxy will permit CONNECT attempts to ports
#	other than port 443 (many will not).
#	Note: this command just opens the socket through the proxy to
#	the target machine -- no SSL/TLS negotiation is done yet.
#
proc ::autoproxy::tunnel_connect {args} {
    variable options
    variable uid
    set code ok

    # args = ... host port
    # and the host/port is the actual endpoint we want to talk to,
    # regardless of any proxying. See our caller tls_connect for
    # ensuring this by peeking into the http package internals.

    # To handle proxying properly we have to run through 'filter'
    # (again), to ensure that proxy exceptions are correctly taken
    # into account.

    set proxy [filter [lindex $args end-1]]

    if {[llength $proxy]} {
        foreach {proxy_host proxy_port} $proxy break

        set token [namespace current]::[incr uid]
        upvar #0 $token state
        set state(endpoint) [lrange $args end-1 end]
        set state(state) connect
        set state(data) ""
        set state(useragent) [http::config -useragent]
        set state(sock) [::socket $proxy_host $proxy_port]
        fileevent $state(sock) writable [namespace code [list tunnel_write $token]]
        vwait [set token](state)

        if {[string length $state(error)] > 0} {
            set result $state(error)
            close $state(sock)
            unset state
            set code error
        } elseif {[info exists state(code)] &&
                  (($state(code) >= 300) ||
                   ($state(code) < 200))} {
            set result [lindex $state(headers) 0]
            regexp {HTTP/\d.\d\s+\d+\s+(.*)} $result -> result
            close $state(sock)
            set code error
        } else {
            set result $state(sock)
        }
        unset state
    } else {
        set result [eval [linsert $args 0 ::socket]]
    }
    return -code $code $result
}

proc ::autoproxy::tunnel_write {token} {
    upvar #0 $token state
    variable options
    fileevent $state(sock) writable {}
    if {[catch {set state(error) [fconfigure $state(sock) -error]} err]} {
        set state(error) $err
    }
    if {[string length $state(error)] > 0} {
        set state(state) error
        return
    }
    fconfigure $state(sock) -blocking 0 -buffering line -translation crlf
    foreach {host port} $state(endpoint) break
    puts $state(sock) "CONNECT $host:$port HTTP/1.1"
    puts $state(sock) "Host: $host"
    if {[string length $state(useragent)] > 0} {
        puts $state(sock) "User-Agent: $state(useragent)"
    }
    puts $state(sock) "Proxy-Connection: keep-alive"
    puts $state(sock) "Connection: keep-alive"
    if {[string length $options(basic)] > 0} {
        puts $state(sock) [join $options(basic) ": "]
    }
    puts $state(sock) ""

    fileevent $state(sock) readable [namespace code [list tunnel_read $token]]
    return
}

proc ::autoproxy::tunnel_read {token} {
    upvar #0 $token state
    set len [gets $state(sock) line]
    if {[eof $state(sock)]} {
        fileevent $state(sock) readable {}
        set state(state) eof
    } elseif {$len == 0} {
        set state(code) [lindex [split [lindex $state(headers) 0] { }] 1]
        fileevent $state(sock) readable {}
        set state(state) ok
    } else {
        lappend state(headers) $line
    }
}

# autoproxy::tls_socket --
#
#	This can be used to handle TLS connections independently of
#	proxy presence. It can only be used with the Tcl http package
#	and to use it you must do:
#	   http::register https 443 ::autoproxy::tls_socket
#	After that you can use the http::geturl command to access
#	secure web pages and any proxy details will be handled for you.
#
proc ::autoproxy::tls_socket {args} {
    variable options

    # Look into the http package for the actual target. If a proxy is in use then
    # The function appends the proxy host and port and not the target.

    upvar host uhost port uport
    set args [lrange $args 0 end-2]
    lappend args $uhost $uport

    set s [eval [linsert $args 0 tls_connect]]

    # record the tls connection status in the http state array.
    upvar state state

    if {$options(tls_package) eq "twapi"} {
        # With twapi::tls_socket, state may not be available on
        # an async connect until negotiation is completed.
        set state(tls_status) ""
        set security_context [fconfigure $s -context]
        if {$security_context ne ""} {
            set cert [twapi::sspi_remote_cert $security_context]
            set cert_info [twapi::cert_info $cert]
            twapi::cert_release $cert
            dict set state(tls_status) issuer [dict get $cert_info -issuer]
            dict set state(tls_status) subject [dict get $cert_info -subject]
            dict set state(tls_status) notBefore [dict get $cert_info -start]
            dict set state(tls_status) notAfter [dict get $cert_info -end]
            # Note: binary encode hex was not available in older Tcl, use twapi::hex
            dict set state(tls_status) serial [twapi::hex [dict get $cert_info -serialnumber]]
            # TBD - dict set state(tls_status) cipher
            # TBD - dict set state(tls_status) sbits
        }
    } else {
        tls::handshake $s
        set state(tls_status) [tls::status $s]
    }

    return $s
}

# -------------------------------------------------------------------------

package provide autoproxy 1.7

# -------------------------------------------------------------------------
#
# Local variables:
#   mode: tcl
#   indent-tabs-mode: nil
# End:
tackle.vfs/lib/tar/pkgIndex.tcl                                                                     100664  1751    1751    234         14145011620 21427   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        if {![package vsatisfies [package provide Tcl] 8.4]} {
    # PRAGMA: returnok
    return
}
package ifneeded tar 0.11 [list source [file join $dir tar.tcl]]
                                                                                                                                                                                                                                                                                                                                                                    tackle.vfs/lib/tar/tar.tcl                                                                          100664  1751    1751    40550       14145011620 20511   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # tar.tcl --
#
#       Creating, extracting, and listing posix tar archives
#
# Copyright (c) 2004    Aaron Faupell <afaupell@users.sourceforge.net>
# Copyright (c) 2013    Andreas Kupries <andreas_kupries@users.sourceforge.net>
#                       (GNU tar @LongLink support).
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# RCS: @(#) $Id: tar.tcl,v 1.17 2012/09/11 17:22:24 andreas_kupries Exp $

package require Tcl 8.4
package provide tar 0.11

namespace eval ::tar {}

proc ::tar::parseOpts {acc opts} {
    array set flags $acc
    foreach {x y} $acc {upvar $x $x}
    
    set len [llength $opts]
    set i 0
    while {$i < $len} {
        set name [string trimleft [lindex $opts $i] -]
        if {![info exists flags($name)]} {
	    return -errorcode {TAR INVALID OPTION} \
		-code error "unknown option \"$name\""
	}
        if {$flags($name) == 1} {
            set $name [lindex $opts [expr {$i + 1}]]
            incr i $flags($name)
        } elseif {$flags($name) > 1} {
            set $name [lrange $opts [expr {$i + 1}] [expr {$i + $flags($name)}]]
            incr i $flags($name)
        } else {
            set $name 1
        }
        incr i
    }
}

proc ::tar::pad {size} {
    set pad [expr {512 - ($size % 512)}]
    if {$pad == 512} {return 0}
    return $pad
}

proc ::tar::seekorskip {ch off wh} {
    if {[tell $ch] < 0} {
	if {$wh!="current"} {
	    return -code error -errorcode [list TAR INVALID WHENCE $wh] \
		"WHENCE=$wh not supported on non-seekable channel $ch"
	}
	skip $ch $off
	return
    }
    seek $ch $off $wh
    return
}

proc ::tar::skip {ch skipover} {
    while {$skipover > 0} {
	set requested $skipover

	# Limit individual skips to 64K, as a compromise between speed
	# of skipping (Number of read requests), and memory usage
	# (Note how skipped block is read into memory!). While the
	# read data is immediately discarded it still generates memory
	# allocation traffic, gets copied, etc. Trying to skip the
	# block in one go without the limit may cause us to run out of
	# (virtual) memory, or just induce swapping, for nothing.

	if {$requested > 65536} {
	    set requested 65536
	}

	set skipped [string length [read $ch $requested]]

	# Stop in short read into the end of the file.
	if {!$skipped && [eof $ch]} break

	# Keep track of how much is (not) skipped yet.
	incr skipover -$skipped
    }
    return
}

proc ::tar::readHeader {data} {
    binary scan $data a100a8a8a8a12a12a8a1a100a6a2a32a32a8a8a155 \
                      name mode uid gid size mtime cksum type \
                      linkname magic version uname gname devmajor devminor prefix

    foreach x {name type linkname} {
        set $x [string trim [set $x] "\x00"]
    }
    foreach x {uid gid size mtime cksum} {
        set $x [format %d 0[string trim [set $x] " \x00"]]
    }
    set mode [string trim $mode " \x00"]

    if {$magic == "ustar "} {
        # gnu tar
        # not fully supported
        foreach x {uname gname prefix} {
            set $x [string trim [set $x] "\x00"]
        }
        foreach x {devmajor devminor} {
            set $x [format %d 0[string trim [set $x] " \x00"]]
        }
    } elseif {$magic == "ustar\x00"} {
        # posix tar
        foreach x {uname gname prefix} {
            set $x [string trim [set $x] "\x00"]
        }
        foreach x {devmajor devminor} {
            set $x [format %d 0[string trim [set $x] " \x00"]]
        }
    } else {
        # old style tar
        foreach x {uname gname devmajor devminor prefix} { set $x {} }
        if {$type == ""} {
            if {[string match */ $name]} {
                set type 5
            } else {
                set type 0
            }
        }
    }

    return [list name $name mode $mode uid $uid gid $gid size $size mtime $mtime \
                 cksum $cksum type $type linkname $linkname magic $magic \
                 version $version uname $uname gname $gname devmajor $devmajor \
                 devminor $devminor prefix $prefix]
}

proc ::tar::contents {file args} {
    set chan 0
    parseOpts {chan 0} $args
    if {$chan} {
	set fh $file
    } else {
	set fh [::open $file]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    set ret {}
    while {![eof $fh]} {
        array set header [readHeader [read $fh 512]]
	HandleLongLink $fh header
        if {$header(name) == ""} break
	if {$header(prefix) != ""} {append header(prefix) /}
        lappend ret $header(prefix)$header(name)
        seekorskip $fh [expr {$header(size) + [pad $header(size)]}] current
    }
    if {!$chan} {
	close $fh
    }
    return $ret
}

proc ::tar::stat {tar {file {}} args} {
    set chan 0
    parseOpts {chan 0} $args
    if {$chan} {
	set fh $tar
    } else {
	set fh [::open $tar]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    set ret {}
    while {![eof $fh]} {
        array set header [readHeader [read $fh 512]]
	HandleLongLink $fh header
        if {$header(name) == ""} break
	if {$header(prefix) != ""} {append header(prefix) /}
        seekorskip $fh [expr {$header(size) + [pad $header(size)]}] current
        if {$file != "" && "$header(prefix)$header(name)" != $file} {continue}
        set header(type) [string map {0 file 5 directory 3 characterSpecial 4 blockSpecial 6 fifo 2 link} $header(type)]
        set header(mode) [string range $header(mode) 2 end]
        lappend ret $header(prefix)$header(name) [list mode $header(mode) uid $header(uid) gid $header(gid) \
                    size $header(size) mtime $header(mtime) type $header(type) linkname $header(linkname) \
                    uname $header(uname) gname $header(gname) devmajor $header(devmajor) devminor $header(devminor)]
    }
    if {!$chan} {
	close $fh
    }
    return $ret
}

proc ::tar::get {tar file args} {
    set chan 0
    parseOpts {chan 0} $args
    if {$chan} {
	set fh $tar
    } else {
	set fh [::open $tar]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    while {![eof $fh]} {
	set data [read $fh 512]
        array set header [readHeader $data]
	HandleLongLink $fh header
        if {$header(name) eq ""} break
	if {$header(prefix) ne ""} {append header(prefix) /}
        set name [string trimleft $header(prefix)$header(name) /]
        if {$name eq $file} {
            set file [read $fh $header(size)]
            if {!$chan} {
		close $fh
	    }
            return $file
        }
        seekorskip $fh [expr {$header(size) + [pad $header(size)]}] current
    }
    if {!$chan} {
	close $fh
    }
    return -code error -errorcode {TAR MISSING FILE} \
	"Tar \"$tar\": File \"$file\" not found"
}

proc ::tar::untar {tar args} {
    set nooverwrite 0
    set data 0
    set nomtime 0
    set noperms 0
    set chan 0
    parseOpts {dir 1 file 1 glob 1 nooverwrite 0 nomtime 0 noperms 0 chan 0} $args
    if {![info exists dir]} {set dir [pwd]}
    set pattern *
    if {[info exists file]} {
        set pattern [string map {* \\* ? \\? \\ \\\\ \[ \\\[ \] \\\]} $file]
    } elseif {[info exists glob]} {
        set pattern $glob
    }

    set ret {}
    if {$chan} {
	set fh $tar
    } else {
	set fh [::open $tar]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    while {![eof $fh]} {
        array set header [readHeader [read $fh 512]]
	HandleLongLink $fh header
        if {$header(name) == ""} break
	if {$header(prefix) != ""} {append header(prefix) /}
        set name [string trimleft $header(prefix)$header(name) /]
        if {![string match $pattern $name] || ($nooverwrite && [file exists $name])} {
            seekorskip $fh [expr {$header(size) + [pad $header(size)]}] current
            continue
        }

        set name [file join $dir $name]
        if {![file isdirectory [file dirname $name]]} {
            file mkdir [file dirname $name]
            lappend ret [file dirname $name] {}
        }
        if {[string match {[0346]} $header(type)]} {
            if {[catch {::open $name w+} new]} {
                # sometimes if we dont have write permission we can still delete
                catch {file delete -force $name}
                set new [::open $name w+]
            }
            fconfigure $new -encoding binary -translation lf -eofchar {}
            fcopy $fh $new -size $header(size)
            close $new
            lappend ret $name $header(size)
        } elseif {$header(type) == 5} {
            file mkdir $name
            lappend ret $name {}
        } elseif {[string match {[12]} $header(type)] && $::tcl_platform(platform) == "unix"} {
            catch {file delete $name}
            if {![catch {file link [string map {1 -hard 2 -symbolic} $header(type)] $name $header(linkname)}]} {
                lappend ret $name {}
            }
        }
        seekorskip $fh [pad $header(size)] current
        if {![file exists $name]} continue

        if {$::tcl_platform(platform) == "unix"} {
            if {!$noperms} {
                catch {file attributes $name -permissions 0[string range $header(mode) 2 end]}
            }
            catch {file attributes $name -owner $header(uid) -group $header(gid)}
            catch {file attributes $name -owner $header(uname) -group $header(gname)}
        }
        if {!$nomtime} {
            file mtime $name $header(mtime)
        }
    }
    if {!$chan} {
	close $fh
    }
    return $ret
}

## 
 # ::tar::statFile
 # 
 # Returns stat info about a filesystem object, in the form of an info 
 # dictionary like that returned by ::tar::readHeader.
 # 
 # The mode, uid, gid, mtime, and type entries are always present. 
 # The size and linkname entries are present if relevant for this type 
 # of object. The uname and gname entries are present if the OS supports 
 # them. No devmajor or devminor entry is present.
 ##

proc ::tar::statFile {name followlinks} {
    if {$followlinks} {
        file stat $name stat
    } else {
        file lstat $name stat
    }
    
    set ret {}
    
    if {$::tcl_platform(platform) == "unix"} {
        lappend ret mode 1[file attributes $name -permissions]
        lappend ret uname [file attributes $name -owner]
        lappend ret gname [file attributes $name -group]
        if {$stat(type) == "link"} {
            lappend ret linkname [file link $name]
        }
    } else {
        lappend ret mode [lindex {100644 100755} [expr {$stat(type) == "directory"}]]
    }
    
    lappend ret  uid $stat(uid)  gid $stat(gid)  mtime $stat(mtime) \
      type $stat(type)
    
    if {$stat(type) == "file"} {lappend ret size $stat(size)}
    
    return $ret
}

## 
 # ::tar::formatHeader
 # 
 # Opposite operation to ::tar::readHeader; takes a file name and info 
 # dictionary as arguments, returns a corresponding (POSIX-tar) header.
 # 
 # The following dictionary entries must be present:
 #   mode
 #   type
 # 
 # The following dictionary entries are used if present, otherwise 
 # the indicated default is used:
 #   uid       0
 #   gid       0
 #   size      0
 #   mtime     [clock seconds]
 #   linkname  {}
 #   uname     {}
 #   gname     {}
 #   
 # All other dictionary entries, including devmajor and devminor, are 
 # presently ignored.
 ##

proc ::tar::formatHeader {name info} {
    array set A {
        linkname ""
        uname ""
        gname ""
        size 0
        gid  0
        uid  0
    }
    set A(mtime) [clock seconds]
    array set A $info
    array set A {devmajor "" devminor ""}

    set type [string map {file 0 directory 5 characterSpecial 3 \
      blockSpecial 4 fifo 6 link 2 socket A} $A(type)]
    
    set osize  [format %o $A(size)]
    set ogid   [format %o $A(gid)]
    set ouid   [format %o $A(uid)]
    set omtime [format %o $A(mtime)]
    
    set name [string trimleft $name /]
    if {[string length $name] > 255} {
        return -code error -errorcode {TAR BAD PATH LENGTH} \
	    "path name over 255 chars"
    } elseif {[string length $name] > 100} {
	set common [string range $name end-99 154]
	if {[set splitpoint [string first / $common]] == -1} {
	    return -code error -errorcode {TAR BAD PATH UNSPLITTABLE} \
		"path name cannot be split into prefix and name"
	}
	set prefix [string range $name 0 end-100][string range $common 0 $splitpoint-1]
	set name   [string range $common $splitpoint+1 end][string range $name 155 end]
    } else {
        set prefix ""
    }

    set header [binary format a100A8A8A8A12A12A8a1a100A6a2a32a32a8a8a155a12 \
                              $name $A(mode)\x00 $ouid\x00 $ogid\x00\
                              $osize\x00 $omtime\x00 {} $type \
                              $A(linkname) ustar\x00 00 $A(uname) $A(gname)\
                              $A(devmajor) $A(devminor) $prefix {}]

    binary scan $header c* tmp
    set cksum 0
    foreach x $tmp {incr cksum $x}

    return [string replace $header 148 155 [binary format A8 [format %o $cksum]\x00]]
}


proc ::tar::recurseDirs {files followlinks} {
    foreach x $files {
        if {[file isdirectory $x] && ([file type $x] != "link" || $followlinks)} {
            if {[set more [glob -dir $x -nocomplain *]] != ""} {
                eval lappend files [recurseDirs $more $followlinks]
            } else {
                lappend files $x
            }
        }
    }
    return $files
}

proc ::tar::writefile {in out followlinks name} {
     puts -nonewline $out [formatHeader $name [statFile $in $followlinks]]
     set size 0
     if {[file type $in] == "file" || ($followlinks && [file type $in] == "link")} {
         set in [::open $in]
         fconfigure $in -encoding binary -translation lf -eofchar {}
         set size [fcopy $in $out]
         close $in
     }
     puts -nonewline $out [string repeat \x00 [pad $size]]
}

proc ::tar::create {tar files args} {
    set dereference 0
    set chan 0
    parseOpts {dereference 0 chan 0} $args

    if {$chan} {
	set fh $tar
    } else {
	set fh [::open $tar w+]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    foreach x [recurseDirs $files $dereference] {
        writefile $x $fh $dereference $x
    }
    puts -nonewline $fh [string repeat \x00 1024]

    if {!$chan} {
	close $fh
    }
    return $tar
}

proc ::tar::add {tar files args} {
    set dereference 0
    set prefix ""
    set quick 0
    parseOpts {dereference 0 prefix 1 quick 0} $args
    
    set fh [::open $tar r+]
    fconfigure $fh -encoding binary -translation lf -eofchar {}
    
    if {$quick} then {
        seek $fh -1024 end
    } else {
        set data [read $fh 512]
        while {[regexp {[^\0]} $data]} {
            array set header [readHeader $data]
            seek $fh [expr {$header(size) + [pad $header(size)]}] current
            set data [read $fh 512]
        }
        seek $fh -512 current
    }

    foreach x [recurseDirs $files $dereference] {
        writefile $x $fh $dereference $prefix$x
    }
    puts -nonewline $fh [string repeat \x00 1024]

    close $fh
    return $tar
}

proc ::tar::remove {tar files} {
    set n 0
    while {[file exists $tar$n.tmp]} {incr n}
    set tfh [::open $tar$n.tmp w]
    set fh [::open $tar r]

    fconfigure $fh  -encoding binary -translation lf -eofchar {}
    fconfigure $tfh -encoding binary -translation lf -eofchar {}

    while {![eof $fh]} {
        array set header [readHeader [read $fh 512]]
        if {$header(name) == ""} {
            puts -nonewline $tfh [string repeat \x00 1024]
            break
        }
	if {$header(prefix) != ""} {append header(prefix) /}
        set name $header(prefix)$header(name)
        set len [expr {$header(size) + [pad $header(size)]}]
        if {[lsearch $files $name] > -1} {
            seek $fh $len current
        } else {
            seek $fh -512 current
            fcopy $fh $tfh -size [expr {$len + 512}]
        }
    }

    close $fh
    close $tfh

    file rename -force $tar$n.tmp $tar
}

proc ::tar::HandleLongLink {fh hv} {
    upvar 1 $hv header thelongname thelongname

    # @LongName Part I.
    if {$header(type) == "L"} {
	# Size == Length of name. Read it, and pad to full 512
	# size.  After that is a regular header for the actual
	# file, where we have to insert the name. This is handled
	# by the next iteration and the part II below.
	set thelongname [string trimright [read $fh $header(size)] \000]
	seekorskip $fh [pad $header(size)] current
	return -code continue
    }
    # Not supported yet: type 'K' for LongLink (long symbolic links).

    # @LongName, part II, get data from previous entry, if defined.
    if {[info exists thelongname]} {
	set header(name) $thelongname
	# Prevent leakage to further entries.
	unset thelongname
    }

    return
}
                                                                                                                                                        tackle.vfs/lib/textutil/wcswidth.tcl                                                                100644  1751    1751    101650      14145011620 22670   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        ###
# This file is automatically generated by the build/build.tcl file
# based on information in the following database:
# http://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt
#
# (This is the 35th edition, thus version 35 for our package)
#
# Author: Sean Woods <yoda@etoyoc.com>
###
package provide textutil::wcswidth 35.1
proc ::textutil::wcswidth_type char {
  if {$char == 161} { return A }
  if {$char == 164} { return A }
  if {$char == 167} { return A }
  if {$char == 168} { return A }
  if {$char == 170} { return A }
  if {$char == 173} { return A }
  if {$char == 174} { return A }
  if {$char == 176} { return A }
  if {$char == 177} { return A }
  if {$char >= 178 && $char <= 179 } { return A }
  if {$char == 180} { return A }
  if {$char >= 182 && $char <= 183 } { return A }
  if {$char == 184} { return A }
  if {$char == 185} { return A }
  if {$char == 186} { return A }
  if {$char >= 188 && $char <= 190 } { return A }
  if {$char == 191} { return A }
  if {$char == 198} { return A }
  if {$char == 208} { return A }
  if {$char == 215} { return A }
  if {$char == 216} { return A }
  if {$char >= 222 && $char <= 225 } { return A }
  if {$char == 230} { return A }
  if {$char >= 232 && $char <= 234 } { return A }
  if {$char >= 236 && $char <= 237 } { return A }
  if {$char == 240} { return A }
  if {$char >= 242 && $char <= 243 } { return A }
  if {$char == 247} { return A }
  if {$char >= 248 && $char <= 250 } { return A }
  if {$char == 252} { return A }
  if {$char == 254} { return A }
  if {$char == 257} { return A }
  if {$char == 273} { return A }
  if {$char == 275} { return A }
  if {$char == 283} { return A }
  if {$char >= 294 && $char <= 295 } { return A }
  if {$char == 299} { return A }
  if {$char >= 305 && $char <= 307 } { return A }
  if {$char == 312} { return A }
  if {$char >= 319 && $char <= 322 } { return A }
  if {$char == 324} { return A }
  if {$char >= 328 && $char <= 331 } { return A }
  if {$char == 333} { return A }
  if {$char >= 338 && $char <= 339 } { return A }
  if {$char >= 358 && $char <= 359 } { return A }
  if {$char == 363} { return A }
  if {$char == 462} { return A }
  if {$char == 464} { return A }
  if {$char == 466} { return A }
  if {$char == 468} { return A }
  if {$char == 470} { return A }
  if {$char == 472} { return A }
  if {$char == 474} { return A }
  if {$char == 476} { return A }
  if {$char == 593} { return A }
  if {$char == 609} { return A }
  if {$char == 708} { return A }
  if {$char == 711} { return A }
  if {$char >= 713 && $char <= 715 } { return A }
  if {$char == 717} { return A }
  if {$char == 720} { return A }
  if {$char >= 728 && $char <= 731 } { return A }
  if {$char == 733} { return A }
  if {$char == 735} { return A }
  if {$char >= 768 && $char <= 879 } { return A }
  if {$char >= 913 && $char <= 929 } { return A }
  if {$char >= 931 && $char <= 937 } { return A }
  if {$char >= 945 && $char <= 961 } { return A }
  if {$char >= 963 && $char <= 969 } { return A }
  if {$char == 1025} { return A }
  if {$char >= 1040 && $char <= 1103 } { return A }
  if {$char == 1105} { return A }
  if {$char >= 4352 && $char <= 4447 } { return W }
  if {$char == 8208} { return A }
  if {$char >= 8211 && $char <= 8213 } { return A }
  if {$char == 8214} { return A }
  if {$char == 8216} { return A }
  if {$char == 8217} { return A }
  if {$char == 8220} { return A }
  if {$char == 8221} { return A }
  if {$char >= 8224 && $char <= 8226 } { return A }
  if {$char >= 8228 && $char <= 8231 } { return A }
  if {$char == 8240} { return A }
  if {$char >= 8242 && $char <= 8243 } { return A }
  if {$char == 8245} { return A }
  if {$char == 8251} { return A }
  if {$char == 8254} { return A }
  if {$char == 8308} { return A }
  if {$char == 8319} { return A }
  if {$char >= 8321 && $char <= 8324 } { return A }
  if {$char == 8361} { return H }
  if {$char == 8364} { return A }
  if {$char == 8451} { return A }
  if {$char == 8453} { return A }
  if {$char == 8457} { return A }
  if {$char == 8467} { return A }
  if {$char == 8470} { return A }
  if {$char >= 8481 && $char <= 8482 } { return A }
  if {$char == 8486} { return A }
  if {$char == 8491} { return A }
  if {$char >= 8531 && $char <= 8532 } { return A }
  if {$char >= 8539 && $char <= 8542 } { return A }
  if {$char >= 8544 && $char <= 8555 } { return A }
  if {$char >= 8560 && $char <= 8569 } { return A }
  if {$char == 8585} { return A }
  if {$char >= 8592 && $char <= 8596 } { return A }
  if {$char >= 8597 && $char <= 8601 } { return A }
  if {$char >= 8632 && $char <= 8633 } { return A }
  if {$char == 8658} { return A }
  if {$char == 8660} { return A }
  if {$char == 8679} { return A }
  if {$char == 8704} { return A }
  if {$char >= 8706 && $char <= 8707 } { return A }
  if {$char >= 8711 && $char <= 8712 } { return A }
  if {$char == 8715} { return A }
  if {$char == 8719} { return A }
  if {$char == 8721} { return A }
  if {$char == 8725} { return A }
  if {$char == 8730} { return A }
  if {$char >= 8733 && $char <= 8736 } { return A }
  if {$char == 8739} { return A }
  if {$char == 8741} { return A }
  if {$char >= 8743 && $char <= 8748 } { return A }
  if {$char == 8750} { return A }
  if {$char >= 8756 && $char <= 8759 } { return A }
  if {$char >= 8764 && $char <= 8765 } { return A }
  if {$char == 8776} { return A }
  if {$char == 8780} { return A }
  if {$char == 8786} { return A }
  if {$char >= 8800 && $char <= 8801 } { return A }
  if {$char >= 8804 && $char <= 8807 } { return A }
  if {$char >= 8810 && $char <= 8811 } { return A }
  if {$char >= 8814 && $char <= 8815 } { return A }
  if {$char >= 8834 && $char <= 8835 } { return A }
  if {$char >= 8838 && $char <= 8839 } { return A }
  if {$char == 8853} { return A }
  if {$char == 8857} { return A }
  if {$char == 8869} { return A }
  if {$char == 8895} { return A }
  if {$char == 8978} { return A }
  if {$char >= 8986 && $char <= 8987 } { return W }
  if {$char == 9001} { return W }
  if {$char == 9002} { return W }
  if {$char >= 9193 && $char <= 9196 } { return W }
  if {$char == 9200} { return W }
  if {$char == 9203} { return W }
  if {$char >= 9312 && $char <= 9371 } { return A }
  if {$char >= 9372 && $char <= 9449 } { return A }
  if {$char >= 9451 && $char <= 9471 } { return A }
  if {$char >= 9472 && $char <= 9547 } { return A }
  if {$char >= 9552 && $char <= 9587 } { return A }
  if {$char >= 9600 && $char <= 9615 } { return A }
  if {$char >= 9618 && $char <= 9621 } { return A }
  if {$char >= 9632 && $char <= 9633 } { return A }
  if {$char >= 9635 && $char <= 9641 } { return A }
  if {$char >= 9650 && $char <= 9651 } { return A }
  if {$char == 9654} { return A }
  if {$char == 9655} { return A }
  if {$char >= 9660 && $char <= 9661 } { return A }
  if {$char == 9664} { return A }
  if {$char == 9665} { return A }
  if {$char >= 9670 && $char <= 9672 } { return A }
  if {$char == 9675} { return A }
  if {$char >= 9678 && $char <= 9681 } { return A }
  if {$char >= 9698 && $char <= 9701 } { return A }
  if {$char == 9711} { return A }
  if {$char >= 9725 && $char <= 9726 } { return W }
  if {$char >= 9733 && $char <= 9734 } { return A }
  if {$char == 9737} { return A }
  if {$char >= 9742 && $char <= 9743 } { return A }
  if {$char >= 9748 && $char <= 9749 } { return W }
  if {$char == 9756} { return A }
  if {$char == 9758} { return A }
  if {$char == 9792} { return A }
  if {$char == 9794} { return A }
  if {$char >= 9800 && $char <= 9811 } { return W }
  if {$char >= 9824 && $char <= 9825 } { return A }
  if {$char >= 9827 && $char <= 9829 } { return A }
  if {$char >= 9831 && $char <= 9834 } { return A }
  if {$char >= 9836 && $char <= 9837 } { return A }
  if {$char == 9839} { return A }
  if {$char == 9855} { return W }
  if {$char == 9875} { return W }
  if {$char >= 9886 && $char <= 9887 } { return A }
  if {$char == 9889} { return W }
  if {$char >= 9898 && $char <= 9899 } { return W }
  if {$char >= 9917 && $char <= 9918 } { return W }
  if {$char == 9919} { return A }
  if {$char >= 9924 && $char <= 9925 } { return W }
  if {$char >= 9926 && $char <= 9933 } { return A }
  if {$char == 9934} { return W }
  if {$char >= 9935 && $char <= 9939 } { return A }
  if {$char == 9940} { return W }
  if {$char >= 9941 && $char <= 9953 } { return A }
  if {$char == 9955} { return A }
  if {$char >= 9960 && $char <= 9961 } { return A }
  if {$char == 9962} { return W }
  if {$char >= 9963 && $char <= 9969 } { return A }
  if {$char >= 9970 && $char <= 9971 } { return W }
  if {$char == 9972} { return A }
  if {$char == 9973} { return W }
  if {$char >= 9974 && $char <= 9977 } { return A }
  if {$char == 9978} { return W }
  if {$char >= 9979 && $char <= 9980 } { return A }
  if {$char == 9981} { return W }
  if {$char >= 9982 && $char <= 9983 } { return A }
  if {$char == 9989} { return W }
  if {$char >= 9994 && $char <= 9995 } { return W }
  if {$char == 10024} { return W }
  if {$char == 10045} { return A }
  if {$char == 10060} { return W }
  if {$char == 10062} { return W }
  if {$char >= 10067 && $char <= 10069 } { return W }
  if {$char == 10071} { return W }
  if {$char >= 10102 && $char <= 10111 } { return A }
  if {$char >= 10133 && $char <= 10135 } { return W }
  if {$char == 10160} { return W }
  if {$char == 10175} { return W }
  if {$char >= 11035 && $char <= 11036 } { return W }
  if {$char == 11088} { return W }
  if {$char == 11093} { return W }
  if {$char >= 11094 && $char <= 11097 } { return A }
  if {$char >= 11904 && $char <= 11929 } { return W }
  if {$char >= 11931 && $char <= 12019 } { return W }
  if {$char >= 12032 && $char <= 12245 } { return W }
  if {$char >= 12272 && $char <= 12283 } { return W }
  if {$char == 12288} { return F }
  if {$char >= 12289 && $char <= 12291 } { return W }
  if {$char == 12292} { return W }
  if {$char == 12293} { return W }
  if {$char == 12294} { return W }
  if {$char == 12295} { return W }
  if {$char == 12296} { return W }
  if {$char == 12297} { return W }
  if {$char == 12298} { return W }
  if {$char == 12299} { return W }
  if {$char == 12300} { return W }
  if {$char == 12301} { return W }
  if {$char == 12302} { return W }
  if {$char == 12303} { return W }
  if {$char == 12304} { return W }
  if {$char == 12305} { return W }
  if {$char >= 12306 && $char <= 12307 } { return W }
  if {$char == 12308} { return W }
  if {$char == 12309} { return W }
  if {$char == 12310} { return W }
  if {$char == 12311} { return W }
  if {$char == 12312} { return W }
  if {$char == 12313} { return W }
  if {$char == 12314} { return W }
  if {$char == 12315} { return W }
  if {$char == 12316} { return W }
  if {$char == 12317} { return W }
  if {$char >= 12318 && $char <= 12319 } { return W }
  if {$char == 12320} { return W }
  if {$char >= 12321 && $char <= 12329 } { return W }
  if {$char >= 12330 && $char <= 12333 } { return W }
  if {$char >= 12334 && $char <= 12335 } { return W }
  if {$char == 12336} { return W }
  if {$char >= 12337 && $char <= 12341 } { return W }
  if {$char >= 12342 && $char <= 12343 } { return W }
  if {$char >= 12344 && $char <= 12346 } { return W }
  if {$char == 12347} { return W }
  if {$char == 12348} { return W }
  if {$char == 12349} { return W }
  if {$char == 12350} { return W }
  if {$char >= 12353 && $char <= 12438 } { return W }
  if {$char >= 12441 && $char <= 12442 } { return W }
  if {$char >= 12443 && $char <= 12444 } { return W }
  if {$char >= 12445 && $char <= 12446 } { return W }
  if {$char == 12447} { return W }
  if {$char == 12448} { return W }
  if {$char >= 12449 && $char <= 12538 } { return W }
  if {$char == 12539} { return W }
  if {$char >= 12540 && $char <= 12542 } { return W }
  if {$char == 12543} { return W }
  if {$char >= 12549 && $char <= 12591 } { return W }
  if {$char >= 12593 && $char <= 12686 } { return W }
  if {$char >= 12688 && $char <= 12689 } { return W }
  if {$char >= 12690 && $char <= 12693 } { return W }
  if {$char >= 12694 && $char <= 12703 } { return W }
  if {$char >= 12704 && $char <= 12730 } { return W }
  if {$char >= 12736 && $char <= 12771 } { return W }
  if {$char >= 12784 && $char <= 12799 } { return W }
  if {$char >= 12800 && $char <= 12830 } { return W }
  if {$char >= 12832 && $char <= 12841 } { return W }
  if {$char >= 12842 && $char <= 12871 } { return W }
  if {$char >= 12872 && $char <= 12879 } { return A }
  if {$char == 12880} { return W }
  if {$char >= 12881 && $char <= 12895 } { return W }
  if {$char >= 12896 && $char <= 12927 } { return W }
  if {$char >= 12928 && $char <= 12937 } { return W }
  if {$char >= 12938 && $char <= 12976 } { return W }
  if {$char >= 12977 && $char <= 12991 } { return W }
  if {$char >= 12992 && $char <= 13054 } { return W }
  if {$char >= 13056 && $char <= 13311 } { return W }
  if {$char >= 13312 && $char <= 19893 } { return W }
  if {$char >= 19894 && $char <= 19903 } { return W }
  if {$char >= 19968 && $char <= 40943 } { return W }
  if {$char >= 40944 && $char <= 40959 } { return W }
  if {$char >= 40960 && $char <= 40980 } { return W }
  if {$char == 40981} { return W }
  if {$char >= 40982 && $char <= 42124 } { return W }
  if {$char >= 42128 && $char <= 42182 } { return W }
  if {$char >= 43360 && $char <= 43388 } { return W }
  if {$char >= 44032 && $char <= 55203 } { return W }
  if {$char >= 57344 && $char <= 63743 } { return A }
  if {$char >= 63744 && $char <= 64109 } { return W }
  if {$char >= 64110 && $char <= 64111 } { return W }
  if {$char >= 64112 && $char <= 64217 } { return W }
  if {$char >= 64218 && $char <= 64255 } { return W }
  if {$char >= 65024 && $char <= 65039 } { return A }
  if {$char >= 65040 && $char <= 65046 } { return W }
  if {$char == 65047} { return W }
  if {$char == 65048} { return W }
  if {$char == 65049} { return W }
  if {$char == 65072} { return W }
  if {$char >= 65073 && $char <= 65074 } { return W }
  if {$char >= 65075 && $char <= 65076 } { return W }
  if {$char == 65077} { return W }
  if {$char == 65078} { return W }
  if {$char == 65079} { return W }
  if {$char == 65080} { return W }
  if {$char == 65081} { return W }
  if {$char == 65082} { return W }
  if {$char == 65083} { return W }
  if {$char == 65084} { return W }
  if {$char == 65085} { return W }
  if {$char == 65086} { return W }
  if {$char == 65087} { return W }
  if {$char == 65088} { return W }
  if {$char == 65089} { return W }
  if {$char == 65090} { return W }
  if {$char == 65091} { return W }
  if {$char == 65092} { return W }
  if {$char >= 65093 && $char <= 65094 } { return W }
  if {$char == 65095} { return W }
  if {$char == 65096} { return W }
  if {$char >= 65097 && $char <= 65100 } { return W }
  if {$char >= 65101 && $char <= 65103 } { return W }
  if {$char >= 65104 && $char <= 65106 } { return W }
  if {$char >= 65108 && $char <= 65111 } { return W }
  if {$char == 65112} { return W }
  if {$char == 65113} { return W }
  if {$char == 65114} { return W }
  if {$char == 65115} { return W }
  if {$char == 65116} { return W }
  if {$char == 65117} { return W }
  if {$char == 65118} { return W }
  if {$char >= 65119 && $char <= 65121 } { return W }
  if {$char == 65122} { return W }
  if {$char == 65123} { return W }
  if {$char >= 65124 && $char <= 65126 } { return W }
  if {$char == 65128} { return W }
  if {$char == 65129} { return W }
  if {$char >= 65130 && $char <= 65131 } { return W }
  if {$char >= 65281 && $char <= 65283 } { return F }
  if {$char == 65284} { return F }
  if {$char >= 65285 && $char <= 65287 } { return F }
  if {$char == 65288} { return F }
  if {$char == 65289} { return F }
  if {$char == 65290} { return F }
  if {$char == 65291} { return F }
  if {$char == 65292} { return F }
  if {$char == 65293} { return F }
  if {$char >= 65294 && $char <= 65295 } { return F }
  if {$char >= 65296 && $char <= 65305 } { return F }
  if {$char >= 65306 && $char <= 65307 } { return F }
  if {$char >= 65308 && $char <= 65310 } { return F }
  if {$char >= 65311 && $char <= 65312 } { return F }
  if {$char >= 65313 && $char <= 65338 } { return F }
  if {$char == 65339} { return F }
  if {$char == 65340} { return F }
  if {$char == 65341} { return F }
  if {$char == 65342} { return F }
  if {$char == 65343} { return F }
  if {$char == 65344} { return F }
  if {$char >= 65345 && $char <= 65370 } { return F }
  if {$char == 65371} { return F }
  if {$char == 65372} { return F }
  if {$char == 65373} { return F }
  if {$char == 65374} { return F }
  if {$char == 65375} { return F }
  if {$char == 65376} { return F }
  if {$char == 65377} { return H }
  if {$char == 65378} { return H }
  if {$char == 65379} { return H }
  if {$char >= 65380 && $char <= 65381 } { return H }
  if {$char >= 65382 && $char <= 65391 } { return H }
  if {$char == 65392} { return H }
  if {$char >= 65393 && $char <= 65437 } { return H }
  if {$char >= 65438 && $char <= 65439 } { return H }
  if {$char >= 65440 && $char <= 65470 } { return H }
  if {$char >= 65474 && $char <= 65479 } { return H }
  if {$char >= 65482 && $char <= 65487 } { return H }
  if {$char >= 65490 && $char <= 65495 } { return H }
  if {$char >= 65498 && $char <= 65500 } { return H }
  if {$char >= 65504 && $char <= 65505 } { return F }
  if {$char == 65506} { return F }
  if {$char == 65507} { return F }
  if {$char == 65508} { return F }
  if {$char >= 65509 && $char <= 65510 } { return F }
  if {$char == 65512} { return H }
  if {$char >= 65513 && $char <= 65516 } { return H }
  if {$char >= 65517 && $char <= 65518 } { return H }
  if {$char == 65533} { return A }
  if {$char >= 94176 && $char <= 94177 } { return W }
  if {$char >= 94208 && $char <= 100337 } { return W }
  if {$char >= 100352 && $char <= 101106 } { return W }
  if {$char >= 110592 && $char <= 110847 } { return W }
  if {$char >= 110848 && $char <= 110878 } { return W }
  if {$char >= 110960 && $char <= 111355 } { return W }
  if {$char == 126980} { return W }
  if {$char == 127183} { return W }
  if {$char >= 127232 && $char <= 127242 } { return A }
  if {$char >= 127248 && $char <= 127277 } { return A }
  if {$char >= 127280 && $char <= 127337 } { return A }
  if {$char >= 127344 && $char <= 127373 } { return A }
  if {$char == 127374} { return W }
  if {$char >= 127375 && $char <= 127376 } { return A }
  if {$char >= 127377 && $char <= 127386 } { return W }
  if {$char >= 127387 && $char <= 127404 } { return A }
  if {$char >= 127488 && $char <= 127490 } { return W }
  if {$char >= 127504 && $char <= 127547 } { return W }
  if {$char >= 127552 && $char <= 127560 } { return W }
  if {$char >= 127568 && $char <= 127569 } { return W }
  if {$char >= 127584 && $char <= 127589 } { return W }
  if {$char >= 127744 && $char <= 127776 } { return W }
  if {$char >= 127789 && $char <= 127797 } { return W }
  if {$char >= 127799 && $char <= 127868 } { return W }
  if {$char >= 127870 && $char <= 127891 } { return W }
  if {$char >= 127904 && $char <= 127946 } { return W }
  if {$char >= 127951 && $char <= 127955 } { return W }
  if {$char >= 127968 && $char <= 127984 } { return W }
  if {$char == 127988} { return W }
  if {$char >= 127992 && $char <= 127994 } { return W }
  if {$char >= 127995 && $char <= 127999 } { return W }
  if {$char >= 128000 && $char <= 128062 } { return W }
  if {$char == 128064} { return W }
  if {$char >= 128066 && $char <= 128252 } { return W }
  if {$char >= 128255 && $char <= 128317 } { return W }
  if {$char >= 128331 && $char <= 128334 } { return W }
  if {$char >= 128336 && $char <= 128359 } { return W }
  if {$char == 128378} { return W }
  if {$char >= 128405 && $char <= 128406 } { return W }
  if {$char == 128420} { return W }
  if {$char >= 128507 && $char <= 128511 } { return W }
  if {$char >= 128512 && $char <= 128591 } { return W }
  if {$char >= 128640 && $char <= 128709 } { return W }
  if {$char == 128716} { return W }
  if {$char >= 128720 && $char <= 128722 } { return W }
  if {$char >= 128747 && $char <= 128748 } { return W }
  if {$char >= 128756 && $char <= 128761 } { return W }
  if {$char >= 129296 && $char <= 129342 } { return W }
  if {$char >= 129344 && $char <= 129392 } { return W }
  if {$char >= 129395 && $char <= 129398 } { return W }
  if {$char == 129402} { return W }
  if {$char >= 129404 && $char <= 129442 } { return W }
  if {$char >= 129456 && $char <= 129465 } { return W }
  if {$char >= 129472 && $char <= 129474 } { return W }
  if {$char >= 129488 && $char <= 129535 } { return W }
  if {$char >= 131072 && $char <= 173782 } { return W }
  if {$char >= 173783 && $char <= 173823 } { return W }
  if {$char >= 173824 && $char <= 177972 } { return W }
  if {$char >= 177973 && $char <= 177983 } { return W }
  if {$char >= 177984 && $char <= 178205 } { return W }
  if {$char >= 178206 && $char <= 178207 } { return W }
  if {$char >= 178208 && $char <= 183969 } { return W }
  if {$char >= 183970 && $char <= 183983 } { return W }
  if {$char >= 183984 && $char <= 191456 } { return W }
  if {$char >= 191457 && $char <= 194559 } { return W }
  if {$char >= 194560 && $char <= 195101 } { return W }
  if {$char >= 195102 && $char <= 195103 } { return W }
  if {$char >= 195104 && $char <= 196605 } { return W }
  if {$char >= 196608 && $char <= 262141 } { return W }
  if {$char >= 917760 && $char <= 917999 } { return A }
  if {$char >= 983040 && $char <= 1048573 } { return A }
  if {$char >= 1048576 && $char <= 1114109 } { return A }
  return N
}
proc ::textutil::wcswidth_char char {
  if {$char >= 4352 && $char <= 4447 } { return 2 }
  if {$char >= 8986 && $char <= 8987 } { return 2 }
  if {$char == 9001} { return 2 }
  if {$char == 9002} { return 2 }
  if {$char >= 9193 && $char <= 9196 } { return 2 }
  if {$char == 9200} { return 2 }
  if {$char == 9203} { return 2 }
  if {$char >= 9725 && $char <= 9726 } { return 2 }
  if {$char >= 9748 && $char <= 9749 } { return 2 }
  if {$char >= 9800 && $char <= 9811 } { return 2 }
  if {$char == 9855} { return 2 }
  if {$char == 9875} { return 2 }
  if {$char == 9889} { return 2 }
  if {$char >= 9898 && $char <= 9899 } { return 2 }
  if {$char >= 9917 && $char <= 9918 } { return 2 }
  if {$char >= 9924 && $char <= 9925 } { return 2 }
  if {$char == 9934} { return 2 }
  if {$char == 9940} { return 2 }
  if {$char == 9962} { return 2 }
  if {$char >= 9970 && $char <= 9971 } { return 2 }
  if {$char == 9973} { return 2 }
  if {$char == 9978} { return 2 }
  if {$char == 9981} { return 2 }
  if {$char == 9989} { return 2 }
  if {$char >= 9994 && $char <= 9995 } { return 2 }
  if {$char == 10024} { return 2 }
  if {$char == 10060} { return 2 }
  if {$char == 10062} { return 2 }
  if {$char >= 10067 && $char <= 10069 } { return 2 }
  if {$char == 10071} { return 2 }
  if {$char >= 10133 && $char <= 10135 } { return 2 }
  if {$char == 10160} { return 2 }
  if {$char == 10175} { return 2 }
  if {$char >= 11035 && $char <= 11036 } { return 2 }
  if {$char == 11088} { return 2 }
  if {$char == 11093} { return 2 }
  if {$char >= 11904 && $char <= 11929 } { return 2 }
  if {$char >= 11931 && $char <= 12019 } { return 2 }
  if {$char >= 12032 && $char <= 12245 } { return 2 }
  if {$char >= 12272 && $char <= 12283 } { return 2 }
  if {$char == 12288} { return 2 }
  if {$char >= 12289 && $char <= 12291 } { return 2 }
  if {$char == 12292} { return 2 }
  if {$char == 12293} { return 2 }
  if {$char == 12294} { return 2 }
  if {$char == 12295} { return 2 }
  if {$char == 12296} { return 2 }
  if {$char == 12297} { return 2 }
  if {$char == 12298} { return 2 }
  if {$char == 12299} { return 2 }
  if {$char == 12300} { return 2 }
  if {$char == 12301} { return 2 }
  if {$char == 12302} { return 2 }
  if {$char == 12303} { return 2 }
  if {$char == 12304} { return 2 }
  if {$char == 12305} { return 2 }
  if {$char >= 12306 && $char <= 12307 } { return 2 }
  if {$char == 12308} { return 2 }
  if {$char == 12309} { return 2 }
  if {$char == 12310} { return 2 }
  if {$char == 12311} { return 2 }
  if {$char == 12312} { return 2 }
  if {$char == 12313} { return 2 }
  if {$char == 12314} { return 2 }
  if {$char == 12315} { return 2 }
  if {$char == 12316} { return 2 }
  if {$char == 12317} { return 2 }
  if {$char >= 12318 && $char <= 12319 } { return 2 }
  if {$char == 12320} { return 2 }
  if {$char >= 12321 && $char <= 12329 } { return 2 }
  if {$char >= 12330 && $char <= 12333 } { return 2 }
  if {$char >= 12334 && $char <= 12335 } { return 2 }
  if {$char == 12336} { return 2 }
  if {$char >= 12337 && $char <= 12341 } { return 2 }
  if {$char >= 12342 && $char <= 12343 } { return 2 }
  if {$char >= 12344 && $char <= 12346 } { return 2 }
  if {$char == 12347} { return 2 }
  if {$char == 12348} { return 2 }
  if {$char == 12349} { return 2 }
  if {$char == 12350} { return 2 }
  if {$char >= 12353 && $char <= 12438 } { return 2 }
  if {$char >= 12441 && $char <= 12442 } { return 2 }
  if {$char >= 12443 && $char <= 12444 } { return 2 }
  if {$char >= 12445 && $char <= 12446 } { return 2 }
  if {$char == 12447} { return 2 }
  if {$char == 12448} { return 2 }
  if {$char >= 12449 && $char <= 12538 } { return 2 }
  if {$char == 12539} { return 2 }
  if {$char >= 12540 && $char <= 12542 } { return 2 }
  if {$char == 12543} { return 2 }
  if {$char >= 12549 && $char <= 12591 } { return 2 }
  if {$char >= 12593 && $char <= 12686 } { return 2 }
  if {$char >= 12688 && $char <= 12689 } { return 2 }
  if {$char >= 12690 && $char <= 12693 } { return 2 }
  if {$char >= 12694 && $char <= 12703 } { return 2 }
  if {$char >= 12704 && $char <= 12730 } { return 2 }
  if {$char >= 12736 && $char <= 12771 } { return 2 }
  if {$char >= 12784 && $char <= 12799 } { return 2 }
  if {$char >= 12800 && $char <= 12830 } { return 2 }
  if {$char >= 12832 && $char <= 12841 } { return 2 }
  if {$char >= 12842 && $char <= 12871 } { return 2 }
  if {$char == 12880} { return 2 }
  if {$char >= 12881 && $char <= 12895 } { return 2 }
  if {$char >= 12896 && $char <= 12927 } { return 2 }
  if {$char >= 12928 && $char <= 12937 } { return 2 }
  if {$char >= 12938 && $char <= 12976 } { return 2 }
  if {$char >= 12977 && $char <= 12991 } { return 2 }
  if {$char >= 12992 && $char <= 13054 } { return 2 }
  if {$char >= 13056 && $char <= 13311 } { return 2 }
  if {$char >= 13312 && $char <= 19893 } { return 2 }
  if {$char >= 19894 && $char <= 19903 } { return 2 }
  if {$char >= 19968 && $char <= 40943 } { return 2 }
  if {$char >= 40944 && $char <= 40959 } { return 2 }
  if {$char >= 40960 && $char <= 40980 } { return 2 }
  if {$char == 40981} { return 2 }
  if {$char >= 40982 && $char <= 42124 } { return 2 }
  if {$char >= 42128 && $char <= 42182 } { return 2 }
  if {$char >= 43360 && $char <= 43388 } { return 2 }
  if {$char >= 44032 && $char <= 55203 } { return 2 }
  if {$char >= 63744 && $char <= 64109 } { return 2 }
  if {$char >= 64110 && $char <= 64111 } { return 2 }
  if {$char >= 64112 && $char <= 64217 } { return 2 }
  if {$char >= 64218 && $char <= 64255 } { return 2 }
  if {$char >= 65040 && $char <= 65046 } { return 2 }
  if {$char == 65047} { return 2 }
  if {$char == 65048} { return 2 }
  if {$char == 65049} { return 2 }
  if {$char == 65072} { return 2 }
  if {$char >= 65073 && $char <= 65074 } { return 2 }
  if {$char >= 65075 && $char <= 65076 } { return 2 }
  if {$char == 65077} { return 2 }
  if {$char == 65078} { return 2 }
  if {$char == 65079} { return 2 }
  if {$char == 65080} { return 2 }
  if {$char == 65081} { return 2 }
  if {$char == 65082} { return 2 }
  if {$char == 65083} { return 2 }
  if {$char == 65084} { return 2 }
  if {$char == 65085} { return 2 }
  if {$char == 65086} { return 2 }
  if {$char == 65087} { return 2 }
  if {$char == 65088} { return 2 }
  if {$char == 65089} { return 2 }
  if {$char == 65090} { return 2 }
  if {$char == 65091} { return 2 }
  if {$char == 65092} { return 2 }
  if {$char >= 65093 && $char <= 65094 } { return 2 }
  if {$char == 65095} { return 2 }
  if {$char == 65096} { return 2 }
  if {$char >= 65097 && $char <= 65100 } { return 2 }
  if {$char >= 65101 && $char <= 65103 } { return 2 }
  if {$char >= 65104 && $char <= 65106 } { return 2 }
  if {$char >= 65108 && $char <= 65111 } { return 2 }
  if {$char == 65112} { return 2 }
  if {$char == 65113} { return 2 }
  if {$char == 65114} { return 2 }
  if {$char == 65115} { return 2 }
  if {$char == 65116} { return 2 }
  if {$char == 65117} { return 2 }
  if {$char == 65118} { return 2 }
  if {$char >= 65119 && $char <= 65121 } { return 2 }
  if {$char == 65122} { return 2 }
  if {$char == 65123} { return 2 }
  if {$char >= 65124 && $char <= 65126 } { return 2 }
  if {$char == 65128} { return 2 }
  if {$char == 65129} { return 2 }
  if {$char >= 65130 && $char <= 65131 } { return 2 }
  if {$char >= 65281 && $char <= 65283 } { return 2 }
  if {$char == 65284} { return 2 }
  if {$char >= 65285 && $char <= 65287 } { return 2 }
  if {$char == 65288} { return 2 }
  if {$char == 65289} { return 2 }
  if {$char == 65290} { return 2 }
  if {$char == 65291} { return 2 }
  if {$char == 65292} { return 2 }
  if {$char == 65293} { return 2 }
  if {$char >= 65294 && $char <= 65295 } { return 2 }
  if {$char >= 65296 && $char <= 65305 } { return 2 }
  if {$char >= 65306 && $char <= 65307 } { return 2 }
  if {$char >= 65308 && $char <= 65310 } { return 2 }
  if {$char >= 65311 && $char <= 65312 } { return 2 }
  if {$char >= 65313 && $char <= 65338 } { return 2 }
  if {$char == 65339} { return 2 }
  if {$char == 65340} { return 2 }
  if {$char == 65341} { return 2 }
  if {$char == 65342} { return 2 }
  if {$char == 65343} { return 2 }
  if {$char == 65344} { return 2 }
  if {$char >= 65345 && $char <= 65370 } { return 2 }
  if {$char == 65371} { return 2 }
  if {$char == 65372} { return 2 }
  if {$char == 65373} { return 2 }
  if {$char == 65374} { return 2 }
  if {$char == 65375} { return 2 }
  if {$char == 65376} { return 2 }
  if {$char >= 65504 && $char <= 65505 } { return 2 }
  if {$char == 65506} { return 2 }
  if {$char == 65507} { return 2 }
  if {$char == 65508} { return 2 }
  if {$char >= 65509 && $char <= 65510 } { return 2 }
  if {$char >= 94176 && $char <= 94177 } { return 2 }
  if {$char >= 94208 && $char <= 100337 } { return 2 }
  if {$char >= 100352 && $char <= 101106 } { return 2 }
  if {$char >= 110592 && $char <= 110847 } { return 2 }
  if {$char >= 110848 && $char <= 110878 } { return 2 }
  if {$char >= 110960 && $char <= 111355 } { return 2 }
  if {$char == 126980} { return 2 }
  if {$char == 127183} { return 2 }
  if {$char == 127374} { return 2 }
  if {$char >= 127377 && $char <= 127386 } { return 2 }
  if {$char >= 127488 && $char <= 127490 } { return 2 }
  if {$char >= 127504 && $char <= 127547 } { return 2 }
  if {$char >= 127552 && $char <= 127560 } { return 2 }
  if {$char >= 127568 && $char <= 127569 } { return 2 }
  if {$char >= 127584 && $char <= 127589 } { return 2 }
  if {$char >= 127744 && $char <= 127776 } { return 2 }
  if {$char >= 127789 && $char <= 127797 } { return 2 }
  if {$char >= 127799 && $char <= 127868 } { return 2 }
  if {$char >= 127870 && $char <= 127891 } { return 2 }
  if {$char >= 127904 && $char <= 127946 } { return 2 }
  if {$char >= 127951 && $char <= 127955 } { return 2 }
  if {$char >= 127968 && $char <= 127984 } { return 2 }
  if {$char == 127988} { return 2 }
  if {$char >= 127992 && $char <= 127994 } { return 2 }
  if {$char >= 127995 && $char <= 127999 } { return 2 }
  if {$char >= 128000 && $char <= 128062 } { return 2 }
  if {$char == 128064} { return 2 }
  if {$char >= 128066 && $char <= 128252 } { return 2 }
  if {$char >= 128255 && $char <= 128317 } { return 2 }
  if {$char >= 128331 && $char <= 128334 } { return 2 }
  if {$char >= 128336 && $char <= 128359 } { return 2 }
  if {$char == 128378} { return 2 }
  if {$char >= 128405 && $char <= 128406 } { return 2 }
  if {$char == 128420} { return 2 }
  if {$char >= 128507 && $char <= 128511 } { return 2 }
  if {$char >= 128512 && $char <= 128591 } { return 2 }
  if {$char >= 128640 && $char <= 128709 } { return 2 }
  if {$char == 128716} { return 2 }
  if {$char >= 128720 && $char <= 128722 } { return 2 }
  if {$char >= 128747 && $char <= 128748 } { return 2 }
  if {$char >= 128756 && $char <= 128761 } { return 2 }
  if {$char >= 129296 && $char <= 129342 } { return 2 }
  if {$char >= 129344 && $char <= 129392 } { return 2 }
  if {$char >= 129395 && $char <= 129398 } { return 2 }
  if {$char == 129402} { return 2 }
  if {$char >= 129404 && $char <= 129442 } { return 2 }
  if {$char >= 129456 && $char <= 129465 } { return 2 }
  if {$char >= 129472 && $char <= 129474 } { return 2 }
  if {$char >= 129488 && $char <= 129535 } { return 2 }
  if {$char >= 131072 && $char <= 173782 } { return 2 }
  if {$char >= 173783 && $char <= 173823 } { return 2 }
  if {$char >= 173824 && $char <= 177972 } { return 2 }
  if {$char >= 177973 && $char <= 177983 } { return 2 }
  if {$char >= 177984 && $char <= 178205 } { return 2 }
  if {$char >= 178206 && $char <= 178207 } { return 2 }
  if {$char >= 178208 && $char <= 183969 } { return 2 }
  if {$char >= 183970 && $char <= 183983 } { return 2 }
  if {$char >= 183984 && $char <= 191456 } { return 2 }
  if {$char >= 191457 && $char <= 194559 } { return 2 }
  if {$char >= 194560 && $char <= 195101 } { return 2 }
  if {$char >= 195102 && $char <= 195103 } { return 2 }
  if {$char >= 195104 && $char <= 196605 } { return 2 }
  if {$char >= 196608 && $char <= 262141 } { return 2 }
  return 1
}

proc ::textutil::wcswidth {string} {
  set width 0
  set len [string length $string]
  foreach c [split $string {}] {
    scan $c %c char
    set n [::textutil::wcswidth_char $char]
    if {$n < 0} {
      return -1
    }
    incr width $n
  }
  return $width
}

                                                                                        tackle.vfs/lib/textutil/tabify.tcl                                                                  100644  1751    1751    23170       14145011620 22272   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        #
# As the author of the procs 'tabify2' and 'untabify2' I suggest that the
# comments explaining their behaviour be kept in this file.
# 1) Beginners in any programming language (I am new to Tcl so I know what I
#    am talking about) can profit enormously from studying 'correct' code.
#    Of course comments will help a lot in this regard.
# 2) Many problems newbies face can be solved by directing them towards
#    available libraries - after all, libraries have been written to solve
#    recurring problems. Then they can just use them, or have a closer look
#    to see and to discover how things are done the 'Tcl way'.
# 3) And if ever a proc from a library should be less than perfect, having
#    comments explaining the behaviour of the code will surely help.
#
# This said, I will welcome any error reports or suggestions for improvements
# (especially on the 'doing things the Tcl way' aspect).
#
# Use of these sources is licensed under the same conditions as is Tcl.
#
# June 2001, Helmut Giese (hgiese@ratiosoft.com)
#
# ----------------------------------------------------------------------------
#
# The original procs 'tabify' and 'untabify' each work with complete blocks
# of $num spaces ('num' holding the tab size). While this is certainly useful
# in some circumstances, it does not reflect the way an editor works:
# 	Counting columns from 1, assuming a tab size of 8 and entering '12345'
#   followed by a tab, you expect to advance to column 9. Your editor might
#   put a tab into the file or 3 spaces, depending on its configuration.
#	Now, on 'tabifying' you will expect to see those 3 spaces converted to a
#	tab (and on the other hand expect the tab *at this position* to be
#	converted to 3 spaces).
#
#	This behaviour is mimicked by the new procs 'tabify2' and 'untabify2'.
#   Both have one feature in common: They accept multi-line strings (a whole
#   file if you want to) but in order to make life simpler for the programmer,
#   they split the incoming string into individual lines and hand each line to
#   a proc that does the real work.
#
#   One design decision worth mentioning here:
#      A single space is never converted to a tab even if its position would
#      allow to do so.
#   Single spaces occur very often, say in arithmetic expressions like
#   [expr (($a + $b) * $c) < $d]. If we didn't follow the above rule we might
#   need to replace one or more of them to tabs. However if the tab size gets
#   changed, this expression would be formatted quite differently - which is
#   probably not a good idea.
#
#   'untabifying' on the other hand might need to replace a tab with a single
#   space: If the current position requires it, what else to do?
#   As a consequence those two procs are unsymmetric in this aspect, but I
#   couldn't think of a better solution. Could you?
#
# ----------------------------------------------------------------------------
#

# ### ### ### ######### ######### #########
## Requirements

package require Tcl 8.2
package require textutil::repeat

namespace eval ::textutil::tabify {}

# ### ### ### ######### ######### #########
## API implementation

namespace eval ::textutil::tabify {
    namespace import -force ::textutil::repeat::strRepeat
}

proc ::textutil::tabify::tabify { string { num 8 } } {
    return [string map [list [MakeTabStr $num] \t] $string]
}

proc ::textutil::tabify::untabify { string { num 8 } } {
    return [string map [list \t [MakeTabStr $num]] $string]
}

proc ::textutil::tabify::MakeTabStr { num } {
    variable TabStr
    variable TabLen

    if { $TabLen != $num } then {
	set TabLen $num
	set TabStr [strRepeat " " $num]
    }

    return $TabStr
}

# ----------------------------------------------------------------------------
#
# tabifyLine: Works on a single line of text, replacing 'spaces at correct
# 		positions' with tabs. $num is the requested tab size.
#		Returns the (possibly modified) line.
#
# 'spaces at correct positions': Only spaces which 'fill the space' between
# an arbitrary position and the next tab stop can be replaced. 
# Example: With tab size 8, spaces at positions 11 - 13 will *not* be replaced,
#          because an expansion of a tab at position 11 will jump up to 16.
# See also the comment at the beginning of this file why single spaces are
# *never* replaced by a tab.
#
# The proc works backwards, from the end of the string up to the beginning:
#	- Set the position to start the search from ('lastPos') to 'end'.
#	- Find the last occurrence of ' ' in 'line' with respect to 'lastPos'
#         ('currPos' below). This is a candidate for replacement.
#       - Find to 'currPos' the following tab stop using the expression
#           set nextTab [expr ($currPos + $num) - ($currPos % $num)]
#         and get the previous tab stop as well (this will be the starting 
#         point for the next iteration).
#	- The ' ' at 'currPos' is only a candidate for replacement if
#	  1) it is just one position before a tab stop *and*
#	  2) there is at least one space at its left (see comment above on not
#	     touching an isolated space).
#	  Continue, if any of these conditions is not met.
#	- Determine where to put the tab (that is: how many spaces to replace?)
#	  by stepping up to the beginning until
#		-- you hit a non-space or
#		-- you are at the previous tab position
#	- Do the replacement and continue.
#
# This algorithm only works, if $line does not contain tabs. Otherwise our 
# interpretation of any position beyond the tab will be wrong. (Imagine you 
# find a ' ' at position 4 in $line. If you got 3 leading tabs, your *real*
# position might be 25 (tab size of 8). Since in real life some strings might 
# already contain tabs, we test for it (and eventually call untabifyLine).
#

proc ::textutil::tabify::tabifyLine { line num } {
    if { [string first \t $line] != -1 } { 		
	# assure array 'Spaces' is set up 'comme il faut'
	checkArr $num
	# remove existing tabs
	set line [untabifyLine $line $num]
    }

    set lastPos end

    while { $lastPos > 0 } {
	set currPos [string last " " $line $lastPos]
	if { $currPos == -1 } {
	    # no more spaces
	    break;
	}

	set nextTab [expr {($currPos + $num) - ($currPos % $num)}]
	set prevTab [expr {$nextTab - $num}]

	# prepare for next round: continue at 'previous tab stop - 1'
	set lastPos [expr {$prevTab - 1}]

	if { ($currPos + 1) != $nextTab } {
	    continue			;# crit. (1)
	}

	if { [string index $line [expr {$currPos - 1}]] != " " } {
	    continue			;# crit. (2)
	}

	# now step backwards while there are spaces
	for {set pos [expr {$currPos - 2}]} {$pos >= $prevTab} {incr pos -1} {
	    if { [string index $line $pos] != " " } {
		break;
	    }
	}

	# ... and replace them
	set line [string replace $line [expr {$pos + 1}] $currPos \t]
    }
    return $line
}

#
# Helper proc for 'untabifyLine': Checks if all needed elements of array
# 'Spaces' exist and creates the missing ones if needed.
#

proc ::textutil::tabify::checkArr { num } {
    variable TabLen2
    variable Spaces

    if { $num > $TabLen2 } {
	for { set i [expr {$TabLen2 + 1}] } { $i <= $num } { incr i } {
	    set Spaces($i) [strRepeat " " $i]
	}
	set TabLen2 $num
    }
}


# untabifyLine: Works on a single line of text, replacing tabs with enough
#		spaces to get to the next tab position.
#		Returns the (possibly modified) line.
#
# The procedure is straight forward:
#	- Find the next tab.
#	- Calculate the next tab position following it.
#	- Delete the tab and insert as many spaces as needed to get there.
#

proc ::textutil::tabify::untabifyLine { line num } {
    variable Spaces

    set currPos 0
    while { 1 } {
	set currPos [string first \t $line $currPos]
	if { $currPos == -1 } {
	    # no more tabs
	    break
	}

	# how far is the next tab position ?
	set dist [expr {$num - ($currPos % $num)}]
	# replace '\t' at $currPos with $dist spaces
	set line [string replace $line $currPos $currPos $Spaces($dist)]

	# set up for next round (not absolutely necessary but maybe a trifle
	# more efficient)
	incr currPos $dist
    }
    return $line
}

# tabify2: Replace all 'appropriate' spaces as discussed above with tabs.
#	'string' might hold any number of lines, 'num' is the requested tab size.
#	Returns (possibly modified) 'string'.
#
proc ::textutil::tabify::tabify2 { string { num 8 } } {

    # split string into individual lines
    set inLst [split $string \n]

    # now work on each line
    set outLst [list]
    foreach line $inLst {
	lappend outLst [tabifyLine $line $num]
    }

    # return all as one string
    return [join $outLst \n]
}


# untabify2: Replace all tabs with the appropriate number of spaces.
#	'string' might hold any number of lines, 'num' is the requested tab size.
#	Returns (possibly modified) 'string'.
#
proc ::textutil::tabify::untabify2 { string { num 8 } } {

    # assure array 'Spaces' is set up 'comme il faut'
    checkArr $num

    set inLst [split $string \n]

    set outLst [list]
    foreach line $inLst {
	lappend outLst [untabifyLine $line $num]
    }

    return [join $outLst \n]
}



# ### ### ### ######### ######### #########
## Data structures

namespace eval ::textutil::tabify {
    variable TabLen  8
    variable TabStr  [strRepeat " " $TabLen]

    namespace export tabify untabify tabify2 untabify2
    
    # The proc 'untabify2' uses the following variables for efficiency.
    # Since a tab can be replaced by one up to 'tab size' spaces, it is handy
    # to have the appropriate 'space strings' available. This is the use of
    # the array 'Spaces', where 'Spaces(n)' contains just 'n' spaces.
    # The variable 'TabLen2' remembers the biggest tab size used.

    variable  TabLen2 0
    variable  Spaces
    array set Spaces {0 ""}
}

# ### ### ### ######### ######### #########
## Ready

package provide textutil::tabify 0.7
                                                                                                                                                                                                                                                                                                                                                                                                        tackle.vfs/lib/textutil/expander.tcl                                                                100644  1751    1751    67465       14145011620 22641   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        #---------------------------------------------------------------------
# TITLE:
#	expander.tcl
#
# AUTHOR:
#	Will Duquette
#
# DESCRIPTION:
#
# An expander is an object that takes as input text with embedded
# Tcl code and returns text with the embedded code expanded.  The
# text can be provided all at once or incrementally.
#
# See  expander.[e]html for usage info.
# Also expander.n
#
# LICENSE:
#       Copyright (C) 2001 by William H. Duquette.  See expander_license.txt,
#       distributed with this file, for license information.
#
# CHANGE LOG:
#
#       10/31/01: V0.9 code is complete.
#       11/23/01: Added "evalcmd"; V1.0 code is complete.

# Provide the package.

# Create the package's namespace.

namespace eval ::textutil {
    namespace eval expander {
	# All indices are prefixed by "$exp-".
	#
	# lb		    The left bracket sequence
	# rb		    The right bracket sequence
	# errmode	    How to handle macro errors: 
	#		    nothing, macro, error, fail.
        # evalcmd           The evaluation command.
	# textcmd           The plain text processing command.
	# level		    The context level
	# output-$level     The accumulated text at this context level.
	# name-$level       The tag name of this context level
	# data-$level-$var  A variable of this context level     
	
	variable Info
    
	# In methods, the current object:
	variable This ""
	
	# Export public commands
	namespace export expander
    }

    #namespace import expander::*
    namespace export expander

    proc expander {name} {uplevel ::textutil::expander::expander [list $name]}
}

#---------------------------------------------------------------------
# FUNCTION:
# 	expander name
#
# INPUTS:
#	name		A proc name for the new object.  If not
#                       fully-qualified, it is assumed to be relative
#                       to the caller's namespace.
#
# RETURNS:
#	nothing
#
# DESCRIPTION:
#	Creates a new expander object.

proc ::textutil::expander::expander {name} {
    variable Info

    # FIRST, qualify the name.
    if {![string match "::*" $name]} {
        # Get caller's namespace; append :: if not global namespace.
        set ns [uplevel 1 namespace current]
        if {"::" != $ns} {
            append ns "::"
        }
        
        set name "$ns$name"
    }

    # NEXT, Check the name
    if {"" != [info commands $name]} {
        return -code error "command name \"$name\" already exists"
    }

    # NEXT, Create the object.
    proc $name {method args} [format {
        if {[catch {::textutil::expander::Methods %s $method $args} result]} {
            return -code error $result
        } else {
            return $result
        }
    } $name]

    # NEXT, Initialize the object
    Op_reset $name
    
    return $name
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Methods name method argList
#
# INPUTS:
#	name		The object's fully qualified procedure name.
#			This argument is provided by the object command
#			itself.
#	method		The method to call.
#	argList		Arguments for the specific method.
#
# RETURNS:
#	Depends on the method
#
# DESCRIPTION:
#	Handles all method dispatch for a expander object.
#       The expander's object command merely passes its arguments to
#	this function, which dispatches the arguments to the
#	appropriate method procedure.  If the method raises an error,
#	the method procedure's name in the error message is replaced
#	by the object and method names.

proc ::textutil::expander::Methods {name method argList} {
    variable Info
    variable This

    switch -exact -- $method {
        expand -
        lb -
        rb -
        setbrackets -
        errmode -
        evalcmd -
	textcmd -
        cpush -
	ctopandclear -
        cis -
        cname -
        cset -
        cget -
        cvar -
        cpop -
        cappend -
	where -
        reset {
            # FIRST, execute the method, first setting This to the object
            # name; then, after the method has been called, restore the
            # old object name.
            set oldThis $This
            set This $name

            set retval [catch "Op_$method $name $argList" result]

            set This $oldThis

            # NEXT, handle the result based on the retval.
            if {$retval} {
                regsub -- "Op_$method" $result "$name $method" result
                return -code error $result
            } else {
                return $result
            }
        }
        default {
            return -code error "\"$name $method\" is not defined"
        }
    }
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Get key
#
# INPUTS:
#	key		A key into the Info array, excluding the
#	                object name.  E.g., "lb"
#
# RETURNS:
#	The value from the array
#
# DESCRIPTION:
#	Gets the value of an entry from Info for This.

proc ::textutil::expander::Get {key} {
    variable Info
    variable This

    return $Info($This-$key)
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Set key value
#
# INPUTS:
#	key		A key into the Info array, excluding the
#	                object name.  E.g., "lb"
#
#	value		A Tcl value
#
# RETURNS:
#	The value
#
# DESCRIPTION:
#	Sets the value of an entry in Info for This.

proc ::textutil::expander::Set {key value} {
    variable Info
    variable This

    return [set Info($This-$key) $value]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Var key
#
# INPUTS:
#	key		A key into the Info array, excluding the
#	                object name.  E.g., "lb"
#
# RETURNS:
#	The full variable name, suitable for setting or lappending

proc ::textutil::expander::Var {key} {
    variable Info
    variable This

    return ::textutil::expander::Info($This-$key)
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Contains list value
#
# INPUTS:
#       list		any list
#	value		any value
#
# RETURNS:
#	TRUE if the list contains the value, and false otherwise.

proc ::textutil::expander::Contains {list value} {
    if {[lsearch -exact $list $value] == -1} {
        return 0
    } else {
        return 1
    }
}


#---------------------------------------------------------------------
# FUNCTION:
# 	Op_lb ?newbracket?
#
# INPUTS:
#	newbracket		If given, the new bracket token.
#
# RETURNS:
#	The current left bracket
#
# DESCRIPTION:
#	Returns the current left bracket token.

proc ::textutil::expander::Op_lb {name {newbracket ""}} {
    if {[string length $newbracket] != 0} {
        Set lb $newbracket
    }
    return [Get lb]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_rb ?newbracket?
#
# INPUTS:
#	newbracket		If given, the new bracket token.
#
# RETURNS:
#	The current left bracket
#
# DESCRIPTION:
#	Returns the current left bracket token.

proc ::textutil::expander::Op_rb {name {newbracket ""}} {
    if {[string length $newbracket] != 0} {
        Set rb $newbracket
    }
    return [Get rb]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_setbrackets lbrack rbrack
#
# INPUTS:
#	lbrack		The new left bracket
#	rbrack		The new right bracket
#
# RETURNS:
#	nothing
#
# DESCRIPTION:
#	Sets the brackets as a pair.

proc ::textutil::expander::Op_setbrackets {name lbrack rbrack} {
    Set lb $lbrack
    Set rb $rbrack
    return
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_errmode ?newErrmode?
#
# INPUTS:
#	newErrmode		If given, the new error mode.
#
# RETURNS:
#	The current error mode
#
# DESCRIPTION:
#	Returns the current error mode.

proc ::textutil::expander::Op_errmode {name {newErrmode ""}} {
    if {[string length $newErrmode] != 0} {
        if {![Contains "macro nothing error fail" $newErrmode]} {
            error "$name errmode: Invalid error mode: $newErrmode"
        }

        Set errmode $newErrmode
    }
    return [Get errmode]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_evalcmd ?newEvalCmd?
#
# INPUTS:
#	newEvalCmd		If given, the new eval command.
#
# RETURNS:
#	The current eval command
#
# DESCRIPTION:
#	Returns the current eval command.  This is the command used to
#	evaluate macros; it defaults to "uplevel #0".

proc ::textutil::expander::Op_evalcmd {name {newEvalCmd ""}} {
    if {[string length $newEvalCmd] != 0} {
        Set evalcmd $newEvalCmd
    }
    return [Get evalcmd]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_textcmd ?newTextCmd?
#
# INPUTS:
#	newTextCmd		If given, the new text command.
#
# RETURNS:
#	The current text command
#
# DESCRIPTION:
#	Returns the current text command.  This is the command used to
#	process plain text. It defaults to {}, meaning identity.

proc ::textutil::expander::Op_textcmd {name args} {
    switch -exact [llength $args] {
	0 {}
	1 {Set textcmd [lindex $args 0]}
	default {
	    return -code error "wrong#args for textcmd: name ?newTextcmd?"
	}
    }
    return [Get textcmd]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_reset
#
# INPUTS:
#	none
#
# RETURNS:
#	nothing
#
# DESCRIPTION:
#	Resets all object values, as though it were brand new.

proc ::textutil::expander::Op_reset {name} {
    variable Info 

    if {[info exists Info($name-lb)]} {
        foreach elt [array names Info "$name-*"] {
            unset Info($elt)
        }
    }

    set Info($name-lb) "\["
    set Info($name-rb) "\]"
    set Info($name-errmode) "fail"
    set Info($name-evalcmd) "uplevel #0"
    set Info($name-textcmd) ""
    set Info($name-level) 0
    set Info($name-output-0) ""
    set Info($name-name-0) ":0"

    return
}

#-------------------------------------------------------------------------
# Context: Every expansion takes place in its own context; however, 
# a macro can push a new context, causing the text it returns and all
# subsequent text to be saved separately.  Later, a matching macro can
# pop the context, acquiring all text saved since the first command,
# and use that in its own output.

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_cpush cname
#
# INPUTS:
#	cname		The context name
#
# RETURNS:
#	nothing
#
# DESCRIPTION:
#       Pushes an empty macro context onto the stack.  All expanded text
#       will be added to this context until it is popped.

proc ::textutil::expander::Op_cpush {name cname} {
    # FRINK: nocheck
    incr [Var level]
    # FRINK: nocheck
    set [Var output-[Get level]] {}
    # FRINK: nocheck
    set [Var name-[Get level]] $cname

    # The first level is init'd elsewhere (Op_expand)
    if {[set [Var level]] < 2} return

    # Initialize the location information, inherit from the outer
    # context.

    LocInit $cname
    catch {LocSet $cname [LocGet $name]}
    return    
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_cis cname
#
# INPUTS:
#	cname		A context name
#
# RETURNS:
#	true or false
#
# DESCRIPTION:
#       Returns true if the current context has the specified name, and
#	false otherwise.

proc ::textutil::expander::Op_cis {name cname} {
    return [expr {[string compare $cname [Op_cname $name]] == 0}]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_cname
#
# INPUTS:
#	none
#
# RETURNS:
#	The context name
#
# DESCRIPTION:
#       Returns the name of the current context.

proc ::textutil::expander::Op_cname {name} {
    return [Get name-[Get level]]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_cset varname value
#
# INPUTS:
#	varname		The name of a context variable
#	value		The new value for the context variable
#
# RETURNS:
#	The value
#
# DESCRIPTION:
#       Sets a variable in the current context.

proc ::textutil::expander::Op_cset {name varname value} {
    Set data-[Get level]-$varname $value
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_cget varname
#
# INPUTS:
#	varname		The name of a context variable
#
# RETURNS:
#	The value
#
# DESCRIPTION:
#       Returns the value of a context variable.  It's an error if
#	the variable doesn't exist.

proc ::textutil::expander::Op_cget {name varname} {
    if {![info exists [Var data-[Get level]-$varname]]} {
        error "$name cget: $varname doesn't exist in this context ([Get level])"
    }
    return [Get data-[Get level]-$varname]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_cvar varname
#
# INPUTS:
#	varname		The name of a context variable
#
# RETURNS:
#	The index to the variable
#
# DESCRIPTION:
#       Returns the index to a context variable, for use with set, 
#	lappend, etc.

proc ::textutil::expander::Op_cvar {name varname} {
    if {![info exists [Var data-[Get level]-$varname]]} {
        error "$name cvar: $varname doesn't exist in this context"
    }

    return [Var data-[Get level]-$varname]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_cpop cname
#
# INPUTS:
#	cname		The expected context name.
#
# RETURNS:
#	The accumulated output in this context
#
# DESCRIPTION:
#       Returns the accumulated output for the current context, first
#	popping the context from the stack.  The expected context name
#	must match the real name, or an error occurs.

proc ::textutil::expander::Op_cpop {name cname} {
    variable Info

    if {[Get level] == 0} {
        error "$name cpop underflow on '$cname'"
    }

    if {[string compare [Op_cname $name] $cname] != 0} {
        error "$name cpop context mismatch: expected [Op_cname $name], got $cname"
    }

    set result [Get output-[Get level]]
    # FRINK: nocheck
    set [Var output-[Get level]] ""
    # FRINK: nocheck
    set [Var name-[Get level]] ""

    foreach elt [array names "Info data-[Get level]-*"] {
        unset Info($elt)
    }

    # FRINK: nocheck
    incr [Var level] -1
    return $result
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_ctopandclear
#
# INPUTS:
#	None.
#
# RETURNS:
#	The accumulated output in the topmost context, clears the context,
#	but does not pop it.
#
# DESCRIPTION:
#       Returns the accumulated output for the current context, first
#	popping the context from the stack.  The expected context name
#	must match the real name, or an error occurs.

proc ::textutil::expander::Op_ctopandclear {name} {
    variable Info

    if {[Get level] == 0} {
        error "$name cpop underflow on '[Op_cname $name]'"
    }

    set result [Get output-[Get level]]
    Set output-[Get level] ""
    return $result
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_cappend text
#
# INPUTS:
#	text		Text to add to the output
#
# RETURNS:
#	The accumulated output
#
# DESCRIPTION:
#       Appends the text to the accumulated output in the current context.

proc ::textutil::expander::Op_cappend {name text} {
    # FRINK: nocheck
    append [Var output-[Get level]] $text
}

#-------------------------------------------------------------------------
# Macro-expansion:  The following code is the heart of the module.
# Given a text string, and the current variable settings, this code
# returns an expanded string, with all macros replaced.

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_expand inputString ?brackets?
#
# INPUTS:
#	inputString		The text to expand.
#	brackets		A list of two bracket tokens.
#
# RETURNS:
#	The expanded text.
#
# DESCRIPTION:
#	Finds all embedded macros in the input string, and expands them.
#	If ?brackets? is given, it must be list of length 2, containing
#	replacement left and right macro brackets; otherwise the default
#	brackets are used.

proc ::textutil::expander::Op_expand {name inputString {brackets ""}} {
    # FIRST, push a new context onto the stack, and save the current
    # brackets.

    Op_cpush $name expand
    Op_cset $name lb [Get lb]
    Op_cset $name rb [Get rb]

    # Keep position information in context variables as well.
    # Line we are in, counting from 1; column we are at,
    # counting from 0, and index of character we are at,
    # counting from 0. Tabs counts as '1' when computing
    # the column.

    LocInit $name

    # SF Tcllib Bug #530056.
    set start_level [Get level] ; # remember this for check at end

    # NEXT, use the user's brackets, if given.
    if {[llength $brackets] == 2} {
        Set lb [lindex $brackets 0]
        Set rb [lindex $brackets 1]
    }

    # NEXT, loop over the string, finding and expanding macros.
    while {[string length $inputString] > 0} {
        set plainText [ExtractToToken inputString [Get lb] exclude]

        # FIRST, If there was plain text, append it to the output, and 
        # continue.
        if {$plainText != ""} {
	    set input $plainText
	    set tc [Get textcmd]
	    if {[string length $tc] > 0} {
		lappend tc $plainText

		if {![catch "[Get evalcmd] [list $tc]" result]} {
		    set plainText $result
		} else {
		    HandleError $name {plain text} $tc $result
		}
	    }
            Op_cappend $name $plainText
	    LocUpdate  $name $input

            if {[string length $inputString] == 0} {
                break
            }
        }

        # NEXT, A macro is the next thing; process it.
        if {[catch {GetMacro inputString} macro]} {
	    # SF tcllib bug 781973 ... Do not throw a regular
	    # error. Use HandleError to give the user control of the
	    # situation, via the defined error mode. The continue
	    # intercepts if the user allows the expansion to run on,
	    # yet we must not try to run the non-existing macro.

	    HandleError $name {reading macro} $inputString $macro
	    continue
        }

        # Expand the macro, and output the result, or
        # handle an error.
        if {![catch "[Get evalcmd] [list $macro]" result]} {
            Op_cappend $name $result 

	    # We have to advance the location by the length of the
	    # macro, plus the two brackets. They were stripped by
	    # GetMacro, so we have to add them here again to make
	    # computation correct.

	    LocUpdate $name [Get lb]${macro}[Get rb]
            continue
        } 

	HandleError $name macro $macro $result
    }

    # SF Tcllib Bug #530056.
    if {[Get level] > $start_level} {
	# The user macros pushed additional contexts, but forgot to
	# pop them all. The main work here is to place all the still
	# open contexts into the error message, and to produce
	# syntactically correct english.

	set c [list]
	set n [expr {[Get level] - $start_level}]
	if {$n == 1} {
	    set ctx  context
	    set verb was
	} else {
	    set ctx  contexts
	    set verb were
	}
	for {incr n -1} {$n >= 0} {incr n -1} {
	    lappend c [Get name-[expr {[Get level]-$n}]]
	}
	return -code error \
		"The following $ctx pushed by the macros $verb not popped: [join $c ,]."
    } elseif {[Get level] < $start_level} {
	set n [expr {$start_level - [Get level]}]
	if {$n == 1} {
	    set ctx  context
	} else {
	    set ctx  contexts
	}
	return -code error \
		"The macros popped $n more $ctx than they had pushed."
    }

    Op_lb $name [Op_cget $name lb]
    Op_rb $name [Op_cget $name rb]

    return [Op_cpop $name expand]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	Op_where
#
# INPUTS:
#	None.
#
# RETURNS:
#	The current location in the input.
#
# DESCRIPTION:
#	Retrieves the current location the expander
#	is at during processing.

proc ::textutil::expander::Op_where {name} {
    return [LocGet $name]
}

#---------------------------------------------------------------------
# FUNCTION
#	HandleError name title command errmsg
#
# INPUTS:
#	name		The name of the expander object in question.
#	title		A title text
#	command		The command which caused the error.
#	errmsg		The error message to report
#
# RETURNS:
#	Nothing
#
# DESCRIPTIONS
#	Is executed when an error in a macro or the plain text handler
#	occurs. Generates an error message according to the current
#	error mode.

proc ::textutil::expander::HandleError {name title command errmsg} {
    switch [Get errmode] {
	nothing { }
	macro {
	    # The location is irrelevant here.
	    Op_cappend $name "[Get lb]$command[Get rb]" 
	}
	error {
	    foreach {ch line col} [LocGet $name] break
	    set display [DisplayOf $command]

	    Op_cappend $name "\n=================================\n"
	    Op_cappend $name "*** Error in $title at line $line, column $col:\n"
	    Op_cappend $name "*** [Get lb]$display[Get rb]\n--> $errmsg\n"
	    Op_cappend $name "=================================\n"
	}
	fail   { 
	    foreach {ch line col} [LocGet $name] break
	    set display [DisplayOf $command]

	    return -code error "Error in $title at line $line,\
		    column $col:\n[Get lb]$display[Get rb]\n-->\
		    $errmsg"
	}
	default {
	    return -code error "Unknown error mode: [Get errmode]"
	}
    }
}

#---------------------------------------------------------------------
# FUNCTION:
# 	ExtractToToken string token mode
#
# INPUTS:
#	string		The text to process.
#	token		The token to look for
#	mode		include or exclude
#
# RETURNS:
#	The extracted text
#
# DESCRIPTION:
# 	Extract text from a string, up to or including a particular
# 	token.  Remove the extracted text from the string.
# 	mode determines whether the found token is removed;
# 	it should be "include" or "exclude".  The string is
# 	modified in place, and the extracted text is returned.

proc ::textutil::expander::ExtractToToken {string token mode} {
    upvar $string theString

    # First, determine the offset
    switch $mode {
        include { set offset [expr {[string length $token] - 1}] }
        exclude { set offset -1 }
        default { error "::expander::ExtractToToken: unknown mode $mode" }
    }

    # Next, find the first occurrence of the token.
    set tokenPos [string first $token $theString]

    # Next, return the entire string if it wasn't found, or just
    # the part upto or including the character.
    if {$tokenPos == -1} {
        set theText $theString
        set theString ""
    } else {
        set newEnd    [expr {$tokenPos + $offset}]
        set newBegin  [expr {$newEnd + 1}]
        set theText   [string range $theString 0 $newEnd]
        set theString [string range $theString $newBegin end]
    }

    return $theText
}

#---------------------------------------------------------------------
# FUNCTION:
# 	GetMacro string
#
# INPUTS:
#	string		The text to process.
#
# RETURNS:
#	The macro, stripped of its brackets.
#
# DESCRIPTION:

proc ::textutil::expander::GetMacro {string} {
    upvar $string theString

    # FIRST, it's an error if the string doesn't begin with a
    # bracket.
    if {[string first [Get lb] $theString] != 0} {
        error "::expander::GetMacro: assertion failure, next text isn't a command! '$theString'"
    }

    # NEXT, extract a full macro
    set macro [ExtractToToken theString [Get lb] include]
    while {[string length $theString] > 0} {
        append macro [ExtractToToken theString [Get rb] include]

        # Verify that the command really ends with the [rb] characters,
        # whatever they are.  If not, break because of unexpected
        # end of file.
        if {![IsBracketed $macro]} {
            break;
        }

        set strippedMacro [StripBrackets $macro]

        if {[info complete "puts \[$strippedMacro\]"]} {
            return $strippedMacro
        }
    }

    if {[string length $macro] > 40} {
        set macro "[string range $macro 0 39]...\n"
    }
    error "Unexpected EOF in macro:\n$macro"
}

# Strip left and right bracket tokens from the ends of a macro,
# provided that it's properly bracketed.
proc ::textutil::expander::StripBrackets {macro} {
    set llen [string length [Get lb]]
    set rlen [string length [Get rb]]
    set tlen [string length $macro]

    return [string range $macro $llen [expr {$tlen - $rlen - 1}]]
}

# Return 1 if the macro is properly bracketed, and 0 otherwise.
proc ::textutil::expander::IsBracketed {macro} {
    set llen [string length [Get lb]]
    set rlen [string length [Get rb]]
    set tlen [string length $macro]

    set leftEnd  [string range $macro 0       [expr {$llen - 1}]]
    set rightEnd [string range $macro [expr {$tlen - $rlen}] end]

    if {$leftEnd != [Get lb]} {
        return 0
    } elseif {$rightEnd != [Get rb]} {
        return 0
    } else {
        return 1
    }
}

#---------------------------------------------------------------------
# FUNCTION:
# 	LocInit name
#
# INPUTS:
#	name		The expander object to use.
#
# RETURNS:
#	No result.
#
# DESCRIPTION:
#	A convenience wrapper around LocSet. Initializes the location
#	to the start of the input (char 0, line 1, column 0).

proc ::textutil::expander::LocInit {name} {
    LocSet $name {0 1 0}
    return
}

#---------------------------------------------------------------------
# FUNCTION:
# 	LocSet name loc
#
# INPUTS:
#	name		The expander object to use.
#	loc		Location, list containing character position,
#			line number and column, in this order.
#
# RETURNS:
#	No result.
#
# DESCRIPTION:
#	Sets the current location in the expander to 'loc'.

proc ::textutil::expander::LocSet {name loc} {
    foreach {ch line col} $loc break
    Op_cset  $name char $ch
    Op_cset  $name line $line
    Op_cset  $name col  $col
    return
}

#---------------------------------------------------------------------
# FUNCTION:
# 	LocGet name
#
# INPUTS:
#	name		The expander object to use.
#
# RETURNS:
#	A list containing the current character position, line number
#	and column, in this order.
#
# DESCRIPTION:
#	Returns the current location as stored in the expander.

proc ::textutil::expander::LocGet {name} {
    list [Op_cget $name char] [Op_cget $name line] [Op_cget $name col]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	LocUpdate name text
#
# INPUTS:
#	name		The expander object to use.
#	text		The text to process.
#
# RETURNS:
#	No result.
#
# DESCRIPTION:
#	Takes the current location as stored in the expander, computes
#	a new location based on the string (its length and contents
#	(number of lines)), and makes that new location the current
#	location.

proc ::textutil::expander::LocUpdate {name text} {
    foreach {ch line col} [LocGet $name] break
    set numchars [string length $text]
    #8.4+ set numlines [regexp -all "\n" $text]
    set numlines [expr {[llength [split $text \n]]-1}]

    incr ch   $numchars
    incr line $numlines
    if {$numlines} {
	set col [expr {$numchars - [string last \n $text] - 1}]
    } else {
	incr col $numchars
    }

    LocSet $name [list $ch $line $col]
    return
}

#---------------------------------------------------------------------
# FUNCTION:
# 	LocRange name text
#
# INPUTS:
#	name		The expander object to use.
#	text		The text to process.
#
# RETURNS:
#	A text range description, compatible with the 'location' data
#	used in the tcl debugger/checker.
#
# DESCRIPTION:
#	Takes the current location as stored in the expander object
#	and the length of the text to generate a character range.

proc ::textutil::expander::LocRange {name text} {
    # Note that the structure is compatible with
    # the ranges uses by tcl debugger and checker.
    # {line {charpos length}}

    foreach {ch line col} [LocGet $name] break
    return [list $line [list $ch [string length $text]]]
}

#---------------------------------------------------------------------
# FUNCTION:
# 	DisplayOf text
#
# INPUTS:
#	text		The text to process.
#
# RETURNS:
#	The text, cut down to at most 30 bytes.
#
# DESCRIPTION:
#	Cuts the incoming text down to contain no more than 30
#	characters of the input. Adds an ellipsis (...) if characters
#	were actually removed from the input.

proc ::textutil::expander::DisplayOf {text} {
    set ellip ""
    while {[string bytelength $text] > 30} {
	set ellip ...
	set text [string range $text 0 end-1]
    }
    set display $text$ellip
}

#---------------------------------------------------------------------
# Provide the package only if the code above was read and executed
# without error.

package provide textutil::expander 1.3.1
                                                                                                                                                                                                           tackle.vfs/lib/textutil/pkgIndex.tcl                                                                100644  1751    1751    1740        14145011620 22544   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        if {![package vsatisfies [package provide Tcl] 8.2]} {
    # FRINK: nocheck
    return
}
package ifneeded textutil           0.9   [list source [file join $dir textutil.tcl]]
package ifneeded textutil::adjust   0.7.3 [list source [file join $dir adjust.tcl]]
package ifneeded textutil::split    0.8   [list source [file join $dir split.tcl]]
package ifneeded textutil::trim     0.7   [list source [file join $dir trim.tcl]]
package ifneeded textutil::tabify   0.7   [list source [file join $dir tabify.tcl]]
package ifneeded textutil::repeat   0.7   [list source [file join $dir repeat.tcl]]
package ifneeded textutil::string   0.8   [list source [file join $dir string.tcl]]
package ifneeded textutil::expander 1.3.1 [list source [file join $dir expander.tcl]]
package ifneeded textutil::wcswidth 35.1  [list source [file join $dir wcswidth.tcl]]

if {![package vsatisfies [package provide Tcl] 8.5]} { return }

package ifneeded textutil::patch 0.1 [list source [file join $dir patch.tcl]]
                                tackle.vfs/lib/textutil/dehypht.tex                                                                 100644  1751    1751    144221      14145011620 22520   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        % This is `dehypht.tex' as of 03 March 1999.
%
% Copyright (C) 1988,1991 Rechenzentrum der Ruhr-Universitaet Bochum
%               [german hyphen patterns]
% Copyright (C) 1993,1994,1999 Bernd Raichle/DANTE e.V.
%               [macros, adaption for TeX 2]
%
% -----------------------------------------------------------------
% IMPORTANT NOTICE:
%
% This program can be redistributed and/or modified under the terms
% of the LaTeX Project Public License Distributed from CTAN
% archives in directory macros/latex/base/lppl.txt; either
% version 1 of the License, or any later version.
% -----------------------------------------------------------------
%
%
% This file contains german hyphen patterns following traditional
% hyphenation rules and includes umlauts and sharp s, but without
% `c-k' and triple consonants.  It is based on hyphen patterns
% containing 5719 german hyphen patterns with umlauts in the
% recommended version of September 27, 1990.
%
% For use with TeX generated by
%
%          Norbert Schwarz
%          Rechenzentrum Ruhr-Universitaet Bochum
%          Universitaetsstrasse 150
%          D-44721 Bochum, FRG
%
%
% Adaption of these patterns for TeX, Version 2.x and 3.x and
% all fonts in T1/`Cork'/EC/DC and/or OT1/CM encoding by
%
%          Bernd Raichle
%          Stettener Str. 73
%          D-73732 Esslingen, FRG
%   Email: raichle@Informatik.Uni-Stuttgart.DE
%
%
% Error reports in case of UNCHANGED versions to
%
%          DANTE e.V., Koordinator `german.sty'
%          Postfach 10 18 40
%          D-69008 Heidelberg, FRG
%   Email: german@Dante.DE
%
% or one of the addresses given above.
%
%
% Changes:
%  1990-09-27 First version of `ghyphen3.tex' (Norbert Schwarz)
%  1991-02-13 PC umlauts changed to ^^xx  (Norbert Schwarz)
%  1993-08-27 Umlauts/\ss changed to "a/\3 macros, added macro
%             definitions and additional logic to select correct
%             patterns/encoding  (Bernd Raichle)
%  1994-02-13 Release of `ghyph31.tex' V3.1a (Bernd Raichle)
%  1999-03-03 Renamed file to `dehypht.tex' according to the
%             naming scheme using the ISO country code `de', the
%             common part `hyph' for all hyphenation patterns files,
%             and the additional postfix `t' for traditional,
%             removed wrong catcode change of ^^e (the comment
%             character %) and ^^f (the character &),
%             do _not_ change \catcode, \lccode, \uccode to avoid
%             problems with other hyphenation pattern files,
%             changed code to distinguish TeX 2.x/3.x,
%             changed license conditions to LPPL (Bernd Raichle)
%
%
% For more information see the additional documentation
% at the end of this file.
%
% -----------------------------------------------------------------
%
\message{German Traditional Hyphenation Patterns %
         `dehypht' Version 3.2a <1999/03/03>}
\message{(Formerly known under the name `ghyph31' and `ghyphen'.)}
%
%
% Next we define some commands which are used inside the patterns.
% To keep them local, we enclose the rest of the file in a group
% (The \patterns command globally changes the hyphenation trie!).
%
\begingroup
%
%
% Make sure that doublequote is not active:
\catcode`\"=12
%
%
% Because ^^e4 is used in the following macros which is read by
% TeX 2.x as ^^e or %, the comment character of TeX, some trick
% has to be found to avoid this problem.  The same is true for the
% character ^^f or & in the TeX 2.x code.
% Therefore in the code the exclamationmark ! is used instead of
% the circumflex ^ and its \catcode is set appropriately
% (normally \catcode`\!=12, in the code \catcode`\!=7).
%
% The following \catcode, \lccode assignments and macro definitions
% are defined in such a way that the following \pattern{...} list
% can be used for both, TeX 2.x and TeX 3.x.
%
% We first change the \lccode of ^^Y to make sure that we can
% include this character in the hyphenation patterns.
%
\catcode`\^^Y=11 \lccode`\^^Y=`\^^Y
%
% Then we have to define some macros depending on the TeX version.
% Therefore we have to distinguish TeX version 2.x and 3.x:
%
\ifnum`\@=`\^^40 % true => TeX 3.x
  %
  % For TeX 3:
  % ----------
  %
  % Assign appropriate \catcode and \lccode values for all
  % accented characters used in the patterns (\uccode changes are
  % not used within \patterns{...} and thus not necessary):
  %
  \catcode"E4=11 \catcode"C4=11 % \"a \"A
  \catcode"F6=11 \catcode"D6=11 % \"o \"O
  \catcode"FC=11 \catcode"DC=11 % \"u \"U
  \catcode"FF=11 \catcode"DF=11 % \ss  SS
  %
  \lccode"C4="E4 \uccode"C4="C4  \lccode"E4="E4 \uccode"E4="C4
  \lccode"D6="F6 \uccode"D6="D6  \lccode"F6="F6 \uccode"F6="D6
  \lccode"DC="FC \uccode"DC="DC  \lccode"FC="FC \uccode"FC="DC
  \lccode"DF="FF \uccode"DF="DF  \lccode"FF="FF \uccode"FF="DF
  %
  % In the following definitions we use ??xy instead of ^^xy
  % to avoid errors when reading the following macro definitions
  % with TeX 2.x (remember ^^e(4) is the comment character):
  %
  \catcode`\?=7
  %
  % Define the accent macro " in such a way that it
  % expands to single letters in font encoding T1.
  \catcode`\"=13
  \def"#1{\ifx#1a??e4\else \ifx#1o??f6\else \ifx#1u??fc\else
      \errmessage{Hyphenation pattern file corrupted!}%
    \fi\fi\fi}
  %
  %   - patterns with umlauts are ok
  \def\n#1{#1}
  %
  % For \ss which exists in T1 _and_ OT1 encoded fonts but with
  % different glyph codes, duplicated patterns for both encodings
  % are included.  Thus you can use these hyphenation patterns for
  % T1 and OT1 encoded fonts:
  %   - define \3 to be code `\^^ff (\ss in font encoding T1)
  %   - define \9 to be code `\^^Y  (\ss in font encoding OT1)
  \def\3{??ff}
  \def\9{??Y}
  %   - duplicated patterns to support font encoding OT1 are ok
  \def\c#1{#1}
  %   >>>>>>  UNCOMMENT the next line, if you do not want
  %   >>>>>>  to use fonts in font encoding OT1
  %\def\c#1{}
  %
  \catcode`\?=12
  %
\else
  %
  % For TeX 2:
  % ----------
  %
  % Define the accent macro " to throw an error message.
  \catcode`\"=13
  \def"#1{\errmessage{Hyphenation pattern file corrupted!}}
  %
  %   - ignore all patterns with umlauts
  \def\n#1{}
  %
  % With TeX 2 fonts in encoding T1 can be used, but all glyphs
  % in positions > 127 can not be used in hyphenation patterns.
  % Thus only patterns with glyphs in OT1 positions are included:
  %   - define \3 to be code ^^Y (\ss in CM font encoding)
  %   - define \9 to throw an error message
  \def\3{^^Y}
  \def\9{\errmessage{Hyphenation pattern file corrupted!}}
  %   - ignore all duplicated patterns with \ss in T1 encoding
  \def\c#1{}
  %
\fi
%
%
\patterns{%
.aa6l .ab3a4s .ab3ei .abi2 .ab3it .ab1l .ab1r .ab3u .ad3o4r .alti6
.ana3c .an5alg .an1e .ang8s .an1s .ap1p .ar6sc .ar6ta .ar6tei .as2z
.au2f1 .au2s3 .be5erb .be3na .ber6t5r .bie6r5 .bim6s5t .brot3 .bru6s
.ch6 .che6f5 .da8c .da2r .dar5in .dar5u .den6ka .de5r6en .des6pe
.de8spo .de3sz .dia3s4 .dien4 .dy2s1 .ehren5 .eine6 .ei6n5eh .ei8nen
.ein5sa .en6der .en6d5r .en3k4 .en8ta8 .en8tei .en4t3r .epo1 .er6ban
.er6b5ei .er6bla .er6d5um .er3ei .er5er .er3in .er3o4b .erwi5s .es1p
.es8t .ex1a2 .ex3em .fal6sc .fe6st5a .flu4g3 .furch8 .ga6ner .ge3n4a
\n{.ge5r"o} .ges6 .halb5 .halbe6 .hal6br .haup4 .hau4t .heima6 .he4r3e
.her6za .he5x .hin3 .hir8sc .ho4c .hu3sa .hy5o .ibe5 .ima6ge .in1
.ini6 .is5chi .jagd5 .kal6k5o .ka6ph .ki4e .kop6f3 .kraf6 \n{.k"u5ra}
.lab6br .liie6 .lo6s5k \n{.l"o4s3t} .ma5d .mi2t1 .no6th .no6top
.obe8ri .ob1l .obs2 .ob6st5e .or3c .ort6s5e .ost3a .oste8r .pe4re
.pe3ts .ph6 .po8str .rau4m3 .re5an .ro8q .ru5the \n{.r"u5be}
\n{.r"u8stet} .sch8 .se6e .se5n6h .se5ra .si2e .spi6ke .st4 .sy2n
.tages5 .tan6kl .ta8th .te6e .te8str .to6der .to8nin .to6we .um1
.umpf4 .un1 .une6 .unge5n .ur1c .ur5en .ve6rin .vora8 .wah6l5 .we8ges
.wo6r .wor3a .wun4s .zi4e .zuch8 \n{."ande8re} \n{."och8} aa1c aa2gr
aal5e aa6r5a a5arti aa2s1t aat2s 6aba ab3art 1abdr 6abel aben6dr
ab5erk ab5err ab5esse 1abf 1abg \n{1abh"a} ab1ir 1abko a1bl ab1la
5ablag a6bla\3 \c{a6bla\9} ab4ler ab1lu \n{a8bl"a} \n{5a6bl"o} abma5c
1abn ab1ra ab1re 5a6brec ab1ro ab1s ab8sk abs2z 3abtei ab1ur 1abw
5abze 5abzu \n{ab1"an} \n{ab"au8} a4ce.  a5chal ach5art ach5au a1che
a8chent ach6er.  a6ch5erf a1chi ach1l ach3m ach5n a1cho ach3re a1chu
ach1w a1chy \n{ach5"af} ack1o acks6t ack5sta a1d 8ad.  a6d5ac ad3ant
ad8ar 5addi a8dein ade5o8 adi5en 1adj 1adle ad1op a2dre 3adres adt1
1adv \n{a6d"a} a1e2d ae1r a1er.  1aero 8afa a3fal af1an a5far a5fat
af1au a6fentl a2f1ex af1fr af5rau af1re 1afri af6tent af6tra aft5re
a6f5um \n{8af"a} ag5abe 5a4gent ag8er ages5e 1aggr ag5las ag1lo a1gn
ag2ne 1agog a6g5und a1ha a1he ah5ein a4h3erh a1hi ahl1a ah1le ah4m3ar
ahn1a a5ho ahra6 ahr5ab ah1re ah8rei ahren8s ahre4s3 ahr8ti ah1ru a1hu
\n{ah8"o} ai3d2s ai1e aif6 a3inse ai4re.  a5isch.  ais8e a3ismu ais6n
aiso6 a1j 1akad a4kade a1ke a1ki 1akko 5akro1 a5lal al5ans 3al8arm
al8beb al8berw alb5la 3album al1c a1le a6l5e6be a4l3ein a8lel a8lerb
a8lerh a6lert 5a6l5eth 1algi al4gli al3int al4lab al8lan al4l3ar
alle3g a1lo a4l5ob al6schm al4the altist5 al4t3re 8a1lu alu5i a6lur
alu3ta \n{a1l"a} a6mate 8ame.  5a6meise am6m5ei am6mum am2n ampf3a
am6schw am2ta a1mu \n{a1m"a} a3nac a1nad anadi5e an3ako an3alp 3analy
an3ame an3ara a1nas an5asti a1nat anat5s an8dent ande4s3 an1ec an5eis
an1e2k 4aner.  a6n5erd a8nerf a6n5erke 1anfa 5anfert \n{1anf"a} 3angab
5angebo an3gli ang6lis an2gn 3angri ang5t6 \n{5anh"a} ani5g ani4ka
an5i8on an1kl an6kno an4kro 1anl anma5c anmar4 3annah anne4s3 a1no
5a6n1o2d 5a6n3oma 5a6nord 1anr an1sa 5anschl an4soz an1st 5anstal
an1s2z 5antenn an1th \n{5anw"a} a5ny an4z3ed 5anzeig 5anzieh 3anzug
\n{an1"a} \n{5an"as} \n{a1n"o} \n{an"o8d} a1os a1pa 3apfel a2ph1t
\n{aph5"a6} a1pi 8apl apo1c apo1s a6poste a6poth 1appa ap1pr a1pr
\n{a5p"a} \n{a3p"u} a1ra a4r3af ar3all 3arbei 2arbt ar1c 2a1re ar3ein
ar2gl 2a1ri ari5es ar8kers ar6les ar4nan ar5o6ch ar1o2d a1rol ar3ony
a8ror a3ros ar5ox ar6schl 8artei ar6t5ri a1ru a1ry 1arzt arz1w
\n{ar8z"a} \n{ar"a8m} \n{ar"o6} \n{ar5"om} \n{ar1"u2} a1sa a6schec
asch5l asch3m a6schn a3s4hi as1pa asp5l a8steb as5tev 1asth a6stoc
a1str ast3re 8a1ta ata5c ata3la a6tapf ata5pl a1te a6teli aten5a
ate5ran 6atf 6atg a1th at3hal 1athl 2a1ti 5atlant 3atlas 8atmus 6atn
a1to a6t5ops ato6ra a6t5ort.  4a1tr a6t5ru at2t1h \n{at5t6h"a} 6a1tu
atz1w \n{a1t"a} \n{a1t"u} au1a au6bre auch3a au1e aue4l 5aufent
\n{3auff"u} 3aufga 1aufn auf1t 3auftr 1aufw 3auge.  au4kle aule8s 6aum
au8mar aum5p 1ausb 3ausd 1ausf 1ausg au8sin 3auss au4sta 1ausw 1ausz
aut5eng au1th 1auto au\3e8 \c{au\9e8} a1v ave5r6a aver6i a1w a6wes a1x
a2xia a6xio a1ya a1z azi5er.  8a\3 \c{8a\9} 1ba 8ba8del ba1la ba1na
ban6k5r ba5ot bardi6n ba1ro basten6 bau3sp 2b1b bb6le b2bli 2b1c 2b1d
1be be1a be8at.  be1ch 8becht 8becke.  be5el be1en bee8rei be5eta bef2
8beff be1g2 \n{beh"o8} bei1s 6b5eisen bei3tr b8el bel8o belu3t be3nac
bend6o be6ners be6nerw be4nor ben4se6 bens5el \n{be1n"a} \n{be1n"u}
be1o2 b8er.  be1ra be8rac ber8gab.  ber1r \n{be1r"u} bes8c bes5erh
bes2p be5tha bet5sc be1un be1ur 8bex be6zwec 2b1f8 bfe6st5e 2b1g2
bga2s5 bge1 2b1h bhole6 1bi bi1bl b6ie bi1el bi1la \n{bil"a5} bi1na
bi4nok bi5str bi6stu bi5tr bit4t5r b1j 2b1k2 \n{bk"u6} bl8 b6la.
6b1lad 6blag 8blam 1blat b8latt 3blau.  b6lav 3ble.  b1leb b1led
8b1leg 8b1leh 8bleid 8bleih 6b3lein blei3s ble4m3o 4blich b4lind
8bling b2lio 5blit b4litz b1loh 8b1los 1blu 5blum 2blun blut3a blut5sc
\n{3bl"a} \n{bl"as5c} \n{5bl"o} \n{3bl"u} \n{bl"u8sc} 2b1m 2b1n 1bo
bo1ch bo5d6s boe5 8boff 8bonk bo1ra b1ort 2b1p2 b1q 1br brail6 brast8
bre4a b5red 8bref 8b5riem b6riga bro1s b1rup b2ruz \n{8br"oh}
\n{br"os5c} 8bs b1sa b8sang b2s1ar b1sc bs3erl bs3erz b8sof b1s2p
bst1h b3stru \n{b5st"a} b6sun 2b1t b2t1h 1bu bu1ie bul6k b8ure bu6sin
6b1v 2b1w 1by1 by6te.  8b1z bzi1s \n{1b"a} \n{b5"a6s5} \n{1b"u}
\n{b6"u5bere} \n{b"uge6} \n{b"ugel5e} \n{b"ur6sc} 1ca cag6 ca5la ca6re
ca5y c1c 1ce celi4c celich5 ce1ro c8h 2ch.  1chae ch1ah ch3akt cha6mer
8chanz 5chara 3chari 5chato 6chb 1chef 6chei ch3eil ch3eis 6cherkl
6chf 4chh 5chiad 5chias 6chins 8chj chl6 5chlor 6ch2m 2chn6 ch8nie
5cho.  8chob choi8d 6chp ch3ren ch6res \n{ch3r"u} 2chs 2cht cht5ha
cht3hi 5chthon ch6tin 6chuh chu4la 6ch3unt chut6t 8chw 1ci ci5tr c2k
2ck.  ck1ei 4ckh ck3l ck3n ck5o8f ck1r 2cks ck5stra ck6s5u c2l 1c8o
con6ne 8corb cos6t c3q 1c6r 8c1t 1cu 1cy \n{5c"a1} \n{c"o5} 1da.
8daas 2dabg 8dabr 6dabt 6dabw 1dac da2gr 6d5alk 8d5amt dan6ce.
dani5er dan8ker 2danl danla6 6dans 8danzi 6danzu d1ap da2r1a8 2d1arb
d3arc dar6men 4d3art 8darz 1dat 8datm 2d1auf 2d1aus 2d1b 2d1c 2d1d
d5de d3d2h \n{dd"amme8} 1de 2deal de5an de3cha de1e defe6 6deff 2d1ehr
5d4eic de5isc de8lar del6s5e del6spr de4mag de8mun de8nep dene6r
8denge.  8dengen de5o6d 2deol de5ram 8derdb der5ein de1ro der1r d8ers
der5um de4s3am de4s3an de4sau de6sil de4sin de8sor de4spr de2su 8deul
de5us.  2d1f df2l 2d1g 2d1h 1di dia5c di5ara dice5 di3chr di5ena di1gn
di1la dil8s di1na 8dind 6dinf 4d3inh 2d1ins di5o6d di3p4t di8sen dis1p
di5s8per di6s5to dis5tra di8tan di8tin d1j 6dje 2dju 2d1k 2d1l 2d1m
2d1n6 dni6 dnje6 1do 6d5obe do6berf 6d5ony do3ran 6dord 2d1org dor4t3h
do6ste 6doth dott8e 2d1p d5q dr4 1drah 8drak d5rand 6dre.  4drech
d6reck 4d3reg 8d3reic d5reife 8drem 8d1ren 2drer 8dres.  6d5rh 1dria
d1ric 8drind droi6 dro5x 1dru 8drut \n{dr"os5c} \n{1dr"u} \n{dr"u5b}
\n{dr"u8sc} 2ds d1sa d6san dsat6 d1sc 5d6scha.  5dschik dse8e d8serg
8dsl d1sp d4spak ds2po \n{d8sp"a} d1st \n{d1s"u} 2dt d1ta d1te d1ti
d1to dt1s6 d1tu \n{d5t"a} 1du du5als du1b6 du1e duf4t3r 4d3uh du5ie
8duml 8dumw 2d1und du8ni 6d5unt dur2c durch3 6durl 6dursa 8durt du1s
du8schr 2d1v 2d1w dwa8l 2d1z \n{1d"a} \n{6d"ah} \n{8d"and} \n{d"a6r}
\n{d"o8bl} \n{d5"ol} \n{d"or6fl} \n{d"o8sc} \n{d5"o4st} \n{d"os3te}
\n{1d"u} ea4ben e1ac e1ah e1akt e1al.  e5alf e1alg e5a8lin e1alk e1all
e5alp e1alt e5alw e1am e1and ea6nim e1ar.  e5arf e1ark e5arm e3art
e5at.  e6ate e6a5t6l e8ats e5att e6au.  e1aus e1b e6b5am ebens5e
eb4lie eb4ser eb4s3in e1che e8cherz e1chi ech3m 8ech3n ech1r ech8send
ech4su e1chu eck5an e5cl e1d ee5a ee3e ee5g e1ei ee5isc eei4s3t
ee6lend e1ell \n{ee5l"o} e1erd ee3r4e ee8reng eere6s5 \n{ee5r"a}
ee6tat e1ex e1f e6fau e8fe8b 3effek ef3rom ege6ra eglo6si 1egy e1ha
e6h5ach eh5ans e6hap eh5auf e1he e1hi ehl3a eh1le ehl5ein eh1mu ehn5ec
e1ho ehr1a eh1re ehre6n eh1ri eh1ru ehr5um e1hu eh1w e1hy \n{e1h"a}
\n{e1h"o} \n{e3h"ut} ei1a eia6s ei6bar eich3a eich5r ei4dar ei6d5ei
ei8derf ei3d4sc ei1e 8eifen 3eifri 1eign eil1d ei6mab ei8mag ein1a4
ei8nat ei8nerh ei8ness ei6nete ein1g e8ini ein1k ei6n5od ei8nok ei4nor
\n{e3ins"a} ei1o e1irr ei5ru ei8sab ei5schn ei6s5ent ei8sol ei4t3al
eit3ar eit1h ei6thi ei8tho eit8samt ei6t5um e1j 1ekd e1ke e1ki e1k2l
e1kn ekni4 e1la e2l1al 6elan e6lanf e8lanl e6l5ans el3arb el3arm
e6l3art 5e6lasti e6lauge elbst5a e1le 6elef ele6h e6l5ehe e8leif
e6l5einh 1elek e8lel 3eleme e6lemen e6lente el5epi e4l3err e6l5ersc
elf2l elg2 e6l5ins ell8er 4e1lo e4l3ofe el8soh el8tent 5eltern e1lu
elut2 \n{e1l"a} \n{e1l"u} em8dei em8meis 4emo emo5s 1emp1f 1empt 1emto
e1mu emurk4 emurks5 \n{e1m"a} en5a6ben en5achs en5ack e1nad en5af
en5all en3alt en1am en3an.  en3ant en3anz en1a6p en1ar en1a6s 6e1nat
en3auf en3aus en2ce enda6l end5erf end5erg en8dess 4ene.  en5eck
e8neff e6n5ehr e6n5eim en3eis 6enem.  6enen e4nent 4ener.  e8nerd
e6n3erf e4nerg 5energi e6n5erla en5ers e6nerst en5erw 6enes e6n5ess
e2nex en3glo 2eni enni6s5 ennos4 enns8 e1no e6nober eno8f en5opf
e4n3ord en8sers ens8kl en1sp ens6por en5t6ag enta5go en8terbu en6tid
3entla ent5ric 5entwic 5entwu 1entz enu5i e3ny en8zan \n{en1"of}
\n{e1n"os} \n{e1n"ug} eo1c e5o6fe e5okk e1on.  e3onf e5onk e5onl e5onr
e5opf e5ops e5or.  e1ord e1org eo5r6h eo1t e1pa e8pee e6p5e6g ep5ent
e1p2f e1pi 5epid e6pidem e1pl 5epos e6pos.  ep4p3a e1pr \n{e1p"a} e1q
e1ra.  er5aal 8eraba e5rabel er5a6ben e5rabi er3abs er3ach era5e
era5k6l er3all er3amt e3rand e3rane er3ans e5ranz.  e1rap er3arc
e3rari er3a6si e1rat erat3s er3auf e3raum 3erbse er1c e1re 4e5re.
er3eck er5egg er5e2h 2erei e3rei.  e8reine er5einr 6eren.  e4r3enm
4erer.  e6r5erm er5ero er5erst e4r3erz er3ess \n{5erf"ul} er8gan.
5ergebn er2g5h \n{5erg"anz} \n{5erh"ohu} 2e1ri eri5ak e6r5iat e4r3ind
e6r5i6n5i6 er5ins e6r5int er5itio er1kl \n{3erkl"a} \n{5erl"os.}
ermen6s er6nab 3ernst 6e1ro.  e1rod er1o2f e1rog 6e3roi ero8ide e3rol
e1rom e1ron e3rop8 e2r1or e1ros e1rot er5ox ersch4 5erstat er6t5ein
er2t1h er5t6her 2e1ru eruf4s3 e4r3uhr er3ums e5rus 5erwerb e1ry er5zwa
er3zwu \n{er"a8m} \n{er5"as} \n{er"o8} \n{e3r"os.} \n{e6r1"u2b} e1sa
esa8b e8sap e6s5a6v e1sc esch4l ese1a es5ebe eserve5 e8sh es5ill
es3int es4kop e2sl eso8b e1sp espei6s5 es2po es2pu 5essenz e6stabs
e6staf e6st5ak est3ar e8stob e1str est5res es3ur e2sz \n{e1s"u} e1ta
et8ag etari5e eta8ta e1te eten6te et5hal e5thel e1ti 1etn e1to e1tr
et3rec e8tscha et8se et6tei et2th et2t1r e1tu etu1s et8zent et8zw
\n{e1t"a} \n{e1t"o} \n{e1t"u} eu1a2 eu1e eue8rei eu5fe euin5 euk2
e1um.  eu6nio e5unter eu1o6 eu5p 3europ eu1sp eu5str eu8zo e1v eval6s
eve5r6en ever4i e1w e2wig ex1or 1exp 1extr ey3er.  e1z \n{e1"a2}
\n{e5"o8} \n{e1"u} e8\3es \c{e8\9es} fa6ch5i fade8 fa6del fa5el.
fal6lo falt8e fa1na fan4gr 6fanl 6fap far6ba far4bl far6r5a 2f1art
fa1sc fau8str fa3y 2f1b2 6f1c 2f1d 1fe 2f1eck fe6dr feh6lei f6eim
8feins f5eis fel5en 8feltern 8femp fe5rant 4ferd.  ferri8 fe8stof
fe6str fe6stum fe8tag fet6ta fex1 2ff f1fa f6f5arm f5fe ffe5in ffe6la
ffe8ler ff1f f1fla ff3lei ff4lie ff8sa ff6s5ta 2f1g2 fgewen6 4f1h 1fi
fid4 fi3ds fieb4 fi1la fi8lei fil4m5a f8in.  fi1na 8finf fi8scho fi6u
6f1j 2f1k2 f8lanz fl8e 4f3lein 8flib 4fling f2lix 6f3lon 5flop 1flor
\n{5f8l"ac} \n{3fl"ot} 2f1m 2f1n 1fo foh1 f2on fo6na 2f1op fo5ra
for8mei for8str for8th for6t5r fo5ru 6f5otte 2f1p8 f1q fr6 f5ram
1f8ran f8ra\3 \c{f8ra\9} f8re.  frei1 5frei.  f3reic f3rest f1rib
8f1ric 6frig 1fris fro8na \n{fr"as5t} 2fs f1sc f2s1er f5str
\n{fs3t"at} 2ft f1tak f1te ft5e6h ftere6 ft1h f1ti f5to f1tr ft5rad
ft1sc ft2so f1tu ftwi3d4 ft1z 1fu 6f5ums 6funf fun4ka fu8\3end
\c{fu8\9end} 6f1v 2f1w 2f1z \n{1f"a} \n{f"a1c} \n{8f"arm} \n{6f"aug}
\n{f"a8\3} \n{\c{f"a8\9}} \n{f"ode3} \n{8f"of} \n{3f"or} \n{1f"u}
\n{f"un4f3u} 1ga ga6bl 6gabw 8gabz g3a4der ga8ho ga5isc 4gak ga1la
6g5amt ga1na gan5erb gan6g5a ga5nj 6ganl 8gansc 6garb 2g1arc 2g1arm
ga5ro 6g3arti ga8sa ga8sc ga6stre 2g1atm 6g5auf gau5fr g5aus 2g1b g5c
6gd g1da 1ge ge1a2 ge6an ge8at.  ge1e2 ge6es gef2 8geff ge1g2l ge1im
4g3eise geist5r gel8bra gelt8s \n{ge5l"o} ge8nin gen3k 6g5entf
\n{ge3n"a} ge1or ge1ra ge6rab ger8au \n{8gerh"o} ger8ins ge1ro 6g5erz.
\n{ge1r"a} \n{ge1r"u} ge1s ges2p ge5unt 4g3ex3 2g1f8 2g1g g1ha 6g1hei
5ghel.  g5henn 6g1hi g1ho 1ghr \n{g1h"o} 1gi gi5la gi8me.  gi1na
4g3ins gi3str g1j 2g1k 8gl.  1glad g5lag glan4z3 1glas 6glass 5glaub
g3lauf 1gle.  g5leb 3gleic g3lein 5gleis 1glem 2gler 8g3leu gli8a
g2lie 3glied 1g2lik 1g2lim g6lio 1gloa 5glom 1glon 1glop g1los g4loss
g5luf 1g2ly \n{1gl"u} 2g1m gn8 6gn.  1gna 8gnach 2gnah g1nas g8neu
g2nie g3nis 1gno 8gnot 1go goe1 8gof 2gog 5gogr 6g5oh goni5e 6gonist
go1ra 8gord 2g1p2 g1q 1gr4 g5rahm gra8m gra4s3t 6g1rec gre6ge 4g3reic
g5reit 8grenn gri4e g5riem 5grif 2grig g5ring 6groh 2grot gro6\3
\c{gro6\9} 4grut 2gs gs1ab g5sah gs1ak gs1an gs8and gs1ar gs1au g1sc
gs1ef g5seil gs5ein g2s1er gs1in g2s1o gso2r gs1pr g2s1u 2g1t g3te
g2t1h 1gu gu5as gu2e 2gue.  6gued 4g3uh 8gums 6g5unt gu1s gut3h gu2tu
4g1v 2g1w gy1n g1z \n{1g"a} \n{8g"a8m} \n{6g"arm} \n{1g"o} \n{1g"u}
\n{6g"ub} 1haa hab8r ha8del hade4n 8hae ha5el.  haf6tr 2hal.  ha1la
hal4b5a 6hale 8han.  ha1na han6dr han6ge.  2hani h5anth 6hanz 6harb
h3arbe h3arme ha5ro ha2t1h h1atm hau6san ha8\3 \c{ha8\9} h1b2 h1c h1d
he2bl he3cho h3echt he5d6s 5heft h5e6he.  hei8ds h1eif 2hein he3ism
he5ist.  heit8s3 hek6ta hel8lau 8helt he6mer 1hemm 6h1emp hen5end
hen5klo hen6tri he2nu 8heo he8q her3ab he5rak her3an 4herap her3au
h3erbi he1ro he8ro8b he4r3um her6z5er he4spe he1st heta6 het5am he5th
heu3sc he1xa hey5e h1f2 h1g hgol8 h1h h1iat hie6r5i hi5kt hil1a2
hil4fr hi5nak hin4ta hi2nu hi5ob hirn5e hir6ner hi1sp hi1th hi5tr
5hitz h1j h6jo h1k2 hlabb4 hla4ga hla6gr h5lai hl8am h1las h1la\3
\c{h1la\9} hl1c h1led h3lein h5ler.  h2lif h2lim h8linf hl5int h2lip
h2lit h4lor h3lose \n{h1l"as} hme5e h2nee h2nei hn3eig h2nel hne8n
hne4p3f hn8erz h6netz h2nip h2nit h1nol hn5sp h2nuc h2nud h2nul hoch1
1hoh hoh8lei 2hoi ho4l3ar 1holz h2on ho1ra 6horg 5horn.  ho3sl hos1p
ho4spi h1p hpi6 h1q 6hr h1rai h8rank h5raum hr1c hrcre8 h1red h3reg
h8rei.  h4r3erb h8rert hrg2 h1ric hr5ins h2rom hr6t5erl hr2t1h hr6t5ra
hr8tri h6rum hr1z hs3ach h6s5amt h1sc h6s5ec h6s5erl hs8erle h4sob
h1sp h8spa\3 \c{h8spa\9} h8spel hs6po h4spun h1str h4s3tum hs3und
\n{h1s"u} h5ta.  h5tab ht3ac ht1ak ht3ang h5tanz ht1ar ht1at h5taub
h1te h2t1ec ht3eff ht3ehe h4t3eif h8teim h4t3ein ht3eis h6temp h8tentf
hte8ren \n{h6terf"u} h8tergr h4t3erh h6t5ersc h8terst h8tese h8tess
h2t1eu h4t3ex ht1he ht5hu h1ti ht5rak hts3ah ht1sc ht6sex ht8sk ht8so
h1tu htz8 \n{h5t"um} hub5l hu6b5r huh1l h5uhr.  huld5a6 hu8lent
\n{hu8l"a} h5up.  h1v h5weib h3weis h1z \n{h"a8kl} \n{h"al8s}
\n{h"ama8tu8} \n{h"a8sche.} \n{h"at1s} \n{h"au4s3c} \n{2h"o.}
\n{2h"oe} \n{8h"oi} \n{h"o6s} \n{h"os5c} \n{h"uhne6} \n{h"ul4s3t}
\n{h"utte8re} i5adn i1af i5ak.  i1al.  i1al1a i1alb i1ald i5alei i1alf
i1alg i3alh i1alk i1all i1alp i1alr i1als i1alt i1alv i5alw i3alz
i1an.  ia5na i3and ian8e ia8ne8b i1ang i3ank i5ann i1ant i1anz i6apo
i1ar.  ia6rab i5arr i1as.  i1asm i1ass i5ast.  i1at.  i5ats i1au i5azz
i6b5eig i6b5eis ib2le i4blis i6brig i6b5unt \n{i6b"ub} i1che ich5ei
i6cherb i1chi ich5ins ich1l ich3m ich1n i1cho icht5an icht3r i1chu
ich1w ick6s5te ic5l i1d id3arm 3ideal ide8na 3ideol \n{ide5r"o} i6diot
id5rec id1t ie1a ie6b5ar iebe4s3 ie2bl ieb1r ie8bra ie4bre \n{ie8b"a}
ie2dr ie1e8 ie6f5ad ief5f ie2f1l ie4fro ief1t i1ei ie4l3ec ie8lei
ie4lek i3ell i1en.  i1end ien6e i3enf i5enn ien6ne.  i1enp i1enr
i5ensa ien8stal i5env i1enz ie5o ier3a4b ie4rap i2ere ie4rec ie6r5ein
ie6r5eis ier8er i3ern.  ie8rum ie8rund ie6s5che ie6tau ie8tert ie5the
ie6t5ri i1ett ie5un iex5 2if i1fa if5ang i6fau if1fr if5lac i5f6lie
i1fre ift5a if6t5r ig3art 2ige i8gess ig5he i5gla ig2ni i5go ig3rot
ig3s2p i1ha i8ham i8hans i1he i1hi ih1n ih1r i1hu i8hum ih1w 8i1i ii2s
ii2t i1j i1k i6kak i8kerz i6kes ik4ler i6k5unt 2il i5lac i1lag il3ans
i5las i1lau il6auf i1le ile8h i8lel il2fl il3ipp il6l5enn i1lo ilt8e
i1lu \n{i1l"a} i8mart imb2 i8mele i8mid imme6l5a i1mu \n{i1m"a}
\n{i5m"o} ina5he i1nat in1au inau8s 8ind.  in4d3an 5index ind2r 3indus
i5nec i2n1ei i8nerw 3infek 1info 5ingeni ing5s6o 5inhab ini5er.  5inj
\n{in8k"at} in8nan i1no inoi8d in3o4ku in5sau in1sp 5inspe 5instit
5instru ins4ze 5intere 5interv in3the in5t2r i5ny \n{in"a2} \n{i1n"ar}
\n{in1"as} \n{in"o8} \n{in5"od} \n{i1n"os} 2io io1a8 io1c iode4 io2di
ioi8 i1ol.  i1om.  i1on.  i5onb ion2s1 i1ont i5ops i5o8pt i1or.
i3oral io3rat i5orc i1os.  i1ot.  i1o8x 2ip i1pa i1pi i1p2l i1pr i1q
i1ra ir6bl i1re i1ri ir8me8d ir2m1o2 ir8nak i1ro ir5rho ir6schl
ir6sch5r i5rus i5ry \n{i5r"a} i1sa i8samt i6sar i2s1au i8scheh i8schei
isch5m isch3r \n{isch"a8} is8ele ise3ra i4s3erh is3err isi6de i8sind
is4kop ison5e is6por i8s5tum i5sty \n{i5s"o} i1ta it5ab.  i2t1a2m
i8tax i1te i8tersc i1thi i1tho i5thr \n{it8h"a} i1ti i8ti8d iti6kl
itmen4 i1to i8tof it3ran it3rau i1tri itri5o it1sc it2se it5spa it8tru
i1tu it6z5erg it6z1w \n{i1t"a} \n{it"a6r5e} \n{it"at2} \n{it"ats5}
\n{i1t"u} i1u iu6r 2i1v i6vad iva8tin i8vei i6v5ene i8verh i2vob i8vur
i1w iwi2 i5xa i1xe i1z ize8n i8zir i6z5w \n{i"a8m} \n{i1"a6r}
\n{i5"at.} \n{i5"av} \n{i1"o8} \n{i"u8} i6\35ers \c{i6\95ers} ja5la
je2t3r 6jm 5jo jo5as jo1ra jou6l ju5cha jugen4 jugend5 jung5s6 ju1s
\n{3j"a} 1ka 8kachs 8kakz ka1la kal5d kam5t ka1na 2kanl 8kapf ka6pl
ka5r6a 6k3arbe ka1ro kar6p5f 4k3arti 8karz \n{ka1r"a} kasi5e ka6teb
kat8ta kauf6s kau3t2 2k1b 2k1c 4k1d kehr6s kehrs5a 8keic 2k1eig 6k5ein
6k5eis ke6lar ke8leis ke8lo 8kemp k5ente.  k3entf 8k5ents 6kentz ke1ra
k5erlau 2k1f8 2k1g 2k1h ki5fl 8kik king6s5 6kinh ki5os ki5sp ki5th
\n{8ki8"o} 2k1k2 kl8 1kla 8klac k5lager kle4br k3leib 3kleid kle5isc
4k3leit k3lek 6k5ler.  5klet 2klic 8klig k2lim k2lin 5klip 5klop k3lor
\n{1kl"a} 2k1m kmani5e kn8 6kner k2ni \n{kn"a8} 1k2o ko1a2 ko6de.
ko1i koi8t ko6min ko1op ko1or ko6pht ko3ra kor6d5er ko5ru ko5t6sc k3ou
3kow 6k5ox 2k1p2 k1q 1kr8 4k3rad 2k1rec 4k3reic kre5ie 2krib 6krig
2krip 6kroba 2ks k1sa k6sab ksal8s k8samt k6san k1sc k2s1ex k5spat
k5spe k8spil ks6por k1spr kst8 k2s1uf 2k1t kta8l kt5a6re k8tein kte8re
k2t1h k8tinf kt3rec kt1s 1ku ku1ch kuck8 k3uhr ku5ie kum2s1 kunfts5
kun2s kunst3 ku8rau ku4ro kurz1 ku1st 4kusti ku1ta ku8\3 \c{ku8\9}
6k1v 2k1w ky5n 2k1z \n{1k"a} \n{k"a4m} \n{4k3"ami} \n{k"ase5} \n{1k"o}
\n{k"o1c} \n{k"o1s} \n{1k"u} \n{k"u1c} \n{k"ur6sc} \n{k"u1s} 1la.
8labf 8labh lab2r 2l1abs lach3r la8dr 5ladu 8ladv 6laff laf5t la2gn
5laken 8lamb la6mer 5lampe.  2l1amt la1na 1land lan4d3a lan4d3r lan4gr
8lanme 6lann 8lanw \n{6lan"a} 8lappa lap8pl lap6pr l8ar.  la5ra lar4af
la8rag la8ran la6r5a6s l3arbe la8rei 6larm.  la8sa la1sc la8sta lat8i
6l5atm 4lauss 4lauto 1law 2lb l8bab l8bauf l8bede l4b3ins l5blo
lbst5an lbst3e 8lc l1che l8chert l1chi lch3m l5cho lch5w 6ld l4d3ei
ld1re \n{l6d"ub} le2bl le8bre lecht6s5 led2r 6leff le4gas 1lehr lei6br
le8inf 8leinn 5leistu 4lektr le6l5ers lemo2 8lemp l8en.  8lends
6lendun le8nend len8erw 6l5ents 4l3entw 4lentz 8lenzy 8leoz 6lepi
le6pip 8lepo 1ler l6er.  8lerbs 6l5erde le8reis le8rend le4r3er 4l3erg
l8ergr 6lerkl 6l5erzie \n{8ler"o} 8lesel lesi5e le3sko le3tha let1s
5leuc 4leuro leu4s3t le5xe 6lexp l1f 2l1g lgend8 l8gh lglie3 lglied6
6l1h 1li li1ar li1as 2lick li8dr li1en lien6n li8ers li8ert 2lie\3
\c{2lie\9} 3lig li8ga8b li1g6n li1l8a 8limb li1na 4l3indu lings5
4l3inh 6linj link4s3 4linkt 2lint 8linv lion5s6t 4lipp 5lipt 4lisam
livi5e 6l1j 6l1k l8keim l8kj lk2l lko8f lkor8 lk2sa lk2se 6ll l1la
ll3a4be l8labt ll8anl ll1b ll1c ll1d6 l1le l4l3eim l6l5eise ller3a
l4leti l5lip l1lo ll3ort ll5ov ll6spr llte8 l1lu ll3urg \n{l1l"a}
\n{l5l"u} \n{l6l"ub} 2l1m l6m5o6d 6ln l1na l1no 8lobl lo6br 3loch.
l5o4fen 5loge.  5lohn 4l3ohr 1lok l2on 4l3o4per lo1ra 2l1ord 6lorg
4lort lo1ru 1los.  lo8sei 3losig lo6ve lowi5 6l1p lp2f l8pho l8pn
lp4s3te l2pt l1q 8l1r 2ls l1sa l6sarm l1sc l8sec l6s5erg l4s3ers l8sh
l5s6la l1sp ls4por ls2pu l1str l8suni \n{l1s"u} 2l1t lt5amp l4t3ein
l5ten l6t5eng l6t5erp l4t3hei lt3her l2t1ho l6t5i6b lti1l \n{l8tr"o}
lt1sc lt6ser lt4s3o lt5ums lu8br lu2dr lu1en8 8lu8fe luft3a luf8tr
lu6g5r 2luh l1uhr lu5it 5luk 2l1umf 2l1umw 1lun 6l5u6nio 4l3unte lu5ol
4lurg 6lurs l3urt lu4sto lu3str lu6st5re lu8su lu6tal lu6t5e6g lu8terg
lu3the lu6t5or lu2t1r lu6\35 \c{lu6\95} l1v lve5r6u 2l1w 1ly lya6
6lymp ly1no l8zess l8zo8f l3zwei lz5wu \n{3l"and} \n{l"a5on}
\n{l"a6sc} \n{l"at1s} \n{5l"auf} \n{2l"aug} \n{l"au6s5c} \n{l"a5v}
\n{l1"ol} \n{1l"os} \n{l"o1\36t} \n{\c{l"o1\96t}} \n{6l1"ube} 1ma
8mabg ma5chan mad2 ma5el 4magg mag8n ma1la ma8lau mal5d 8malde mali5e
malu8 ma8lut 2m1amp 3man mand2 man3ds 8mangr mani5o 8m5anst 6mappa
4m3arbe mar8kr ma1r4o mar8schm 3mas ma1sc \n{ma1t"o} 4m5auf ma5yo 2m1b
mb6r 2m1c 2m1d \n{md6s"a} 1me me1ch me5isc 5meld mel8sa 8memp me5nal
men4dr men8schl men8schw 8mentsp me1ra mer4gl me1ro 3mes me6s5ei me1th
me8\3 \c{me8\9} 2m1f6 2m1g 2m1h 1mi mi1a mi6ale mi1la 2m1imm mi1na
\n{mi5n"u} mi4s3an mit1h mi5t6ra 3mitt mitta8 mi6\35 \c{mi6\95} 6mj
2m1k8 2m1l 2m1m m6mad m6m5ak m8menth m8mentw mme6ra m2mn mm5sp mm5ums
mmut5s \n{m8m"an} m1n8 m5ni 1mo mo5ar mo4dr 8mof mo8gal mo4kla mol5d
m2on mon8do mo4n3od mont8a 6m5ony mopa6 mo1ra mor8d5a mo1sc mo1sp 5mot
moy5 2mp m1pa mpfa6 mpf3l mphe6 m1pi mpin6 m1pl mp2li m2plu mpo8ste
m1pr \n{mpr"a5} mp8th mput6 mpu5ts \n{m1p"o} 8m1q 2m1r 2ms ms5au m1sc
msch4l ms6po m3spri m1str 2m1t mt1ar m8tein m2t1h mt6se \n{mt8s"a}
mu5e 6m5uh mumi1 1mun mun6dr muse5e mu1ta 2m1v mvol2 mvoll3 2m1w 1my
2m1z \n{m"a6kl} \n{1m"an} \n{m"a1s} \n{m"a5tr} \n{m"au4s3c} \n{3m"a\3}
\n{\c{3m"a\9}} \n{m"ob2} \n{6m"ol} \n{1m"u} \n{5m"un} \n{3m"ut} 1na.
n5ab.  8nabn n1abs n1abz \n{na6b"a} na2c nach3e 3nacht 1nae na5el
n1afr 1nag 1n2ah na8ha na8ho 1nai 6nair na4kol n1akt nal1a 8naly 1nama
na4mer na1mn n1amp 8n1amt 5nanc nan6ce n1and n6and.  2n1ang 1nani
1nann n1ans 8nanw 5napf.  1n2ar.  na2ra 2n1arc n8ard 1nari n8ark
6n1arm 5n6ars 2n1art n8arv 6natm nat6s5e 1naue 4nauf n3aug 5naui n5auk
na5um 6nausb 6nauto 1nav 2nax 3naz 1na\3 \c{1na\9} n1b2 nbau5s n1c
nche5e nch5m 2n1d nda8d n2d1ak nd5ans n2d1ei nde8lac ndel6sa n8derhi
nde4se nde8stal n2dj ndnis5 n6d5or6t nd3rec nd3rot nd8samt nd6sau
ndt1h n8dumd 1ne ne5as ne2bl 6n5ebn 2nec 5neei ne5en ne1g4l 2negy
4n1ein 8neis 4n3e4lem 8nemb 2n1emp nen1a 6n5energ nen3k 8nentb
4n3en3th 8nentl 8n5entn 8n5ents ne1ra ne5r8al ne8ras 8nerbi 6n5erde.
nere5i6d nerfor6 \n{6n5erh"o} \n{8nerl"o} 2n1err n8ers.  6n5ertra
2n1erz nesi3e net1h neu4ra neu5sc 8neu\3 \c{8neu\9} n1f nf5f nf2l
nflei8 nf5lin nft8st n8g5ac ng5d ng8en nge8ram ngg2 ng1h n6glic ng3rip
ng8ru ng2se4 ng2si n2g1um n1gy \n{n8g"al} n1h nhe6r5e 1ni ni1bl
\n{ni5ch"a} ni8dee n6ie ni1en nie6s5te niet5h ni8etn 4n3i6gel n6ik
ni1la 2n1imp ni5na 2n1ind 8ninf 6n5inh ni8nit 6n5inn 2n1ins 4n1int
n6is ni3str ni1th ni1tr n1j n6ji n8kad nk5ans n1ke n8kerla n1ki nk5inh
\n{n5kl"o} n1k2n n8k5not nk3rot \n{n8kr"u} nk5spo nk6t5r n8kuh
\n{n6k"ub} n5l6 nli4mi n1m nmen4s n1na n8nerg nni5o n1no nn4t3ak nnt1h
nnu1e n1ny \n{n1n"a} \n{n1n"o} \n{n1n"u} no5a no4b3la 4n3obs 2nobt
noche8 no6die no4dis no8ia no5isc 6n5o6leu no4mal noni6er 2n1onk n1ony
4n3o4per 6nopf 6nopti no3ra no4ram nor6da 4n1org 2n1ort n6os no1st
8nost.  no8tan no8ter noty6pe 6n5ox n1p2 n1q n1r \n{nr"os3} 6ns n1sac
ns3ang n1sc n8self n8s5erf n8serg n6serk ns5erw n8sint n1s2pe n1spr
n6s5tat.  n5s6te.  n6stob n1str n1ta n4t3a4go nt5anh nt3ark nt3art
n1te nt3eis nte5n6ar nte8nei nter3a nte6rei nt1ha nt6har n3ther nt5hie
n3thus n1ti nti1c n8tinh nti1t ntlo6b ntmen8 n1to nt3o4ti n1tr ntra5f
ntra5ut nt8rea nt3rec nt8rep n4t3rin nt8rop n4t3rot \n{n4tr"u} nt1s
nts6an nt2sk n1tu nt1z \n{n1t"a} \n{n1t"o} \n{n8t"ol} \n{n1t"u} 1nu
nu1a nu5el nu5en 4n1uhr nu5ie 8numl 6n5ums 6n5umw 2n1und 6nuni 6n5unr
2n1unt 2nup 2nu6r n5uri nu3skr nu5ta n1v 8n1w 1nys n1za n6zab n2z1ar
n6zaus nzi4ga n8zof n6z5unt n1zw n6zwir \n{1n"ac} \n{5n"ae} \n{5n"ai}
\n{n8"al} \n{n"a6m} \n{n"a6re} \n{n5"arz} \n{5n"aus} \n{n1"ol}
\n{1n"ot} \n{n5"oz} \n{5n"u.} \n{6n1"u2b} \n{5n"u\3} \n{\c{5n"u\9}}
o5ab.  oa2l o8ala o1a2m o1an ob1ac obe4ra o6berh 5o4bers o4beru
obe6ser 1obj o1bl o2bli ob5sk 3obst.  ob8sta obst5re ob5sz o1che
oche8b o8chec o3chi och1l och3m ocho8f o3chro och3to o3chu och1w o1d
o2d1ag od2dr ode5i ode6n5e od1tr o5e6b o5e6der.  oe8du o1ef o1e2l
o1e2p o1er.  o5e8x o1fa of8fan 1offi of8fin of6f5la o5fla o1fr 8o1g
og2n o1ha o1he o6h5eis o1hi ohl1a oh1le oh4l3er 5ohm.  oh2ni o1ho
oh1re oh1ru o1hu oh1w o1hy \n{o1h"a} o5ia o1id.  o8idi oi8dr o5ids
o5isch.  oiset6 o1ism o3ist.  o5i6tu o1j o1k ok2l ok3lau \n{o8kl"a}
1okta o1la old5am old5r o1le ole5in ole1r ole3u ol6gl ol2kl olk4s1
ol8lak ol8lauf.  ol6lel ol8less o1lo ol1s ol6sk o1lu oly1e2 5olym
o2mab om6an o8mau ombe4 o8merz om5sp o1mu o8munt \n{o1m"a} \n{o1m"o}
o1na ona8m on1ax on8ent o6n5erb 8oni oni5er.  on1k on6n5a6b o1no ono1c
o4nokt 1ons onts8 \n{o1n"a} oo8f 1oog oo2pe oo2sa o1pa 3o4pera o3pfli
opf3lo opf3r o1pi o1pl o2pli o5p6n op8pa op6pl o1pr o3p4ter 1opti
\n{o1p"a} \n{o5p"o} o1q o1ra.  o3rad o8radd 1oram o6rang o5ras o8rauf
or5cha or4d3a4m or8dei or8deu 1ordn or4dos o1re o5re.  ore2h o8r5ein
ore5isc or6enn or8fla or8fli 1orga 5orgel.  or2gl o1ri 5o6rient or8nan
\n{or8n"a} o1ro or1r2h or6t5an or8tau or8tere o1rus o1ry \n{o1r"a}
\n{or1"u2} o1sa osa3i 6ose o8serk o1sk o6ske o6ski os2kl os2ko os2kr
osni5e o2s1o2d o3s4per o4stam o6stau o3stra ost3re osu6 o6s5ur o5s6ze
o1ta ot3auf o6taus o1te o6terw o1th othe5u o2th1r o1ti o1to oto1a
ot1re o1tri o1tro ot1sc o3tsu ot6t5erg ot2t3h ot2t5r \n{ot8t"o} o1tu
ou3e ouf1 ou5f6l o5u6gr ou5ie ou6rar ou1t6a o1v o1wa o1we o6wer.  o1wi
owid6 o1wo o5wu o1xe oy5al.  oy1e oy1i o5yo o1z oza2r 1o2zea ozo3is
\n{o"o8} o\35elt \c{o\95elt} o\31t \c{o\91t} 3paa pa6ce 5pad pag2 1pak
pa1la pa8na8t pani5el pa4nor pan1s2 1pap pap8s pa8rei par8kr paro8n
par5o6ti part8e 5partei 3partn pas6sep pa4tha 1pau 6paug pau3sc p1b
8p5c 4p1d 1pe 4peic pe5isc 2pek pen3k pen8to8 p8er pe1ra pere6 per5ea
per5eb pe4rem 2perr per8ran 3pers 4persi \n{pe3r"u} pe4sta pet2s
p2f1ec p4fei pf1f pf2l 5pflanz pf8leg pf3lei 2pft pf3ta p1g 1ph 2ph.
2p1haf 6phb 8phd 6p5heit ph5eme 6phg phi6e 8phk 6phn p5holl pht2
ph3tha 4ph3the phu6 6phz pi1en pi5err pi1la pi1na 5pinse pioni8e 1pis
pi1s2k pi1th p1k pl8 5pla p2lau 4plei p3lein 2pler 6p5les 2plig p6lik
6p5ling p2liz plo8min 6p1m p1n 1p2o 8poh 5pol po8lan poly1 po3ny po1ra
2porn por4t3h \n{po5r"o} 5poti p1pa p6p5ei ppe6la pp5f p2p1h p1pi pp1l
ppp6 pp5ren pp1s \n{p5p"o} pr6 3preis 1pres 2p3rig 5prinz 1prob 1prod
5prog pro8pt pro6t5a prote5i 8pro\3 \c{8pro\9} \n{pr"a3l} \n{1pr"as}
\n{pr"ate4} \n{1pr"uf} p5schl 2pst 1p2sy p1t p8to8d pt1s 5p6ty 1pu
pu1b2 2puc pu2dr puf8fr 6p5uh pun8s pu8rei pu5s6h pu1ta p1v p3w 5py
py5l p1z \n{p"a6der} \n{p5"a6m} \n{p"a8nu} \n{8p"ar} \n{p"at5h}
\n{p"at1s} qu6 1qui 8rabk ra6bla 3rable ra2br r1abt 6rabz ra4dan ra2dr
5rafal ra4f3er ra5gla ra2g3n 6raha ral5am 5rald 4ralg ra8lins 2rall
ral5t 8ramei r3anal r6and ran8der ran4dr 8ranf 6ranga 5rangi ran8gli
r3angr rans5pa 8ranw r8anz.  ra5or 6rapf ra5pl rap6s5er 2r1arb 1rarh
r1arm ra5ro 2r1art 6r1arz ra8tei ra6t5he 6ratl ra4t3ro r5atta raue4n
6raus.  r5austa rau8tel raut5s ray1 r1b rb5lass r6bler rb4lie rbon6n
r8brecht \n{rb6s5t"a} r8ces r1che rch1l rch3m rch3re rch3tr rch1w 8rd
r1da r8dachs r8dap rda5ro rde5ins rdio5 r8dir rd3ost r1dr r8drau 1re.
re1ak 3reakt re3als re6am.  re1as 4reben re6bl rech5a r8edi re3er
8reff 3refl 2reh 5reha r4ei.  reich6s5 8reier 6reign re5imp 4r3eina
6r3einb 6reing 6r5einn 6reinr 4r3eins r3eint reli3e 8r5elt 6rempf
2remt ren5a6b ren8gl r3enni 1reno 5rente 4r3enth 8rentl 4r3entw 8rentz
ren4zw re1on requi5 1rer rer4bl 6rerbs 4r3erd \n{8rerh"o} 8rerkl
4r3erla \n{8rerl"o} 4r3erns \n{6r5ern"a} rer5o 6r5erreg r5ertr r5erwec
\n{r5er"o} re2sa re8schm 2ress re5u8ni 6rewo 2r1ex r1f r8ferd rf4lie
8r1g r8gah rge4bl rge5na rgest4 rg6ne r2gni2 r8gob r4g3ret rg8sel r1h8
r2hy 5rhyt ri1ar ri5cha rid2g r2ie rieg4s5 ri8ei ri1el ri6ele ri1en
ri3er.  ri5ers.  ri6fan ri8fer ri8fr 1r2ig ri8kn ri5la \n{rim"a8}
ri1na r8inde rin4ga rin6gr 1rinn 6rinner rino1 r8insp 4rinst
\n{ri1n"a} ri5o6ch ri1o2d ri3o6st 2r1ir r2is ri3sko ri8spr \n{ri8st"u}
ri5sv r2it 6r5i6tal ri5tr ri6ve.  8r1j 6rk r1ke rkehrs5 r1ki r3klin
r1k2n rk3str rk4t3an rk6to r6kuh \n{rk"a4s3t} r1l r5li rline5a 6r1m
r6manl rma4p r4m3aph r8minf r8mob rm5sa 2rn r1na rna8be r5ne rn2ei
r6neif r6nex r6nh rn1k r1no r6n5oc rn1sp \n{r1n"a} \n{r1n"u} ro6bern
6robs ro1ch 3rock.  ro5de ro1e 4rofe ro8hert 1rohr ro5id ro1in ro5isc
6rolym r2on 6roog ro6phan r3ort ro1s2p ro5s6w ro4tau ro1tr ro6ts 5rout
r1p rpe8re rp2f r2ps r2pt r1q 2rr r1ra r1re rrer6 rr6hos \n{r5rh"o}
r1ri r1ro rro8f rr8or rror5a r1ru r3ry \n{r1r"a} \n{r1r"o} \n{r1r"u}
2r1s r6sab r4sanf rse6e rse5na r2sh r6ska r6ski rs2kl r8sko r2sl rs2p
r6stauf r8sterw r8stran rswi3d4 r2sz 2r1t rt3art r8taut r5tei rt5eige
r8tepe r4t3erh r8terla r4t3hei r5t6hu r4t3int rt5reif rt1sc rt6ser
rt6s5o rt6s5u rt5und r8turt rube6 ru1en 1r4uf ruf4st ru1ie 2r1umg
2r1uml 2rums run8der run4d5r 6rundz 6runf 8runs 2r1unt 2r1ur r6us
ru6sta ru3str ru6tr 1ruts r1v rven1 rvi2c r1w r1x r1za rz5ac r6z5al
r8z1ar r8zerd r6z5erf rz8erh rz4t3h r8zum \n{r"a4ste} \n{r"au8sc}
\n{r1"of} \n{5r"ohr} \n{r"o5le} \n{3r"oll} \n{5r"omis} \n{r1"or}
\n{r"o2sc} \n{3r"ump} 1sa.  1saa s3a4ben sa2bl 2s1abs 6s1abt 6sabw
3sack.  6s3a4der 1saf sa1fa 4s1aff sa5fr 1sag 1sai sa1i2k1 4s1akt 1sal
sa1la 4s3alpi 6salter salz3a 1sam s5anb san2c 1sand s5angeh 6sanl
2s1ans 6s3antr 8s1anw s1ap s6aph 8sapo sap5p6 s8ar.  2s1arb 3sarg
s1arm sa5ro 2s1art 6s1arz 1sas 1sat sat8a 2s1atl sa8tom 3s8aue s5auff
sau5i s6aur 2s1aus 5s6ause 2s1b2 2sca s4ce 8sch.  3scha.  5schade
3schaf 3schal sch5ame 8schanc 8schb 1sche 6schef 8schex 2schf 2schg
2schh 1schi 2schk 5schlag 5schlu \n{6schm"a\3} \n{\c{6schm"a\9}}
6schna\3 \c{6schna\9} 1scho 6schord 6schp 3schri 8schric 8schrig
8schrou 6schs 2scht sch3ta sch3tr 1schu 8schunt 6schv 2schz \n{5sch"o}
\n{5sch"u} 2sco scre6 6scu 2s1d 1se se5an se1ap se6ben se5ec see5i6g
se3erl 8seff se6han se8hi \n{se8h"o} 6s5eid.  2s1eig s8eil 5sein.
sei5n6e 6s5einh 3s8eit 3sel.  se4lar selb4 6s3e4lem se8lerl 2s1emp
sen3ac se5nec 6s5ents 4sentz s8er.  se8reim ser5inn \n{8serm"a}
8s5erzi \n{6ser"of} se1um 8sexa 6sexp 2s1f2 sfal8ler 2s3g2 sge5b2 s1h
s8hew 5s6hip 5s4hop 1si 2siat si1b sicht6s 6s5i6dee siege6s5 si1en
si5err si1f2 si1g2n si6g5r si8kau sik1i si4kin si2kl \n{si8k"u} si1la
sil6br si1na 2s1inf sin5gh 2s1inh sinne6s5 2s1ins si5ru si5str 4s1j
s1k2 6sk.  2skau skel6c skelch5 s6kele 1s2ki.  3s4kin.  s6kiz s8kj
6skn 2skow 3skrib 3skrip 2sku \n{8sk"u} s1l s8lal slei3t s4low 2s1m
s1n 6sna 6snot 1so so1ch 2s1odo so4dor 6s5o4fen solo3 s2on so5of 4sope
so1ra 2s1ord 4sorga sou5c so3un 4s3ox sp2 8spaa 5spal 1span 2spap
s2pec s4peis 1spek s6perg 4spers s6pes 2s1pf 8sphi \n{1s2ph"a} 1spi
spi4e 6s5pig 6spinse 2spis 2spla 2spol 5s6pom 6s5pos 6spoti 1spra
3s8prec 6spreis 5spring 6sprob 1spru s2pul 1s2pur 6spy \n{5sp"an}
\n{1sp"u} s1q 2s1r 2s1s2 sse8nu ssini6s ssoi6r 2st.  1sta 4stafe 2stag
sta3la 6stale 4stalg 8stalk 8stamt 6st5anf 4stans 6stanw 6starb sta4te
6staus 2stb 6stc 6std 1ste 4steil 3s2tel st3elb 8stemb 6steppi 8stese
8stesse 6stf 2stg 2sth st1ha st3hei s8t1hi st1ho st5hu 1sti sti4el
4stigm sti3na 6stind 4stinf sti8r 2stk 2stl 2stm 1sto 6stoll.  4st3ope
6stopf.  6stord 6stp 5stra.  4strai 3s4tral 6s5traum 3stra\3
\c{3stra\9} 3strec 6s3tref 8streib 5streif 6streno 6stres 6strev
5s6tria 6strig 5strik 8strisi 3s4troa s8troma st5rose 4struf 3strum
\n{6str"ag} 2st1s6 2stt 1stu stu5a 4stuc 2stue 8stun.  2stv 2stw s2tyl
6stz \n{1st"a} \n{8st"ag} \n{1st"o} \n{1st"u} \n{8st"uch} \n{4st"ur.}
1su su2b1 3suc su1e su2fe su8mar 6sumfa 8sumk 2s1unt sup1p2 6s5u6ran
6surte 2s1v 2s1w 1sy 8syl.  sy5la syn1 sy2na syne4 s1z s4zend 5s6zene.
8szu \n{1s"a} \n{6s5"and} \n{6s"augi} \n{6s"au\3} \n{\c{6s"au\9}}
\n{5s"om} \n{2s1"u2b} \n{1s"uc} \n{s"u8di} \n{1s"un} \n{5s"u\3}
\n{\c{5s"u\9}} taats3 4tab.  taba6k ta8ban tab2l ta6bre 4tabs t3absc
8tabz 6t3acht ta6der 6tadr tad6s tad2t 1tafe4 1tag ta6ga6 ta8gei
tage4s tag6s5t tah8 tahl3 tai6ne.  ta5ir.  tak8ta tal3au 1tale ta8leng
tal5ert 6t5a6mer 6tamp tampe6 2t1amt tan5d6a tan8dr tands5a tani5e
6tanl 2tanr t3ans 8t5antr tanu6 t5anw 8tanwa tan8zw ta8rau 6tarbe
1tari 2tark 2t1arm ta1ro 2tart t3arti 6tarz ta1sc ta6sien ta8stem
ta8sto t5aufb 4taufn 8taus.  5tause 8tausf 6tausg t5ausl 2t1b2 2t1c
t6chu 2t1d te2am tea4s te8ben 5techn 4teff te4g3re te6hau 2tehe te4hel
2t1ehr te5id.  teig5l 6teign tei8gr 1teil 4teinh t5einhe 4teis t5eisen
8teiw te8lam te4lar 4telek 8telem te6man te6n5ag ten8erw ten5k tens4p
ten8tro 4t3entw 8tentz te6pli 5teppi ter5a6b te3ral ter5au 8terbar
t5erbe.  6terben 8terbs 4t3erbt t5erde.  ter5ebe ter5ein te8rers terf4
\n{8terh"o} \n{6terkl"a} ter8nor ter6re.  t8erscha t5e6sel te8stau
t3euro te1xa tex3e 8texp tex6ta 2t1f2 2t1g2 2th.  th6a 5tha.  2thaa
6t1hab 6t5haf t5hah 8thak 3thal.  6thals 6t3hand 2t1hau 1the.  3t4hea
t1heb t5heil t3heit t3helf 1theo 5therap 5therf 6t5herz 1thes 1thet
5thi.  2t1hil t3him 8thir 3this t5hj 2th1l 2th1m th1n t5hob t5hof
4tholz 6thopti 1thr6 4ths t1hum 1thy \n{4t1h"a} \n{2t1h"o} \n{t1h"u}
ti1a2m ti1b tie6fer ti1en ti8gerz tig3l ti8kin ti5lat 1tilg t1ind
tin4k3l ti3spa ti5str 5tite ti5tr ti8vel ti8vr 2t1j 2t1k2 2t1l tl8a
2t1m8 2t1n 3tobe 8tobj to3cha 5tocht 8tock tode4 to8del to8du to1e
6t5o6fen to1in toi6r 5toll.  to8mene t2ons 2t1ony to4per 5topf.  6topt
to1ra to1s to6ska tos2l 2toti to1tr t8ou 2t1p2 6t1q tr6 tra5cha
tra8far traf5t 1trag tra6gl tra6gr t3rahm 1trai t6rans tra3sc tra6st
3traue t4re.  2trec t3rech t8reck 6t1red t8ree 4t1reg 3treib 4treif
8t3reis 8trepo tre6t5r t3rev 4t3rez 1trib t6rick tri6er 2trig t8rink
tri6o5d trizi5 tro1a 3troc trocke6 troi8d tro8man.  tro3ny 5tropf
6t5rosa t5ro\3 \c{t5ro\9} 5trub 5trup trut5 \n{1tr"ag} \n{6t1r"oh}
\n{5tr"ub} \n{tr"u3bu} \n{t1r"uc} \n{t1r"us} 2ts ts1ab t1sac tsa8d
ts1ak t6s5alt ts1an ts1ar ts3auf t3schr \n{t5sch"a} tse6e tsee5i
tsein6s ts3ent ts1er t8serf t4serk t8sh 5t6sik t4s3int ts5ort.
t5s6por t6sprei t1st t6s5tanz ts1th t6stit t4s3tor 1t2sua t2s1uf
t8sum.  t2s1u8n t2s1ur 2t1t tt5eif tte6sa tt1ha tt8ret tt1sc tt8ser
tt5s6z 1tuc tuch5a 1tu1e 6tuh t5uhr tu1i tu6it 1tumh 6t5umr 1tums
8tumt 6tund 6tunf 2t1unt tu5ra tu6rau tu6re.  tu4r3er 2t1v 2t1w 1ty1
ty6a ty8la 8tym 6ty6o 2tz tz5al tz1an tz1ar t8zec tzeh6 tzehn5 t6z5ei.
t6zor t4z3um \n{t6z"au} \n{5t"ag} \n{6t"ah} \n{t5"alt} \n{t8"an}
\n{t"are8} \n{8t"a8st} \n{6t"au\3} \n{\c{6t"au\9}} \n{t5"offen}
\n{8t"o8k} \n{1t"on} \n{4t"ub} \n{t6"u5ber.} \n{5t"uch} \n{1t"ur.}
u3al.  u5alb u5alf u3alh u5alk u3alp u3an.  ua5na u3and u5ans u5ar.
ua6th u1au ua1y u2bab ubi5er.  u6b5rit ubs2k \n{u5b"o} \n{u8b"ub} 2uc
u1che u6ch5ec u1chi uch1l uch3m uch5n uch1r uch5to ucht5re u1chu uch1w
uck1a uck5in u1d ud4a u1ei u6ela uene8 u6ep u1er uer1a ue8rerl uer5o
u8esc u2est u8ev u1fa u2f1ei u4f3ent u8ferh uf1fr uf1l uf1ra uf1re
\n{uf1r"a} \n{uf1r"u} uf1s2p uf1st uft1s u8gabt u8gad u6gap ugeb8 u8gn
ugo3s4 u1ha u1he u1hi uh1le u1ho uh1re u1hu uh1w \n{u1h"a} \n{u1h"o}
6ui ui5en u1ig u3ins uin8tes u5isch.  u1j 6uk u1ke u1ki u1kl u8klu
u1k6n u5ky u1la uld8se u1le ul8lac ul6lau ul6le6l ul6lo ulni8 u1lo
ulo6i ult6a ult8e u1lu ul2vr \n{u1l"a} \n{u1l"o} 3umfan 5umlau umo8f
um8pho u1mu umu8s \n{u5m"o} u1n1a un2al un6at unau2 6und.  5undein
un4d3um 3undzw \n{und"u8} \n{un8d"ub} une2b un1ec une2h un3eis 3unfal
\n{1unf"a} 5ungea \n{3ungl"u} ung2s1 \n{un8g"a} 1u2nif un4it un8kro
unk5s u1no unpa2 uns2p unvol4 unvoll5 u5os.  u1pa u1pi u1p2l u1pr
up4s3t up2t1a u1q u1ra ur5abs ura8d ur5ah u6rak ur3alt u6rana u6r5ans
u8rap ur5a6ri u8ratt u1re ur3eig ur8gri u1ri ur5ins 3urlau urmen6
ur8nan u1ro 3ursac ur8sau ur8sei ur4sk 3urtei u1ru uru5i6 uru6r u1ry
ur2za \n{ur6z"a} \n{ur5"a6m} \n{u5r"o} \n{u1r"u} \n{ur"uck3} u1sa
usa4gi u2s1ar u2s1au u8schec usch5wi u2s1ei use8kel u8sl u4st3a4b
us3tau u3s4ter u2s1uf u8surn ut1ac u1tal uta8m u1tan ut1ar u1tas ut1au
u1te u8teic u4tent u8terf u6terin u4t3hei ut5ho ut1hu u1ti utine5
uti6q u1to uto5c u1tr ut1sa ut1s6p ut6stro u1tu utz5w u1u u1v uve5n
\n{uve3r4"a} u1w u1xe u5ya uy5e6 u1yi u2z1eh u8zerh \n{u5"o} u\3e6n
\c{u\9e6n} u\3en5e \c{u\9en5e} 8vanb 6vang 6varb var8d va6t5a va8tei
va2t1r 2v1b 6v5c 6vd 1ve 6ve5g6 ver1 ver5b verb8l ve2re2 verg8 ve2ru8
ve1s ve2s3p ve3xe 2v1f 2v1g 6v5h vi6el vie6w5 vi1g4 vi8leh vil6le.
8vint vi1ru vi1tr 2v1k 2v1l 2v1m 4v5n 8vo8f voi6le vol8lend vol8li
v2or1 vo2re vo8rin vo2ro 2v1p 8vra v6re 2v1s 2v1t 2v1v 4v3w 2v1z
waffe8 wa6g5n 1wah wah8n wa5la wal8din wal6ta wan4dr 5ware wa8ru
war4za 1was w5c w1d 5wech we6fl 1weg we8geng weg5h weg3l we2g1r
weh6r5er 5weise weit3r wel2t welt3r we6rat 8werc 5werdu wer4fl 5werk.
wer4ka wer8ku wer4ta wer8term we2sp we8stend we6steu we8str
\n{we8st"o} wet8ta wich6s5t 1wid wi2dr wiede4 wieder5 wik6 wim6ma
win4d3r 5wirt wisch5l 1wj 6wk 2w1l 8w1n wo1c woche6 wol6f wor6t5r 6ws2
w1sk 6w5t 5wunde.  wun6gr wu1sc wu2t1 6w5w wy5a \n{w"arme5} \n{w"a1sc}
1xag x1ak x3a4men 8xamt x1an 8x1b x1c 1xe.  x3e4g 1xen xe1ro x1erz
1xes 8xf x1g 8x1h 1xi 8xid xi8so 4xiste x1k 6x1l x1m 8xn 1xo 8x5o6d
8x3p2 x1r x1s6 8x1t x6tak x8terf x2t1h 1xu xu1e x5ul 6x3w x1z 5ya.
y5an.  y5ank y1b y1c y6cha y4chia y1d yen6n y5ern y1g y5h y5in y1j
y1k2 y1lak yl1al yla8m y5lax y1le y1lo y5lu y8mn ym1p2 y3mu y1na yno2d
yn1t y1on.  y1o4p y5ou ypo1 y1pr y8ps y1r yri3e yr1r2 y1s ys5iat ys8ty
y1t y3w y1z \n{y"a8m} z5a6b zab5l 8za6d 1zah za5is 4z3ak 6z1am 5zange.
8zanl 2z1ara 6z5as z5auf 3zaun 2z1b 6z1c 6z1d 1ze ze4dik 4z3eff 8zein
zei4ta zei8ters ze6la ze8lec zel8th 4zemp 6z5engel zen8zin \n{8zerg"a}
zer8i ze1ro zers8 zerta8 zer8tab zer8tag 8zerz ze8ste zeu6gr 2z1ex
2z1f8 z1g 4z1h 1zi zi1en zi5es.  4z3imp zi1na 6z5inf 6z5inni zin6s5er
8zinsuf zist5r zi5th zi1tr 6z1j 2z1k 2z1l 2z1m 6z1n 1zo zo6gl 4z3oh
zo1on zor6na8 4z1p z5q 6z1r 2z1s8 2z1t z4t3end z4t3hei z8thi 1zu zu3al
zu1b4 zu1f2 6z5uhr zun2a 8zunem zunf8 8zungl zu1o zup8fi zu1s8 zu1z
2z1v zw8 z1wal 5zweck zwei3s z1wel z1wer z6werg 8z5wes 1zwi zwi1s
6z1wo 1zy 2z1z zz8a zzi1s \n{1z"a} \n{1z"o} \n{6z"ol.} \n{z"o1le}
\n{1z"u} \n{2z1"u2b} \n{"a1a6} \n{"ab1l} \n{"a1che} \n{"a3chi}
\n{"ach8sc} \n{"ach8sp} \n{"a5chu} \n{"ack5a} \n{"ad1a} \n{"ad5era}
\n{"a6d5ia} \n{"a1e} \n{"a5fa} \n{"af1l} \n{"aft6s} \n{"ag1h}
\n{"ag3le} \n{"a6g5nan} \n{"ag5str} \n{"a1he} \n{"a1hi} \n{"ah1le}
\n{"ah5ne} \n{1"ahnl} \n{"ah1re} \n{"ah5ri} \n{"ah1ru} \n{"a1hu}
\n{"ah1w} \n{6"ai} \n{"a1isc} \n{"a6ische} \n{"a5ism} \n{"a5j}
\n{"a1k} \n{"al1c} \n{"a1le} \n{"a8lei} \n{"al6schl} \n{"ami1e}
\n{"am8n} \n{"am8s} \n{"a5na} \n{5"anderu} \n{"ane5i8} \n{"ang3l}
\n{"ank5l} \n{"a1no} \n{"an6s5c} \n{"a1pa} \n{"ap6s5c} \n{3"aq}
\n{"ar1c} \n{"a1re} \n{"are8m} \n{5"argern} \n{"ar6gl} \n{"a1ri}
\n{3"armel} \n{"a1ro} \n{"art6s5} \n{"a1ru} \n{3"arztl} \n{"a5r"o}
\n{"a6s5chen} \n{"asen8s} \n{"as1th} \n{"ata8b} \n{"a1te} \n{"ateri4}
\n{"ater5it} \n{"a6thy} \n{"a1ti} \n{3"atk} \n{"a1to} \n{"at8schl}
\n{"ats1p} \n{"a5tu} \n{"aub1l} \n{"au1e} \n{1"aug} \n{"au8ga}
\n{"au5i} \n{"a1um.} \n{"a1us.} \n{1"au\3} \n{\c{1"au\9}} \n{"a1z}
\n{"o1b} \n{"o1che} \n{"o5chi} \n{"och8stei} \n{"och8str} \n{"ocht6}
\n{5"o6dem} \n{5"offn} \n{"o1he} \n{"oh1l8} \n{"oh1re} \n{"o1hu}
\n{"o1is} \n{"o1ke} \n{1"o2ko} \n{1"ol.} \n{"ol6k5l} \n{"ol8pl}
\n{"o1mu} \n{"o5na} \n{"onig6s3} \n{"o1no} \n{"o5o6t} \n{"opf3l}
\n{"op6s5c} \n{"o1re} \n{"or8gli} \n{"o1ri} \n{"or8tr} \n{"o1ru}
\n{5"osterr} \n{"o1te} \n{"o5th} \n{"o1ti} \n{"o1tu} \n{"o1v} \n{"o1w}
\n{"owe8} \n{"o2z} \n{"ub6e2} \n{3"u4ber1} \n{"ub1l} \n{"ub1r}
\n{5"u2bu} \n{"u1che} \n{"u1chi} \n{"u8ch3l} \n{"uch6s5c} \n{"u8ck}
\n{"uck1a} \n{"uck5ers} \n{"ud1a2} \n{"u6deu} \n{"udi8t} \n{"u2d1o4}
\n{"ud5s6} \n{"uge4l5a} \n{"ug1l} \n{"uh5a} \n{"u1he} \n{"u8heh}
\n{"u6h5erk} \n{"uh1le} \n{"uh1re} \n{"uh1ru} \n{"u1hu} \n{"uh1w}
\n{"u3k} \n{"u1le} \n{"ul4l5a} \n{"ul8lo} \n{"ul4ps} \n{"ul6s5c}
\n{"u1lu} \n{"un8da} \n{"un8fei} \n{"unk5l} \n{"un8za} \n{"un6zw}
\n{"u5pi} \n{"u1re} \n{"u8rei} \n{"ur8fl} \n{"ur8fr} \n{"ur8geng}
\n{"u1ri} \n{"u1ro} \n{"ur8sta} \n{"ur8ster} \n{"u1ru} \n{"use8n}
\n{"u8sta} \n{"u8stes} \n{"u6s5tete} \n{"u3ta} \n{"u1te} \n{"u1ti}
\n{"ut8tr} \n{"u1tu} \n{"ut8zei} \n{"u1v} \31a8 \c{\91a8} 5\3a.
\c{5\9a.} \38as \c{\98as} \31b8 \c{\91b8} \31c \c{\91c} \31d \c{\91d}
1\3e \c{1\9e} \35ec \c{\95ec} 8\3e8g \c{8\9e8g} 8\3e8h \c{8\9e8h}
2\31ei \c{2\91ei} 8\3em \c{8\9em} \31f8 \c{\91f8} \31g \c{\91g} \31h
\c{\91h} 1\3i \c{1\9i} \31k \c{\91k} \31l \c{\91l} \31m \c{\91m}
\3mana8 \c{\9mana8} \31n \c{\91n} \31o \c{\91o} \31p8 \c{\91p8} \35q
\c{\95q} \31r \c{\91r} \31s2 \c{\91s2} \3st8 \c{\9st8} \31ta \c{\91ta}
\31te \c{\91te} \3t3hei \c{\9t3hei} \31ti \c{\91ti} \35to \c{\95to}
\31tr \c{\91tr} 1\3u8 \c{1\9u8} 6\35um \c{6\95um} \31v \c{\91v} \31w
\c{\91w} \31z \c{\91z}
}%
\endgroup
\relax\endinput
%
% -----------------------------------------------------------------
%
% =============== Additional Documentation ===============
%
%
% Older Versions of German Hyphenation Patterns:
% ----------------------------------------------
%
% All older versions of `ghyphen.tex' distributed as
%
%       ghyphen.tex/germhyph.tex   as of 1986/11/01
%       ghyphen.min/ghyphen.max    as of 1988/10/10
%       ghyphen3.tex               as of 1990/09/27 & 1991/02/13
%       ghyph31.tex                as of 1994/02/13
%
% are out of date and it is recommended to replace them
% with the new version `dehypht.tex' as of 1999/03/03.
%
% If you are using `ghyphen.min' (a minor version of `ghyphen')
% because of limited trie memory space, try this version and if
% the space is exceeded get a newer TeX implementation with
% larger or configurable trie memory sizes.
%
%
%
% Trie Memory Requirements/Space for Hyphenation Patterns:
% --------------------------------------------------------
%
% To load this set of german hyphenation patterns the parameters
% of TeX has to have at least these values:
%
% TeX 3.x:
%    IniTeX:    trie_size >= 9733    trie_op_size >= 207
%    VirTeX:    trie_size >= 8375    trie_op_size >= 207
%
% TeX 2.x:
%    IniTeX:    trie_size >= 8675    trie_op_size >= 198
%    VirTeX:    trie_size >= 7560    trie_op_size >= 198
%
% If you want to load more than one set of hyphenation patterns
% (in TeX 3.x), the parameters have to be set to a value larger
% than or equal to the sum of all required values for each set.
%
%
% Setting Trie Memory Parameters:
% -------------------------------
%
% Some implementations allow the user to change the default value
% of a set of the internal TeX parameters including the trie memory
% size parameter specifying the used memory for the hyphenation
% patterns.
% 
% Web2c 7.x (Source), teTeX 0.9 (Unix, Amiga), fpTeX (Win32)
% and newer:
%   The used memory size of the true is usually set high enough.
%   If needed set the size of the trie using the keyword `trie_size'
%   in the configuration file `texmf/web2c/texmf.cnf'.  For details
%   see the included documentation.
%
% emTeX (OS/2, MS-DOS, Windows 3.x/9x/NT):
%   You can set the used memory size of the trie using the
%   `-mt<number>' option on the command line or in the
%   TEXOPTIONS environment variable.
%
% PasTeX (Amiga):
%   The values for the parameters can be set using the keywords
%   `triesize', `itriesize' and `trieopsize' in the configuration
%   file.
%
% others (binaries only):
%   See the documentation of the implementation if it is possible
%   and how to change these values without recompilation.
%
% others (with sources)
%   If the trie memory is too small, you have to recompile TeX
%   using larger values for `trie_size' and `trie_op_size'.
%   Modify the change file `tex.ch' and recompile TeX.
%   For details see the documentation included in the sources.
%
%
%
% Necessary Settings in TeX macro files:
% --------------------------------------
%
% \lefthyphenmin, \righthyphenmin:
%   You can set both parameters to 2.
%
% \lccode <char>:
%   To get correct hyphenation points within words containing
%   umlauts or \ss, it's necessary to assign values > 0 to the
%   appropriate \lccode <char> positions.
%
% These changes are _not_ done when reading this file and have to
% be included in the language switching mechanism as is done in,
% for example, `german.sty' (\lccode change for ^^Y = \ss in OT1,
% \left-/\righthyphenmin settings).
%
%
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%%
\endinput
%% 
%% End of file `dehypht.tex'.
                                                                                                                                                                                                                                                                                                                                                                               tackle.vfs/lib/textutil/repeat.tcl                                                                  100644  1751    1751    4353        14145011620 22256   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # repeat.tcl --
#
#	Emulation of string repeat for older
#	revisions of Tcl.
#
# Copyright (c) 2000      by Ajuba Solutions.
# Copyright (c) 2001-2006 by Andreas Kupries <andreas_kupries@users.sourceforge.net>
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: repeat.tcl,v 1.1 2006/04/21 04:42:28 andreas_kupries Exp $

# ### ### ### ######### ######### #########
## Requirements

package require Tcl 8.2

namespace eval ::textutil::repeat {}

# ### ### ### ######### ######### #########

namespace eval ::textutil::repeat {
    variable HaveBuiltin [expr {![catch {string repeat a 1}]}]
}

if {0} {
    # Problems with the deactivated code:
    # - Linear in 'num'.
    # - Tests for 'string repeat' in every call!
    #   (Ok, just the variable, still a test every call)
    # - Fails for 'num == 0' because of undefined 'str'.

    proc textutil::repeat::StrRepeat { char num } {
	variable HaveBuiltin
	if { $HaveBuiltin == 0 } then {
	    for { set i 0 } { $i < $num } { incr i } {
		append str $char
	    }
	} else {
	    set str [ string repeat $char $num ]
	}
	return $str
    }
}

if {$::textutil::repeat::HaveBuiltin} {
    proc ::textutil::repeat::strRepeat {char num} {
	return [string repeat $char $num]
    }

    proc ::textutil::repeat::blank {n} {
	return [string repeat " " $n]
    }
} else {
    proc ::textutil::repeat::strRepeat {char num} {
	if {$num <= 0} {
	    # No replication required
	    return ""
	} elseif {$num == 1} {
	    # Quick exit for recursion
	    return $char
	} elseif {$num == 2} {
	    # Another quick exit for recursion
	    return $char$char
	} elseif {0 == ($num % 2)} {
	    # Halving the problem results in O (log n) complexity.
	    set result [strRepeat $char [expr {$num / 2}]]
	    return "$result$result"
	} else {
	    # Uneven length, reduce problem by one
	    return "$char[strRepeat $char [incr num -1]]"
	}
    }

    proc ::textutil::repeat::blank {n} {
	return [strRepeat " " $n]
    }
}

# ### ### ### ######### ######### #########
## Data structures

namespace eval ::textutil::repeat {
    namespace export strRepeat blank
}

# ### ### ### ######### ######### #########
## Ready

package provide textutil::repeat 0.7
                                                                                                                                                                                                                                                                                     tackle.vfs/lib/textutil/ithyph.tex                                                                  100644  1751    1751    22543       14145011620 22342   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        
%%%%%%%%%%%%%%%%%%%% file ithyph.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%  file ithyph.tex  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Prepared by Claudio Beccari   e-mail  beccari@polito.it
%
%                                       Dipartimento di Elettronica
%                                       Politecnico di Torino
%                                       Corso Duca degli Abruzzi, 24
%                                       10129 TORINO
%
% Copyright  1998, 2001 Claudio Beccari
%
% This program can be redistributed and/or modified under the terms
% of the LaTeX Project Public License Distributed from CTAN
% archives in directory macros/latex/base/lppl.txt; either
% version 1 of the License, or any later version.
%
% \versionnumber{4.8d}   \versiondate{2001/11/21}
%
% These hyphenation patterns for the Italian language are supposed to comply
% with the Reccomendation UNI 6461 on hyphenation issued by the Italian
% Standards Institution (Ente Nazionale di Unificazione UNI).  No guarantee
% or declaration of fitness to any particular purpose is given and any
% liability is disclaimed.
%
% See comments and loading instructions at the end of the file after the
% \endinput line
%
{\lccode`\'=`\'      % Apostrophe has its own lccode so that it is treated
                     % as a letter
                     %>> 1998/04/14 inserted grouping
                     %
%\lccode23=23        % Compound word mark is a letter in encoding T1
%\def\W{^^W}         % ^^W =\char23 = \char"17 =\char'27
%
\patterns{
.a3p2n               % After the Garzanti dictionary: a-pnea, a-pnoi-co,...
.anti1  .anti3m2n
.bio1
.ca4p3s
.circu2m1
.di2s3cine
%.e2x
.fran2k3
.free3
.narco1
.opto1
.orto3p2
.para1
.poli3p2
.pre1
.p2s
%.ri1a2   .ri1e2    .re1i2  .ri1o2  .ri1u2
.sha2re3
.tran2s3c .tran2s3d .tran2s3f .tran2s3l .tran2s3n .tran2s3p .tran2s3r .tran2s3t
.su2b3lu   .su2b3r
.wa2g3n
.wel2t1
a1ia a1ie  a1io  a1iu a1uo a1ya 2at.
e1iu e2w
o1ia o1ie  o1io  o1iu
%u1u
%
%1\W0a2 1\W0e2 1\W0i2 1\W0o2 1\W0u2
'2
1b   2bb   2bc   2bd  2bf  2bm  2bn  2bp  2bs  2bt  2bv
     b2l   b2r   2b.  2b'. 2b''
1c   2cb   2cc   2cd  2cf  2ck  2cm  2cn  2cq  2cs  2ct  2cz
     2chh  c2h   2chb ch2r 2chn c2l  c2r  2c.  2c'. 2c'' .c2
1d   2db   2dd   2dg  2dl  2dm  2dn  2dp  d2r  2ds  2dt  2dv  2dw
     2d.   2d'.  2d'' .d2
1f   2fb   2fg   2ff  2fn  f2l  f2r  2fs  2ft  2f.  2f'. 2f''
1g   2gb   2gd   2gf  2gg  g2h  g2l  2gm  g2n  2gp  g2r  2gs  2gt
     2gv   2gw   2gz  2gh2t     2g.  2g'. 2g''
1h   2hb   2hd   2hh  hi3p2n    h2l  2hm  2hn  2hr  2hv  2h.  2h'.  2h''
1j   2j.   2j'.  2j''
1k   2kg   2kf   k2h  2kk  k2l  2km  k2r  2ks  2kt  2k.  2k'. 2k''
1l   2lb   2lc   2ld  2l3f2     2lg  l2h  2lk  2ll  2lm  2ln  2lp
     2lq   2lr   2ls  2lt  2lv  2lw  2lz  2l.  2l'. 2l''
1m   2mb   2mc   2mf  2ml  2mm  2mn  2mp  2mq  2mr  2ms  2mt  2mv  2mw
     2m.   2m'.  2m''
1n   2nb   2nc   2nd  2nf  2ng  2nk  2nl  2nm  2nn  2np  2nq  2nr
     2ns   2nt   2nv  2nz  n2g3n     2nheit.   2n.  2n'  2n''
1p   2pd   p2h   p2l  2pn  3p2ne 2pp p2r  2ps  3p2sic 2pt  2pz  2p.  2p'. 2p''
1q   2qq   2q.   2q'. 2q''
1r   2rb   2rc   2rd  2rf  r2h  2rg  2rk  2rl  2rm  2rn  2rp
     2rq   2rr   2rs  2rt  rt2s3 2rv 2rx  2rw  2rz  2r.  2r'. 2r''
1s2  2shm  2s3s  s4s3m 2s3p2n   2stb 2stc 2std 2stf 2stg 2stm 2stn
     2stp  2sts  2stt 2stv 2sz  4s.  4s'. 4s''
1t   2tb   2tc   2td  2tf  2tg  t2h  t2l  2tm  2tn  2tp  t2r  2ts
     3t2sch      2tt  2tv  2tw  t2z  2tzk 2tzs 2t.  2t'. 2t''
1v   2vc   v2l   v2r  2vv  2v.  2v'. 2v''
1w   w2h   wa2r  2w1y 2w.  2w'. 2w''
1x   2xt   2xw   2x.   2x'. 2x''
y1ou y1i
1z   2zb   2zd   2zl  2zn  2zp  2zt  2zs  2zv  2zz  2z.  2z'. 2z''  .z2
}}                          % Pattern end

\endinput

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Information %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


                           LOADING THESE PATTERNS

These patterns, as well  as  those  for  any  other  language, do not become
effective until they are loaded in a special form into a format  file;  this
task  is  performed  by  the  TeX  initializer;  any  TeX system has its own
initializer with its special way  of  being activated.  Before loading these
patterns, then, it is necessary to read very carefully the instructions that
come with your TeX system.

Here I describe how to load the  patterns with the freeware TeX system named
MiKTeX version 2.x for Windows 9x, NT, 2000,  XP;  with  minor  changes  the
whole  procedure  is applicable with other TeX systems, but the details must
be deduced from your TeX system documentation at the section/chapter "How to
build or to rebuild a format file".

With MikTeX:

a) copy this file and replace  the existing file ithyph.tex in the directory
   \texmf\tex\generic\hyphen if the existing one has an older  version  date
   and number.
b) select Start|Programs|MiKTeX|MiKTeX options.
c) in  the  Language tab add a check mark to the line concerning the Italian
   language.
d) in the Geneal tab click "Update format files".
e) That's all!  

For the activation of these  patterns  with the specific Italian typesetting
features, use the babel package as this:

\documentclass{article} % Or whatever other class
\usepackage[italian]{babel}
...
\begin{document}
...
\end{document}


                           ON ITALIAN HYPHENATION

I have been working on patterns for the Italian language since 1987; in 1992
I published

C. Beccari, "Computer aided hyphenation for Italian and Modern
      Latin", TUG vol. 13, n. 1, pp. 23-33 (1992)

which contained a set of patterns that allowed hyphenation for both  Italian
and  Latin;  a  slightly  modified  version of the patterns published in the
above paper is contained in LAHYPH.TEX available on the CTAN archives.

From  the  above  patterns  I  extracted  the  minimum  set  necessary   for
hyphenating  Italian  that  was made available on the CTAN archives with the
name ITHYPH.tex the version number  3.5  on  the  16th of August 1994.  

The  original  pattern  set  required  37  ops;  being interested in a local
version of TeX/LaTeX  capable  of  dealing  with  half  a dozen languages, I
wanted to reduce memory occupation and therefore the number of ops.

Th new version (4.0 released  in  1996)  of  ITHYPH.TEX is much simpler than
version 3.5 and requires just 29 ops while  it  retains  all  the  power  of
version  3.5;  it  contains  many  more new patterns that allow to hyphenate
unusual words that generally have  a  root borrowed from a foreign language.
Updated versions 4.x contain minor  additions  and  the  number  of  ops  is
increased to 30 (version 4.7 of 1998/06/01).

This new pattern set has been tested  with the same set of difficult Italian
words that was used to test version 3.5 and it yields the  same  results  (a
part  a  minor  change  that was deliberately introduced so as to reduce the
typographical hyphenation  with  hyathi,  since  hyphenated  hyathi  are not
appreciated by Italian readers).   A  new  enlarged  word  set  for  testing
purposes  gets correct hyphen points that were missed or wrongly placed with
version 3.5, although no error had  been reported, because such words are of
very specialized nature and are seldom used.

As the previous version, this new set  of  patterns  does  not  contain  any
accented  character  so  that  the hyphenation algorithm behaves properly in
both cases, that is with cm  and  with dc/ec fonts.  With LaTeXe terminology
the difference is between OT1 and T1 encodings;  with  the  former  encoding
fonts  do  not  contain  accented characters, while with the latter accented
characters are present and sequences  such  as  \`a map directly to slot "E0
that contains "agrave".

Of course if you use dc/ec fonts (or any other real or virtual font with  T1
encoding)  you get the full power of the hyphenation algorithm, while if you
use cm fonts (or any other real or virtual font with OT1 encoding) you  miss
some  possible  break  points;  this  is  not a big inconvenience in Italian
because:

1) The Regulation UNI 6015 on  accents  specifies  that  compulsory  accents
   appear  only  on the ending vowel of oxitone words; this means that it is
   almost indifferent to have or  to  miss  the dc/ec fonts because the only
   difference consists in how TeX evaluates the end of the word; in practice
   if you have these special facilities you get "qua-li-t\`a", while if  you
   miss them, you get "qua-lit\`a" (assuming that \righthyphenmin > 1).

2)  Optional  accents are so rare in Italian, that if you absolutely want to
   use  them  in  those  rare  instances,  and  you  miss  the  T1  encoding
   facilities, you should also provide  explicit discretionary hyphens as in
   "s\'e\-gui\-to".

There is no explicit  hyphenation  exception  list  because  these  patterns
proved  to  hyphenate correctly a very large set of words suitably chosen in
order to test them in the most heavy circumstances; these patterns were used
in the preparation of a number of books and no errors were discovered.

Nevertheless if you frequently use  technical terms that you want hyphenated
differently  from  what  is  normally  done  (for  example  if  you   prefer
etymological  hyphenation  of  prefixed  and/or  suffixed  words) you should
insert a specific hyphenation  list  in  the  preamble of your document, for
example:

\hyphenation{su-per-in-dut-to-re su-per-in-dut-to-ri}

Should you find any word that gets hyphenated in a wrong way, please, AFTER
CHECKING ON A RELIABLE MODERN DICTIONARY, report to the author, preferably
by e-mail.


                       Happy multilingual typesetting !
                                                                                                                                                             tackle.vfs/lib/textutil/eshyph_vo.tex                                                               100644  1751    1751    13751       14145011620 23042   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        .\'a2
.\'aa2
.\'ae2
.\'ai2
.\'ao2
.\'au2
.\'e2
.\'ea2
.\'ee2
.\'ei2
.\'eo2
.\'eu2
.\'i2
.\'ia2
.\'ie2
.\'ii2
.\'io2
.\'iu2
.\'o2
.\'oa2
.\'oe2
.\'oi2
.\'oo2
.\'ou2
.\'u2
.\'ua2
.\'ue2
.\'ui2
.\'uo2
.\'uu2
.a2
.a\'a2
.a\'e2
.a\'i2
.a\'o2
.a\'u2
.aa2
.ae2
.ai2
.ao2
.au2
.e2
.e\'a2
.e\'e2
.e\'i2
.e\'o2
.e\'u2
.ea2
.ee2
.ei2
.eo2
.eu2
.i2
.i\'a2
.i\'e2
.i\'i2
.i\'o2
.i\'u2
.ia2
.ie2
.ii2
.io2
.iu2
.o2
.o\'a2
.o\'e2
.o\'i2
.o\'o2
.o\'u2
.oa2
.oe2
.oi2
.oo2
.ou2
.u2
.u\'a2
.u\'e2
.u\'i2
.u\'o2
.u\'u2
.ua2
.ue2
.ui2
.uo2
.uu2
2\'a.
2\'aa.
2\'ae.
2\'ai.
2\'ao.
2\'au.
2\'e.
2\'ea.
2\'ee.
2\'ei.
2\'eo.
2\'eu.
2\'i.
2\'ia.
2\'ie.
2\'ii.
2\'io.
2\'iu.
2\'o.
2\'oa.
2\'oe.
2\'oi.
2\'oo.
2\'ou.
2\'u.
2\'ua.
2\'ue.
2\'ui.
2\'uo.
2\'uu.
2\~n1\~n
2\~n1b
2\~n1c
2\~n1d
2\~n1f
2\~n1g
2\~n1h
2\~n1j
2\~n1k
2\~n1m
2\~n1n
2\~n1p
2\~n1q
2\~n1s
2\~n1t
2\~n1v
2\~n1w
2\~n1x
2\~n1y
2\~n1z
2a.
2a\'a.
2a\'e.
2a\'i.
2a\'o.
2a\'u.
2aa.
2ae.
2ai.
2ao.
2au.
2b1\~n
2b1b
2b1c
2b1d
2b1f
2b1g
2b1h
2b1j
2b1k
2b1m
2b1n
2b1p
2b1q
2b1s
2b1t
2b1v
2b1w
2b1x
2b1y
2b1z
2c1\~n
2c1b
2c1c
2c1d
2c1f
2c1g
2c1j
2c1k
2c1m
2c1n
2c1p
2c1q
2c1s
2c1t
2c1v
2c1w
2c1x
2c1y
2c1z
2d1\~n
2d1b
2d1c
2d1d
2d1f
2d1g
2d1h
2d1j
2d1k
2d1m
2d1n
2d1p
2d1q
2d1s
2d1t
2d1v
2d1w
2d1x
2d1y
2d1z
2e.
2e\'a.
2e\'e.
2e\'i.
2e\'o.
2e\'u.
2ea.
2ee.
2ei.
2eo.
2eu.
2f1\~n
2f1b
2f1c
2f1d
2f1f
2f1g
2f1h
2f1j
2f1k
2f1m
2f1n
2f1p
2f1q
2f1s
2f1t
2f1v
2f1w
2f1x
2f1y
2f1z
2g1\~n
2g1b
2g1c
2g1d
2g1f
2g1g
2g1h
2g1j
2g1k
2g1m
2g1n
2g1p
2g1q
2g1s
2g1t
2g1v
2g1w
2g1x
2g1y
2g1z
2h1\~n
2h1b
2h1c
2h1d
2h1f
2h1g
2h1h
2h1j
2h1k
2h1m
2h1n
2h1p
2h1q
2h1s
2h1t
2h1v
2h1w
2h1x
2h1y
2h1z
2i.
2i\'a.
2i\'e.
2i\'i.
2i\'o.
2i\'u.
2ia.
2ie.
2ii.
2io.
2iu.
2j1\~n
2j1b
2j1c
2j1d
2j1f
2j1g
2j1h
2j1j
2j1k
2j1m
2j1n
2j1p
2j1q
2j1s
2j1t
2j1v
2j1w
2j1x
2j1y
2j1z
2k1\~n
2k1b
2k1c
2k1d
2k1f
2k1g
2k1h
2k1j
2k1k
2k1m
2k1n
2k1p
2k1q
2k1s
2k1t
2k1v
2k1w
2k1x
2k1y
2k1z
2l1\~n
2l1b
2l1c
2l1d
2l1f
2l1g
2l1h
2l1j
2l1k
2l1m
2l1n
2l1p
2l1q
2l1s
2l1t
2l1v
2l1w
2l1x
2l1y
2l1z
2m1\~n
2m1b
2m1c
2m1d
2m1f
2m1g
2m1h
2m1j
2m1k
2m1l
2m1m
2m1n
2m1p
2m1q
2m1r
2m1s
2m1t
2m1v
2m1w
2m1x
2m1y
2m1z
2n1\~n
2n1b
2n1c
2n1d
2n1f
2n1g
2n1h
2n1j
2n1k
2n1l
2n1m
2n1n
2n1p
2n1q
2n1r
2n1s
2n1t
2n1v
2n1w
2n1x
2n1y
2n1z
2o.
2o\'a.
2o\'e.
2o\'i.
2o\'o.
2o\'u.
2oa.
2oe.
2oi.
2oo.
2ou.
2p1\~n
2p1b
2p1c
2p1d
2p1f
2p1g
2p1h
2p1j
2p1k
2p1m
2p1n
2p1p
2p1q
2p1s
2p1t
2p1v
2p1w
2p1x
2p1y
2p1z
2q1\~n
2q1b
2q1c
2q1d
2q1f
2q1g
2q1h
2q1j
2q1k
2q1m
2q1n
2q1p
2q1q
2q1s
2q1t
2q1v
2q1w
2q1x
2q1y
2q1z
2r1\~n
2r1b
2r1c
2r1d
2r1f
2r1g
2r1h
2r1j
2r1k
2r1m
2r1n
2r1p
2r1q
2r1s
2r1t
2r1v
2r1w
2r1x
2r1y
2r1z
2s1\~n
2s1b
2s1c
2s1d
2s1f
2s1g
2s1h
2s1j
2s1k
2s1m
2s1n
2s1p
2s1q
2s1s
2s1t
2s1v
2s1w
2s1x
2s1y
2s1z
2t1\~n
2t1b
2t1c
2t1d
2t1f
2t1g
2t1h
2t1j
2t1k
2t1m
2t1n
2t1p
2t1q
2t1s
2t1t
2t1v
2t1w
2t1x
2t1y
2t1z
2u.
2u\'a.
2u\'e.
2u\'i.
2u\'o.
2u\'u.
2ua.
2ue.
2ui.
2uo.
2uu.
2v1\~n
2v1b
2v1c
2v1d
2v1f
2v1g
2v1h
2v1j
2v1k
2v1m
2v1n
2v1p
2v1q
2v1s
2v1t
2v1v
2v1w
2v1x
2v1y
2v1z
2w1\~n
2w1b
2w1c
2w1d
2w1f
2w1g
2w1h
2w1j
2w1k
2w1m
2w1n
2w1p
2w1q
2w1s
2w1t
2w1v
2w1w
2w1x
2w1y
2w1z
2x1\~n
2x1b
2x1c
2x1d
2x1f
2x1g
2x1h
2x1j
2x1k
2x1m
2x1n
2x1p
2x1q
2x1s
2x1t
2x1v
2x1w
2x1x
2x1y
2x1z
2y1\~n
2y1b
2y1c
2y1d
2y1f
2y1g
2y1h
2y1j
2y1k
2y1m
2y1n
2y1p
2y1q
2y1s
2y1t
2y1v
2y1w
2y1x
2y1y
2y1z
2z1\~n
2z1b
2z1c
2z1d
2z1f
2z1g
2z1h
2z1j
2z1k
2z1m
2z1n
2z1p
2z1q
2z1s
2z1t
2z1v
2z1w
2z1x
2z1y
2z1z
\'a1\'i
\'a1\'u
\'a1\~n
\'a1a
\'a1b
\'a1c
\'a1d
\'a1e
\'a1f
\'a1g
\'a1h
\'a1j
\'a1k
\'a1l
\'a1m
\'a1n
\'a1o
\'a1p
\'a1q
\'a1r
\'a1s
\'a1t
\'a1v
\'a1w
\'a1x
\'a1y
\'a1z
\'a2\~n.
\'a2b.
\'a2c.
\'a2d.
\'a2f.
\'a2g.
\'a2h.
\'a2j.
\'a2k.
\'a2l.
\'a2m.
\'a2n.
\'a2p.
\'a2q.
\'a2r.
\'a2s.
\'a2t.
\'a2v.
\'a2w.
\'a2x.
\'a2y.
\'a2z.
\'e1\'i
\'e1\'u
\'e1\~n
\'e1a
\'e1b
\'e1c
\'e1d
\'e1e
\'e1f
\'e1g
\'e1h
\'e1j
\'e1k
\'e1l
\'e1m
\'e1n
\'e1o
\'e1p
\'e1q
\'e1r
\'e1s
\'e1t
\'e1v
\'e1w
\'e1x
\'e1y
\'e1z
\'e2\~n.
\'e2b.
\'e2c.
\'e2d.
\'e2f.
\'e2g.
\'e2h.
\'e2j.
\'e2k.
\'e2l.
\'e2m.
\'e2n.
\'e2p.
\'e2q.
\'e2r.
\'e2s.
\'e2t.
\'e2v.
\'e2w.
\'e2x.
\'e2y.
\'e2z.
\'i1\'a
\'i1\'e
\'i1\'o
\'i1\~n
\'i1a
\'i1b
\'i1c
\'i1d
\'i1e
\'i1f
\'i1g
\'i1h
\'i1j
\'i1k
\'i1l
\'i1m
\'i1n
\'i1o
\'i1p
\'i1q
\'i1r
\'i1s
\'i1t
\'i1v
\'i1w
\'i1x
\'i1y
\'i1z
\'i2\~n.
\'i2b.
\'i2c.
\'i2d.
\'i2f.
\'i2g.
\'i2h.
\'i2j.
\'i2k.
\'i2l.
\'i2m.
\'i2n.
\'i2p.
\'i2q.
\'i2r.
\'i2s.
\'i2t.
\'i2v.
\'i2w.
\'i2x.
\'i2y.
\'i2z.
\'o1\'i
\'o1\'u
\'o1\~n
\'o1a
\'o1b
\'o1c
\'o1d
\'o1e
\'o1f
\'o1g
\'o1h
\'o1j
\'o1k
\'o1l
\'o1m
\'o1n
\'o1o
\'o1p
\'o1q
\'o1r
\'o1s
\'o1t
\'o1v
\'o1w
\'o1x
\'o1y
\'o1z
\'o2\~n.
\'o2b.
\'o2c.
\'o2d.
\'o2f.
\'o2g.
\'o2h.
\'o2j.
\'o2k.
\'o2l.
\'o2m.
\'o2n.
\'o2p.
\'o2q.
\'o2r.
\'o2s.
\'o2t.
\'o2v.
\'o2w.
\'o2x.
\'o2y.
\'o2z.
\'u1\'a
\'u1\'e
\'u1\'o
\'u1\~n
\'u1a
\'u1b
\'u1c
\'u1d
\'u1e
\'u1f
\'u1g
\'u1h
\'u1j
\'u1k
\'u1l
\'u1m
\'u1n
\'u1o
\'u1p
\'u1q
\'u1r
\'u1s
\'u1t
\'u1v
\'u1w
\'u1x
\'u1y
\'u1z
\'u2\~n.
\'u2b.
\'u2c.
\'u2d.
\'u2f.
\'u2g.
\'u2h.
\'u2j.
\'u2k.
\'u2l.
\'u2m.
\'u2n.
\'u2p.
\'u2q.
\'u2r.
\'u2s.
\'u2t.
\'u2v.
\'u2w.
\'u2x.
\'u2y.
\'u2z.
a1\'a
a1\'e
a1\'i
a1\'o
a1\'u
a1\~n
a1a
a1b
a1c
a1d
a1e
a1f
a1g
a1h
a1j
a1k
a1l
a1m
a1n
a1o
a1p
a1q
a1r
a1s
a1t
a1v
a1w
a1x
a1y
a1z
a2\~n.
a2b.
a2c.
a2d.
a2f.
a2g.
a2h.
a2j.
a2k.
a2l.
a2m.
a2n.
a2p.
a2q.
a2r.
a2s.
a2t.
a2v.
a2w.
a2x.
a2y.
a2z.
e1\'a
e1\'e
e1\'i
e1\'o
e1\'u
e1\~n
e1a
e1b
e1c
e1d
e1e
e1f
e1g
e1h
e1j
e1k
e1l
e1m
e1n
e1o
e1p
e1q
e1r
e1s
e1t
e1v
e1w
e1x
e1y
e1z
e2\~n.
e2b.
e2c.
e2d.
e2f.
e2g.
e2h.
e2j.
e2k.
e2l.
e2m.
e2n.
e2p.
e2q.
e2r.
e2s.
e2t.
e2v.
e2w.
e2x.
e2y.
e2z.
i1\~n
i1b
i1c
i1d
i1f
i1g
i1h
i1j
i1k
i1l
i1m
i1n
i1p
i1q
i1r
i1s
i1t
i1v
i1w
i1x
i1y
i1z
i2\~n.
i2b.
i2c.
i2d.
i2f.
i2g.
i2h.
i2j.
i2k.
i2l.
i2m.
i2n.
i2p.
i2q.
i2r.
i2s.
i2t.
i2v.
i2w.
i2x.
i2y.
i2z.
o1\'a
o1\'e
o1\'i
o1\'o
o1\'u
o1\~n
o1a
o1b
o1c
o1d
o1e
o1f
o1g
o1h
o1j
o1k
o1l
o1m
o1n
o1o
o1p
o1q
o1r
o1s
o1t
o1v
o1w
o1x
o1y
o1z
o2\~n.
o2b.
o2c.
o2d.
o2f.
o2g.
o2h.
o2j.
o2k.
o2l.
o2m.
o2n.
o2p.
o2q.
o2r.
o2s.
o2t.
o2v.
o2w.
o2x.
o2y.
o2z.
u1\~n
u1b
u1c
u1d
u1f
u1g
u1h
u1j
u1k
u1l
u1m
u1n
u1p
u1q
u1r
u1s
u1t
u1v
u1w
u1x
u1y
u1z
u2\~n.
u2b.
u2c.
u2d.
u2f.
u2g.
u2h.
u2j.
u2k.
u2l.
u2m.
u2n.
u2p.
u2q.
u2r.
u2s.
u2t.
u2v.
u2w.
u2x.
u2y.
u2z.
                       tackle.vfs/lib/textutil/adjust.tcl                                                                  100644  1751    1751    46664       14145011620 22323   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # trim.tcl --
#
#	Various ways of trimming a string.
#
# Copyright (c) 2000      by Ajuba Solutions.
# Copyright (c) 2000      by Eric Melski <ericm@ajubasolutions.com>
# Copyright (c) 2002-2004 by Johannes-Heinrich Vogeler <vogeler@users.sourceforge.net>
# Copyright (c) 2001-2006 by Andreas Kupries <andreas_kupries@users.sourceforge.net>
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: adjust.tcl,v 1.16 2011/12/13 18:12:56 andreas_kupries Exp $

# ### ### ### ######### ######### #########
## Requirements

package require Tcl 8.2
package require textutil::repeat
package require textutil::string

namespace eval ::textutil::adjust {}

# ### ### ### ######### ######### #########
## API implementation

namespace eval ::textutil::adjust {
    namespace import -force ::textutil::repeat::strRepeat
}

proc ::textutil::adjust::adjust {text args} {
    if {[string length [string trim $text]] == 0} {
        return ""
    }

    Configure $args
    Adjust text newtext

    return $newtext
}

proc ::textutil::adjust::Configure {args} {
    variable Justify      left
    variable Length       72
    variable FullLine     0
    variable StrictLength 0
    variable Hyphenate    0
    variable HyphPatterns    ; # hyphenation patterns (TeX)

    set args [ lindex $args 0 ]
    foreach { option value } $args {
	switch -exact -- $option {
	    -full {
		if { ![ string is boolean -strict $value ] } then {
		    error "expected boolean but got \"$value\""
		}
		set FullLine [ string is true $value ]
	    }
	    -hyphenate {
		# the word exceeding the length of line is tried to be
		# hyphenated; if a word cannot be hyphenated to fit into
		# the line processing stops! The length of the line should
		# be set to a reasonable value!

		if { ![ string is boolean -strict $value ] } then {
		    error "expected boolean but got \"$value\""
		}
		set Hyphenate [string is true $value]
		if { $Hyphenate && ![info exists HyphPatterns(_LOADED_)]} {
		    error "hyphenation patterns not loaded!"
		}
	    }
	    -justify {
		set lovalue [ string tolower $value ]
		switch -exact -- $lovalue {
		    left -
		    right -
		    center -
		    plain {
			set Justify $lovalue
		    }
		    default {
			error "bad value \"$value\": should be center, left, plain or right"
		    }
		}
	    }
	    -length {
		if { ![ string is integer $value ] } then {
		    error "expected positive integer but got \"$value\""
		}
		if { $value < 1 } then {
		    error "expected positive integer but got \"$value\""
		}
		set Length $value
	    }
	    -strictlength {
		# the word exceeding the length of line is moved to the
		# next line without hyphenation; words longer than given
		# line length are cut into smaller pieces

		if { ![ string is boolean -strict $value ] } then {
		    error "expected boolean but got \"$value\""
		}
		set StrictLength [ string is true $value ]
	    }
	    default {
		error "bad option \"$option\": must be -full, -hyphenate, \
			-justify, -length, or -strictlength"
	    }
	}
    }

    return ""
}

# ::textutil::adjust::Adjust
#
# History:
#      rewritten on 2004-04-13 for bugfix tcllib-bugs-882402 (jhv)

proc ::textutil::adjust::Adjust { varOrigName varNewName } {
    variable Length
    variable FullLine
    variable StrictLength
    variable Hyphenate

    upvar $varOrigName orig
    upvar $varNewName  text

    set pos 0;                                   # Cursor after writing
    set line ""
    set text ""


    if {!$FullLine} {
	regsub -all -- "(\n)|(\t)"     $orig   " "  orig
	regsub -all -- " +"            $orig  " "   orig
	regsub -all -- "(^ *)|( *\$)"  $orig  ""    orig
    }

    set words [split $orig]
    set numWords [llength $words]
    set numline 0

    for {set cnt 0} {$cnt < $numWords} {incr cnt} {

	set w [lindex $words $cnt]
	set wLen [string length $w]

	# the word $w doesn't fit into the present line
	# case #1: we try to hyphenate

	if {$Hyphenate && ($pos+$wLen >= $Length)} {
	    # Hyphenation instructions
	    set w2 [textutil::adjust::Hyphenation $w]

	    set iMax [llength $w2]
	    if {$iMax == 1 && [string length $w] > $Length} {
		# word cannot be hyphenated and exceeds linesize

		error "Word \"$w2\" can\'t be hyphenated\
			and exceeds linesize $Length!"
	    } else {
		# hyphenating of $w was successfull, but we have to look
		# that every sylable would fit into the line

		foreach x $w2 {
		    if {[string length $x] >= $Length} {
			error "Word \"$w\" can\'t be hyphenated\
				to fit into linesize $Length!"
		    }
		}
	    }

	    for {set i 0; set w3 ""} {$i < $iMax} {incr i} {
		set syl [lindex $w2 $i]
		if {($pos+[string length " $w3$syl-"]) > $Length} {break}
		append w3 $syl
	    }
	    for {set w4 ""} {$i < $iMax} {incr i} {
		set syl [lindex $w2 $i]
		append w4 $syl
	    }

	    if {[string length $w3] && [string length $w4]} {
		# hyphenation was successfull: redefine
		# list of words w => {"$w3-" "$w4"}

		set x [lreplace $words $cnt $cnt "$w4"]
		set words [linsert $x $cnt "$w3-"]
		set w [lindex $words $cnt]
		set wLen [string length $w]
		incr numWords
	    }
	}

	# the word $w doesn't fit into the present line
	# case #2: we try to cut the word into pieces

	if {$StrictLength && ([string length $w] > $Length)} {
	    # cut word into two pieces
	    set w2 $w

	    set over [expr {$pos+2+$wLen-$Length}]

	    incr Length -1
	    set w3   [string range $w2 0 $Length]
	    incr Length
	    set w4   [string range $w2 $Length end]

	    set x [lreplace $words $cnt $cnt $w4]
	    set words [linsert $x $cnt $w3 ]
	    set w [lindex $words $cnt]
	    set wLen [string length $w]
	    incr numWords
	}

	# continuing with the normal procedure

	if {($pos+$wLen < $Length)} {
	    # append word to current line

	    if {$pos} {append line " "; incr pos}
	    append line $w
	    incr pos $wLen
	} else {
	    # line full => write buffer and  begin a new line

	    if {[string length $text]} {append text "\n"}
	    append text [Justification $line [incr numline]]
	    set line $w
	    set pos $wLen
	}
    }

    # write buffer and return!

    if {[string length $text]} {append text "\n"}
    append text [Justification $line end]
    return $text
}

# ::textutil::adjust::Justification
#
# justify a given line
#
# Parameters:
#      line    text for justification
#      index   index for line in text
#
# Returns:
#      the justified line
#
# Remarks:
#      Only lines with size not exceeding the max. linesize provided
#      for text formatting are justified!!!

proc ::textutil::adjust::Justification { line index } {
    variable Justify
    variable Length
    variable FullLine

    set len [string length $line];               # length of current line

    if { $Length <= $len } then {
	# the length of current line ($len) is equal as or greater than
	# the value provided for text formatting ($Length) => to avoid
	# inifinite loops we leave $line unchanged and return!

	return $line
    }

    # Special case:
    # for the last line, and if the justification is set to 'plain'
    # the real justification is 'left' if the length of the line
    # is less than 90% (rounded) of the max length allowed. This is
    # to avoid expansion of this line when it is too small: without
    # it, the added spaces will 'unbeautify' the result.
    #

    set justify $Justify
    if { ( "$index" == "end" ) && \
	    ( "$Justify" == "plain" ) && \
	    ( $len < round($Length * 0.90) ) } then {
	set justify left
    }

    # For a left justification, nothing to do, but to
    # add some spaces at the end of the line if requested

    if { "$justify" == "left" } then {
	set jus ""
	if { $FullLine } then {
	    set jus [strRepeat " " [ expr { $Length - $len } ]]
	}
	return "${line}${jus}"
    }

    # For a right justification, just add enough spaces
    # at the beginning of the line

    if { "$justify" == "right" } then {
	set jus [strRepeat " " [ expr { $Length - $len } ]]
	return "${jus}${line}"
    }

    # For a center justification, add half of the needed spaces
    # at the beginning of the line, and the rest at the end
    # only if needed.

    if { "$justify" == "center" } then {
	set mr [ expr { ( $Length - $len ) / 2 } ]
	set ml [ expr { $Length - $len - $mr } ]
	set jusl [strRepeat " " $ml]
	set jusr [strRepeat " " $mr]
	if { $FullLine } then {
	    return "${jusl}${line}${jusr}"
	} else {
	    return "${jusl}${line}"
	}
    }

    # For a plain justification, it's a little bit complex:
    #
    # if some spaces are missing, then
    #
    # 1) sort the list of words in the current line by decreasing size
    # 2) foreach word, add one space before it, except if it's the
    #    first word, until enough spaces are added
    # 3) rebuild the line

    if { "$justify" == "plain" } then {
	set miss [ expr { $Length - [ string length $line ] } ]

	# Bugfix tcllib-bugs-860753 (jhv)

	set words [split $line]
	set numWords [llength $words]

	if {$numWords < 2} {
	    # current line consists of less than two words - we can't
	    # insert blanks to achieve a plain justification => leave
	    # $line unchanged and return!

	    return $line
	}

	for {set i 0; set totalLen 0} {$i < $numWords} {incr i} {
	    set w($i) [lindex $words $i]
	    if {$i > 0} {set w($i) " $w($i)"}
	    set wLen($i) [string length $w($i)]
	    set totalLen [expr {$totalLen+$wLen($i)}]
	}

	set miss [expr {$Length - $totalLen}]

	# len walks through all lengths of words of the line under
	# consideration

	for {set len 1} {$miss > 0} {incr len} {
	    for {set i 1} {($i < $numWords) && ($miss > 0)} {incr i} {
		if {$wLen($i) == $len} {
		    set w($i) " $w($i)"
		    incr wLen($i)
		    incr miss -1
		}
	    }
	}

	set line ""
	for {set i 0} {$i < $numWords} {incr i} {
	    set line "$line$w($i)"
	}

	# End of bugfix

	return "${line}"
    }

    error "Illegal justification key \"$justify\""
}

proc ::textutil::adjust::SortList { list dir index } {

    if { [ catch { lsort -integer -$dir -index $index $list } sl ] != 0 } then {
        error "$sl"
    }

    return $sl
}

# Hyphenation utilities based on Knuth's algorithm
#
# Copyright (C) 2001-2003 by Dr.Johannes-Heinrich Vogeler (jhv)
# These procedures may be used as part of the tcllib

# textutil::adjust::Hyphenation
#
#      Hyphenate a string using Knuth's algorithm
#
# Parameters:
#      str     string to be hyphenated
#
# Returns:
#      the hyphenated string

proc ::textutil::adjust::Hyphenation { str } {

    # if there are manual set hyphenation marks e.g. "Recht\-schrei\-bung"
    # use these for hyphenation and return

    if {[regexp {[^\\-]*[\\-][.]*} $str]} {
	regsub -all {(\\)(-)} $str {-} tmp
	return [split $tmp -]
    }

    # Don't hyphenate very short words! Minimum length for hyphenation
    # is set to 3 characters!

    if { [string length $str] < 4 } then { return $str }

    # otherwise follow Knuth's algorithm

    variable HyphPatterns;                       # hyphenation patterns (TeX)

    set w ".[string tolower $str].";             # transform to lower case
    set wLen [string length $w];                 # and add delimiters

    # Initialize hyphenation weights

    set s {}
    for {set i 0} {$i < $wLen} {incr i} {
	lappend s 0
    }

    for {set i 0} {$i < $wLen} {incr i} {
	set kmax [expr {$wLen-$i}]
	for {set k 1} {$k < $kmax} {incr k} {
	    set sw [string range $w $i [expr {$i+$k}]]
	    if {[info exists HyphPatterns($sw)]} {
		set hw $HyphPatterns($sw)
		set hwLen [string length $hw]
		for {set l1 0; set l2 0} {$l1 < $hwLen} {incr l1} {
		    set c [string index $hw $l1]
		    if {[string is digit $c]} {
			set sPos [expr {$i+$l2}]
			if {$c > [lindex $s $sPos]} {
			    set s [lreplace $s $sPos $sPos $c]
			}
		    } else {
			incr l2
		    }
		}
	    }
	}
    }

    # Replace all even hyphenation weigths by zero

    for {set i 0} {$i < [llength $s]} {incr i} {
	set c [lindex $s $i]
	if {!($c%2)} { set s [lreplace $s $i $i 0] }
    }

    # Don't start with a hyphen! Take also care of words enclosed in quotes
    # or that someone has forgotten to put a blank between a punctuation
    # character and the following word etc.

    for {set i 1} {$i < ($wLen-1)} {incr i} {
	set c [string range $w $i end]
	if {[regexp {^[:alpha:][.]*} $c]} {
	    for {set k 1} {$k < ($i+1)} {incr k} {
		set s [lreplace $s $k $k 0]
	    }
	    break
	}
    }

    # Don't separate the last character of a word with a hyphen

    set max [expr {[llength $s]-2}]
    if {$max} {set s [lreplace $s $max end 0]}

    # return the syllabels of the hyphenated word as a list!

    set ret ""
    set w ".$str."
    for {set i 1} {$i < ($wLen-1)} {incr i} {
	if {[lindex $s $i]} { append ret - }
	append ret [string index $w $i]
    }
    return [split $ret -]
}

# textutil::adjust::listPredefined
#
#      Return the names of the hyphenation files coming with the package.
#
# Parameters:
#      None.
#
# Result:
#       List of filenames (without directory)

proc ::textutil::adjust::listPredefined {} {
    variable here
    return [glob -type f -directory $here -tails *.tex]
}

# textutil::adjust::getPredefined
#
#      Retrieve the full path for a predefined hyphenation file
#       coming with the package.
#
# Parameters:
#      name     Name of the predefined file.
#
# Results:
#       Full path to the file, or an error if it doesn't
#       exist or is matching the pattern *.tex.

proc ::textutil::adjust::getPredefined {name} {
    variable here

    if {![string match *.tex $name]} {
        return -code error \
                "Illegal hyphenation file \"$name\""
    }
    set path [file join $here $name]
    if {![file exists $path]} {
        return -code error \
                "Unknown hyphenation file \"$path\""
    }
    return $path
}

# textutil::adjust::readPatterns
#
#      Read hyphenation patterns from a file and store them in an array
#
# Parameters:
#      filNam  name of the file containing the patterns

proc ::textutil::adjust::readPatterns { filNam } {

    variable HyphPatterns;                       # hyphenation patterns (TeX)

    # HyphPatterns(_LOADED_) is used as flag for having loaded
    # hyphenation patterns from the respective file (TeX format)

    if {[info exists HyphPatterns(_LOADED_)]} {
	unset HyphPatterns(_LOADED_)
    }

    # the array xlat provides translation from TeX encoded characters
    # to those of the ISO-8859-1 character set

    set xlat(\"s) \337;  # 223 := sharp s    "
    set xlat(\`a) \340;  # 224 := a, grave
    set xlat(\'a) \341;  # 225 := a, acute
    set xlat(\^a) \342;  # 226 := a, circumflex
    set xlat(\"a) \344;  # 228 := a, diaeresis "
    set xlat(\`e) \350;  # 232 := e, grave
    set xlat(\'e) \351;  # 233 := e, acute
    set xlat(\^e) \352;  # 234 := e, circumflex
    set xlat(\`i) \354;  # 236 := i, grave
    set xlat(\'i) \355;  # 237 := i, acute
    set xlat(\^i) \356;  # 238 := i, circumflex
    set xlat(\~n) \361;  # 241 := n, tilde
    set xlat(\`o) \362;  # 242 := o, grave
    set xlat(\'o) \363;  # 243 := o, acute
    set xlat(\^o) \364;  # 244 := o, circumflex
    set xlat(\"o) \366;  # 246 := o, diaeresis "
    set xlat(\`u) \371;  # 249 := u, grave
    set xlat(\'u) \372;  # 250 := u, acute
    set xlat(\^u) \373;  # 251 := u, circumflex
    set xlat(\"u) \374;  # 252 := u, diaeresis "

    set fd [open $filNam RDONLY]
    set status 0

    while {[gets $fd line] >= 0} {

	switch -exact $status {
	    PATTERNS {
		if {[regexp {^\}[.]*} $line]} {
		    # End of patterns encountered: set status
		    # and ignore that line
		    set status 0
		    continue
		} else {
		    # This seems to be pattern definition line; to process it
		    # we have first to do some editing
		    #
		    # 1) eat comments in a pattern definition line
		    # 2) eat braces and coded linefeeds

		    set z [string first "%" $line]
		    if {$z > 0} { set line [string range $line 0 [expr {$z-1}]] }

		    regsub -all {(\\n|\{|\})} $line {} tmp
		    set line $tmp

		    # Now $line should consist only of hyphenation patterns
		    # separated by white space

		    # Translate TeX encoded characters to ISO-8859-1 characters
		    # using the array xlat defined above

		    foreach x [array names xlat] {
			regsub -all {$x} $line $xlat($x) tmp
			set line $tmp
		    }

		    # split the line and create a lookup array for
		    # the repective hyphenation patterns

		    foreach item [split $line] {
			if {[string length $item]} {
			    if {![string match {\\} $item]} {
				# create index for hyphenation patterns

				set var $item
				regsub -all {[0-9]} $var {} idx
				# store hyphenation patterns as elements of an array

				set HyphPatterns($idx) $item
			    }
			}
		    }
		}
	    }
	    EXCEPTIONS {
		if {[regexp {^\}[.]*} $line]} {
		    # End of patterns encountered: set status
		    # and ignore that line
		    set status 0
		    continue
		} else {
		    # to be done in the future
		}
	    }
	    default {
		if {[regexp {^\\endinput[.]*} $line]} {
		    # end of data encountered, stop processing and
		    # ignore all the following text ..
		    break
		} elseif {[regexp {^\\patterns[.]*} $line]} {
		    # begin of patterns encountered: set status
		    # and ignore that line
		    set status PATTERNS
		    continue
		} elseif {[regexp {^\\hyphenation[.]*} $line]} {
		    # some particular cases to be treated separately
		    set status EXCEPTIONS
		    continue
		} else {
		    set status 0
		}
	    }
	}
    }

    close $fd
    set HyphPatterns(_LOADED_) 1

    return
}

#######################################################

# @c The specified <a text>block is indented
# @c by <a prefix>ing each line. The first
# @c <a hang> lines ares skipped.
#
# @a text:   The paragraph to indent.
# @a prefix: The string to use as prefix for each line
# @a prefix: of <a text> with.
# @a skip:   The number of lines at the beginning to leave untouched.
#
# @r Basically <a text>, but indented a certain amount.
#
# @i indent
# @n This procedure is not checked by the testsuite.

proc ::textutil::adjust::indent {text prefix {skip 0}} {
    set text [string trimright $text]

    set res [list]
    foreach line [split $text \n] {
	if {[string compare "" [string trim $line]] == 0} {
	    lappend res {}
	} else {
	    set line [string trimright $line]
	    if {$skip <= 0} {
		lappend res $prefix$line
	    } else {
		lappend res $line
	    }
	}
	if {$skip > 0} {incr skip -1}
    }
    return [join $res \n]
}

# Undent the block of text: Compute LCP (restricted to whitespace!)
# and remove that from each line. Note that this preverses the
# shaping of the paragraph (i.e. hanging indent are _not_ flattened)
# We ignore empty lines !!

proc ::textutil::adjust::undent {text} {

    if {$text == {}} {return {}}

    set lines [split $text \n]
    set ne [list]
    foreach l $lines {
	if {[string length [string trim $l]] == 0} continue
	lappend ne $l
    }
    set lcp [::textutil::string::longestCommonPrefixList $ne]

    if {[string length $lcp] == 0} {return $text}

    regexp "^(\[\t \]*)" $lcp -> lcp

    if {[string length $lcp] == 0} {return $text}

    set len [string length $lcp]

    set res [list]
    foreach l $lines {
	if {[string length [string trim $l]] == 0} {
	    lappend res {}
	} else {
	    lappend res [string range $l $len end]
	}
    }
    return [join $res \n]
}

# ### ### ### ######### ######### #########
## Data structures

namespace eval ::textutil::adjust {
    variable here [file dirname [info script]]

    variable Justify      left
    variable Length       72
    variable FullLine     0
    variable StrictLength 0
    variable Hyphenate    0
    variable HyphPatterns

    namespace export adjust indent undent
}

# ### ### ### ######### ######### #########
## Ready

package provide textutil::adjust 0.7.3
                                                                            tackle.vfs/lib/textutil/textutil.tcl                                                                100644  1751    1751    5027        14145011620 22657   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # textutil.tcl --
#
#	Utilities for manipulating strings, words, single lines,
#	paragraphs, ...
#
# Copyright (c) 2000      by Ajuba Solutions.
# Copyright (c) 2000      by Eric Melski <ericm@ajubasolutions.com>
# Copyright (c) 2002      by Joe English <jenglish@users.sourceforge.net>
# Copyright (c) 2001-2006 by Andreas Kupries <andreas_kupries@users.sourceforge.net>
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: textutil.tcl,v 1.17 2006/09/21 06:46:24 andreas_kupries Exp $

# ### ### ### ######### ######### #########
## Requirements

package require Tcl 8.2

namespace eval ::textutil {}

# ### ### ### ######### ######### #########
## API implementation
## All through sub-packages imported here.

package require textutil::string
package require textutil::repeat
package require textutil::adjust
package require textutil::split
package require textutil::tabify
package require textutil::trim
package require textutil::wcswidth

namespace eval ::textutil {
    # Import the miscellaneous string command for public export

    namespace import -force string::chop string::tail
    namespace import -force string::cap string::uncap string::capEachWord
    namespace import -force string::longestCommonPrefix
    namespace import -force string::longestCommonPrefixList

    # Import the repeat commands for public export

    namespace import -force repeat::strRepeat repeat::blank

    # Import the adjust commands for public export

    namespace import -force adjust::adjust adjust::indent adjust::undent

    # Import the split commands for public export

    namespace import -force split::splitx split::splitn

    # Import the trim commands for public export

    namespace import -force trim::trim trim::trimleft trim::trimright
    namespace import -force trim::trimPrefix trim::trimEmptyHeading

    # Import the tabify commands for public export

    namespace import -force tabify::tabify tabify::untabify
    namespace import -force tabify::tabify2 tabify::untabify2

    # Re-export all the imported commands

    namespace export chop tail cap uncap capEachWord
    namespace export longestCommonPrefix longestCommonPrefixList
    namespace export strRepeat blank
    namespace export adjust indent undent
    namespace export splitx splitn
    namespace export trim trimleft trimright trimPrefix trimEmptyHeading
    namespace export tabify untabify tabify2 untabify2
}


# ### ### ### ######### ######### #########
## Ready

package provide textutil 0.9
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         tackle.vfs/lib/textutil/string.tcl                                                                  100644  1751    1751    7751        14145011620 22311   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # string.tcl --
#
#	Utilities for manipulating strings, words, single lines,
#	paragraphs, ...
#
# Copyright (c) 2000      by Ajuba Solutions.
# Copyright (c) 2000      by Eric Melski <ericm@ajubasolutions.com>
# Copyright (c) 2002      by Joe English <jenglish@users.sourceforge.net>
# Copyright (c) 2001-2014 by Andreas Kupries <andreas_kupries@users.sourceforge.net>
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# RCS: @(#) $Id: string.tcl,v 1.2 2008/03/22 16:03:11 mic42 Exp $

# ### ### ### ######### ######### #########
## Requirements

package require Tcl 8.2

namespace eval ::textutil::string {}

# ### ### ### ######### ######### #########
## API implementation

# @c Removes the last character from the given <a string>.
#
# @a string: The string to manipulate.
#
# @r The <a string> without its last character.
#
# @i chopping

proc ::textutil::string::chop {string} {
    return [string range $string 0 [expr {[string length $string]-2}]]
}

# @c Removes the first character from the given <a string>.
# @c Convenience procedure.
#
# @a string: string to manipulate.
#
# @r The <a string> without its first character.
#
# @i tail

proc ::textutil::string::tail {string} {
    return [string range $string 1 end]
}

# @c Capitalizes first character of the given <a string>.
# @c Complementary procedure to <p ::textutil::uncap>.
#
# @a string: string to manipulate.
#
# @r The <a string> with its first character capitalized.
#
# @i capitalize

proc ::textutil::string::cap {string} {
    return [string toupper [string index $string 0]][string range $string 1 end]
}

# @c unCapitalizes first character of the given <a string>.
# @c Complementary procedure to <p ::textutil::cap>.
#
# @a string: string to manipulate.
#
# @r The <a string> with its first character uncapitalized.
#
# @i uncapitalize

proc ::textutil::string::uncap {string} {
    return [string tolower [string index $string 0]][string range $string 1 end]
}

# @c Capitalizes first character of each word of the given <a sentence>.
#
# @a sentence: string to manipulate.
#
# @r The <a sentence> with the first character of each word capitalized.
#
# @i capitalize

proc ::textutil::string::capEachWord {sentence} {
    regsub -all {\S+} [string map {\\ \\\\ \$ \\$} $sentence] {[string toupper [string index & 0]][string range & 1 end]} cmd
    return [subst -nobackslashes -novariables $cmd]
}

# Compute the longest string which is common to all strings given to
# the command, and at the beginning of said strings, i.e. a prefix. If
# only one argument is specified it is treated as a list of the
# strings to look at. If more than one argument is specified these
# arguments are the strings to be looked at. If only one string is
# given, in either form, the string is returned, as it is its own
# longest common prefix.

proc ::textutil::string::longestCommonPrefix {args} {
    return [longestCommonPrefixList $args]
}

proc ::textutil::string::longestCommonPrefixList {list} {
    if {[llength $list] <= 1} {
	return [lindex $list 0]
    }

    set list [lsort $list]
    set min [lindex $list 0]
    set max [lindex $list end]

    # Min and max are the two strings which are most different. If
    # they have a common prefix, it will also be the common prefix for
    # all of them.

    # Fast bailouts for common cases.

    set n [string length $min]
    if {$n == 0} {return ""}
    if {0 == [string compare $min $max]} {return $min}

    set prefix ""
    set i 0
    while {[string index $min $i] == [string index $max $i]} {
	append prefix [string index $min $i]
	if {[incr i] > $n} {break}
    }
    set prefix
}

# ### ### ### ######### ######### #########
## Data structures

namespace eval ::textutil::string {
    # Export the imported commands

    namespace export chop tail cap uncap capEachWord
    namespace export longestCommonPrefix
    namespace export longestCommonPrefixList
}

# ### ### ### ######### ######### #########
## Ready

package provide textutil::string 0.8
                       tackle.vfs/lib/textutil/split.tcl                                                                   100644  1751    1751    12767       14145011620 22161   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # split.tcl --
#
#	Various ways of splitting a string.
#
# Copyright (c) 2000      by Ajuba Solutions.
# Copyright (c) 2000      by Eric Melski <ericm@ajubasolutions.com>
# Copyright (c) 2001      by Reinhard Max <max@suse.de>
# Copyright (c) 2003      by Pat Thoyts <patthoyts@users.sourceforge.net>
# Copyright (c) 2001-2006 by Andreas Kupries <andreas_kupries@users.sourceforge.net>
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# RCS: @(#) $Id: split.tcl,v 1.7 2006/04/21 04:42:28 andreas_kupries Exp $

# ### ### ### ######### ######### #########
## Requirements

package require Tcl 8.2

namespace eval ::textutil::split {}

########################################################################
# This one was written by Bob Techentin (RWT in Tcl'ers Wiki):
# http://www.techentin.net
# mailto:techentin.robert@mayo.edu
#
# Later, he send me an email stated that I can use it anywhere, because
# no copyright was added, so the code is defacto in the public domain.
#
# You can found it in the Tcl'ers Wiki here:
# http://mini.net/cgi-bin/wikit/460.html
#
# Bob wrote:
# If you need to split string into list using some more complicated rule
# than builtin split command allows, use following function. It mimics
# Perl split operator which allows regexp as element separator, but,
# like builtin split, it expects string to split as first arg and regexp
# as second (optional) By default, it splits by any amount of whitespace. 
# Note that if you add parenthesis into regexp, parenthesed part of separator
# would be added into list as additional element. Just like in Perl. -- cary 
#
# Speed improvement by Reinhard Max:
# Instead of repeatedly copying around the not yet matched part of the
# string, I use [regexp]'s -start option to restrict the match to that
# part. This reduces the complexity from something like O(n^1.5) to
# O(n). My test case for that was:
# 
# foreach i {1 10 100 1000 10000} {
#     set s [string repeat x $i]
#     puts [time {splitx $s .}]
# }
#

if {[package vsatisfies [package provide Tcl] 8.3]} {

    proc ::textutil::split::splitx {str {regexp {[\t \r\n]+}}} {
        # Bugfix 476988
        if {[string length $str] == 0} {
            return {}
        }
        if {[string length $regexp] == 0} {
            return [::split $str ""]
        }
	if {[regexp $regexp {}]} {
	    return -code error \
		"splitting on regexp \"$regexp\" would cause infinite loop"
	}

        set list  {}
        set start 0
        while {[regexp -start $start -indices -- $regexp $str match submatch]} {
            foreach {subStart subEnd} $submatch break
            foreach {matchStart matchEnd} $match break
            incr matchStart -1
            incr matchEnd
            lappend list [string range $str $start $matchStart]
            if {$subStart >= $start} {
                lappend list [string range $str $subStart $subEnd]
            }
            set start $matchEnd
        }
        lappend list [string range $str $start end]
        return $list
    }

} else {    
    # For tcl <= 8.2 we do not have regexp -start...
    proc ::textutil::split::splitx [list str [list regexp "\[\t \r\n\]+"]] {

        if {[string length $str] == 0} {
            return {}
        }
        if {[string length $regexp] == 0} {
            return [::split $str {}]
        }
	if {[regexp $regexp {}]} {
	    return -code error \
		"splitting on regexp \"$regexp\" would cause infinite loop"
	}

        set list  {}
        while {[regexp -indices -- $regexp $str match submatch]} {
            lappend list [string range $str 0 [expr {[lindex $match 0] -1}]]
            if {[lindex $submatch 0] >= 0} {
                lappend list [string range $str [lindex $submatch 0] \
                                  [lindex $submatch 1]]
            }
            set str [string range $str [expr {[lindex $match 1]+1}] end]
        }
        lappend list $str
        return $list
    }
    
}

#
# splitn --
#
# splitn splits the string $str into chunks of length $len.  These
# chunks are returned as a list.
#
# If $str really contains a ByteArray object (as retrieved from binary
# encoded channels) splitn must honor this by splitting the string
# into chunks of $len bytes.
#
# It is an error to call splitn with a nonpositive $len.
#
# If splitn is called with an empty string, it returns the empty list.
#
# If the length of $str is not an entire multiple of the chunk length,
# the last chunk in the generated list will be shorter than $len.
#
# The implementation presented here was given by Bryan Oakley, as
# part of a ``contest'' I staged on c.l.t in July 2004.  I selected
# this version, as it does not rely on runtime generated code, is
# very fast for chunk size one, not too bad in all the other cases,
# and uses [split] or [string range] which have been around for quite
# some time.
#
# -- Robert Suetterlin (robert@mpe.mpg.de)
#
proc ::textutil::split::splitn {str {len 1}} {

    if {$len <= 0} {
        return -code error "len must be > 0"
    }

    if {$len == 1} {
        return [split $str {}]
    }

    set result [list]
    set max [string length $str]
    set i 0
    set j [expr {$len -1}]
    while {$i < $max} {
        lappend result [string range $str $i $j]
        incr i $len
        incr j $len
    }

    return $result
}

# ### ### ### ######### ######### #########
## Data structures

namespace eval ::textutil::split {
    namespace export splitx splitn
}

# ### ### ### ######### ######### #########
## Ready

package provide textutil::split 0.8
         tackle.vfs/lib/textutil/patch.tcl                                                                   100644  1751    1751    10533       14145011620 22112   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # patch.tcl --
#
#	Application of a diff -ruN patch to a directory tree.
#
# Copyright (c) 2019 Christian Gollwitzer <auriocus@gmx.de>
# with tweaks by Andreas Kupries
# - Factored patch parsing into a helper
# - Replaced `puts` with report callback.

package require Tcl 8.5
package provide textutil::patch 0.1

# # ## ### ##### ######## ############# #####################

namespace eval ::textutil::patch {
    namespace export apply
    namespace ensemble create
}

# # ## ### ##### ######## ############# #####################

proc ::textutil::patch::apply {dir striplevel patch reportcmd} {
    set patchdict [Parse $dir $striplevel $patch]

    # Apply, now that we have parsed the patch.
    dict for {fn hunks} $patchdict {
	Report apply $fn
	if {[catch {open $fn} fd]} {
	    set orig {}
	} else {
	    set orig [split [read $fd] \n]
	}
	close $fd

	set patched $orig

	set fail false
	set already_applied false
	set hunknr 1
	foreach hunk $hunks {
	    dict with hunk {
		set oldend [expr {$oldstart+[llength $oldcode]-1}]
		set newend [expr {$newstart+[llength $newcode]-1}]
		# check if the hunk matches
		set origcode [lrange $orig $oldstart $oldend]
		if {$origcode ne $oldcode} {
		    set fail true
		    # check if the patch is already applied
		    set origcode_applied [lrange $orig $newstart $newend]
		    if {$origcode_applied eq $newcode} {
			set already_applied true
			Report fail-already $fn $hunknr
		    } else {
			Report fail $fn $hunknr $oldcode $origcode
		    }
		    break
		}
		# apply patch
		set patched [list \
				 {*}[lrange $patched 0 $newstart-1] \
				 {*}$newcode \
				 {*}[lrange $orig $oldend+1 end]]
	    }
	    incr hunknr
	}

	if {!$fail} {
	    # success - write the result back
	    set fd [open $fn w]
	    puts -nonewline $fd [join $patched \n]
	    close $fd
	}
    }

    return
}

# # ## ### ##### ######## ############# #####################

proc ::textutil::patch::Report {args} {
    upvar 1 reportcmd reportcmd
    uplevel #0 [list {*}$reportcmd {*}$args]
    ##
    # apply        $fname
    # fail-already $fname $hunkno
    # fail         $fname $hunkno $expected $seen
    ##
}

proc ::textutil::patch::Parse {dir striplevel patch} {
    set patchlines [split $patch \n]
    set inhunk false
    set oldcode {}
    set newcode {}
    set n [llength $patchlines]

    set patchdict {}
    for {set lineidx 0} {$lineidx < $n} {incr lineidx} {
	set line [lindex $patchlines $lineidx]
	if {[string match ---* $line]} {
	    # a diff block starts. Current line should be
	    # --- oldfile date time TZ
	    # Next line should be
	    # +++ newfile date time TZ
	    set in $line
	    incr lineidx
	    set out [lindex $patchlines $lineidx]

	    if {![string match ---* $in] || ![string match +++* $out]} {
		#puts $in
		#puts $out
		return -code error "Patch not in unified diff format, line $lineidx $in $out"
	    }

	    # the quoting is compatible with list
	    lassign $in  -> oldfile
	    lassign $out -> newfile

	    set fntopatch [file join $dir {*}[lrange [file split $oldfile] $striplevel end]]
	    set inhunk false
	    #puts "Found diffline for $fntopatch"
	    continue
	}

	# state machine for parsing the hunks
	set typechar [string index $line 0]
	set codeline [string range $line 1 end]
	switch $typechar {
	    @ {
		if {![regexp {@@\s+\-(\d+),(\d+)\s+\+(\d+),(\d+)\s+@@} $line \
			  -> oldstart oldlen newstart newlen]} {
		    return code -error "Erroneous hunk in line $lindeidx, $line"
		}
		# adjust line numbers for 0-based indexing
		incr oldstart -1
		incr newstart -1
		#puts "New hunk"
		set newcode {}
		set oldcode {}
		set inhunk true
	    }
	    - { # line only in old code
		if {$inhunk} {
		    lappend oldcode $codeline
		}
	    }
	    + { # line only in new code
		if {$inhunk} {
		    lappend newcode $codeline
		}
	    }
	    " " { # common line
		if {$inhunk} {
		    lappend oldcode $codeline
		    lappend newcode $codeline
		}
	    }
	    default {
		# puts "Junk: $codeline";
		continue
	    }
	}
	# test if the hunk is complete
	if {[llength $oldcode]==$oldlen && [llength $newcode]==$newlen} {
	    set hunk [dict create \
			  oldcode $oldcode \
			  newcode $newcode \
			  oldstart $oldstart \
			  newstart $newstart]
	    #puts "hunk complete: $hunk"
	    set inhunk false
	    dict lappend patchdict $fntopatch $hunk
	}
    }

    return $patchdict
}

# # ## ### ##### ######## ############# #####################
return
                                                                                                                                                                     tackle.vfs/lib/textutil/trim.tcl                                                                    100644  1751    1751    5204        14145011620 21745   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # trim.tcl --
#
#	Various ways of trimming a string.
#
# Copyright (c) 2000      by Ajuba Solutions.
# Copyright (c) 2000      by Eric Melski <ericm@ajubasolutions.com>
# Copyright (c) 2001-2006 by Andreas Kupries <andreas_kupries@users.sourceforge.net>
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# RCS: @(#) $Id: trim.tcl,v 1.5 2006/04/21 04:42:28 andreas_kupries Exp $

# ### ### ### ######### ######### #########
## Requirements

package require Tcl 8.2

namespace eval ::textutil::trim {}

# ### ### ### ######### ######### #########
## API implementation

proc ::textutil::trim::trimleft {text {trim "[ \t]+"}} {
    regsub -line -all -- [MakeStr $trim left] $text {} text
    return $text
}

proc ::textutil::trim::trimright {text {trim "[ \t]+"}} {
    regsub -line -all -- [MakeStr $trim right] $text {} text
    return $text
}

proc ::textutil::trim::trim {text {trim "[ \t]+"}} {
    regsub -line -all -- [MakeStr $trim left]  $text {} text
    regsub -line -all -- [MakeStr $trim right] $text {} text
    return $text
}



# @c Strips <a prefix> from <a text>, if found at its start.
#
# @a text: The string to check for <a prefix>.
# @a prefix: The string to remove from <a text>.
#
# @r The <a text>, but without <a prefix>.
#
# @i remove, prefix

proc ::textutil::trim::trimPrefix {text prefix} {
    if {[string first $prefix $text] == 0} {
	return [string range $text [string length $prefix] end]
    } else {
	return $text
    }
}


# @c Removes the Heading Empty Lines of <a text>.
#
# @a text: The text block to manipulate.
#
# @r The <a text>, but without heading empty lines.
#
# @i remove, empty lines

proc ::textutil::trim::trimEmptyHeading {text} {
    regsub -- "^(\[ \t\]*\n)*" $text {} text
    return $text
}

# ### ### ### ######### ######### #########
## Helper commands. Internal

proc ::textutil::trim::MakeStr { string pos }  {
    variable StrU
    variable StrR
    variable StrL

    if { "$string" != "$StrU" } {
        set StrU $string
        set StrR "(${StrU})\$"
        set StrL "^(${StrU})"
    }
    if { "$pos" == "left" } {
        return $StrL
    }
    if { "$pos" == "right" } {
        return $StrR
    }

    return -code error "Panic, illegal position key \"$pos\""
}

# ### ### ### ######### ######### #########
## Data structures

namespace eval ::textutil::trim {	    
    variable StrU "\[ \t\]+"
    variable StrR "(${StrU})\$"
    variable StrL "^(${StrU})"

    namespace export \
	    trim trimright trimleft \
	    trimPrefix trimEmptyHeading
}

# ### ### ### ######### ######### #########
## Ready

package provide textutil::trim 0.7
                                                                                                                                                                                                                                                                                                                                                                                            tackle.vfs/lib/tcltls1.7.20/pkgIndex.tcl                                                            100664  1751    1751    725         14145011620 22621   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        if {[package vsatisfies [package present Tcl] 8.5]} {
	package ifneeded tls 1.7.20 [list apply {{dir} {
		if {{shared} eq "static"} {
			load {} Tls
		} else {
			load [file join $dir tcltls.so] Tls
		}

		set tlsTclInitScript [file join $dir tls.tcl]
		if {[file exists $tlsTclInitScript]} {
			source $tlsTclInitScript
		}
	}} $dir]
} elseif {[package vsatisfies [package present Tcl] 8.4]} {
	package ifneeded tls 1.7.20 [list load [file join $dir tcltls.so] Tls]
}
                                           tackle.vfs/lib/tcltls1.7.20/tcltls.so                                                               100664  1751    1751    156570      14145011620 22306   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        ELF          >    7      @                 @ 8 	 @                                 X'      X'                    0       0       0      Z      Z                                        ;      ;                   p      p      p             	                                                              8      8      8      $       $              Ptd                     d      d             Qtd                                                  Rtd   p      p      p                                  GNU @AY;Mt@w                                                                              S                                          S                                          b                     H                                          {                                          &                                          \                                          _                     [                                                                                      z                                                                                     >                     :                     z                                                                                                                                @                                                                 3                                                                                                           {                     .                                          ,                                            D                                          F   "                                                             u                                          ^                     B                                                                                    ?                                                                                                                              Y                                                               1                     t                                          J                     8                     H                                                                                    U                                                               U                      t                     2                                                                                     (                     	                     +                                                                                     P                                          :                     6                                                                                                                                                   k                                          f                                           n                     "                     `                                                                                    o                                                                                                                                                                        L                                                                                                                                w                                          X                                              pm      \       __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize __stack_chk_fail SSL_get_certificate SSL_get_current_cipher SSL_CIPHER_get_bits SSL_CIPHER_get_name SSL_get_peer_certificate X509_free SSL_get_ex_data SSL_state_string_long SSL_alert_desc_string_long SSL_get_ex_data_X509_STORE_CTX_idx X509_STORE_CTX_get_ex_data X509_STORE_CTX_get_current_cert X509_STORE_CTX_get_error_depth X509_STORE_CTX_get_error X509_verify_cert_error_string strncpy strlen ERR_get_error ERR_reason_error_string SSL_CTX_free TLSv1_2_method SSL_CTX_new SSL_new SSL_get_cipher_list SSL_free TLS_method TLSv1_method TLSv1_1_method SSL_get_ciphers OPENSSL_sk_num OPENSSL_sk_value SSL_CIPHER_description EVP_PKEY_new RSA_generate_key EVP_PKEY_assign EVP_PKEY_free BIO_s_file BIO_new BIO_ctrl PEM_write_bio_PrivateKey BIO_free_all X509_new X509_set_version X509_get_serialNumber ASN1_INTEGER_set X509_getm_notBefore X509_gmtime_adj X509_getm_notAfter X509_set_pubkey X509_get_subject_name X509_NAME_add_entry_by_txt X509_set_subject_name EVP_md5 X509_sign PEM_write_bio_X509 DH_new BN_bin2bn DH_set0_pqg DH_free BN_free __sprintf_chk SSL_ctrl SSL_set_ex_data SSL_set_verify SSL_CTX_set_info_callback BIO_f_ssl SSL_set_accept_state SSL_set_bio SSL_set_connect_state SSL_CTX_set_ex_data SSL_CTX_set_options SSL_CTX_ctrl SSL_CTX_set_cipher_list SSL_CTX_set_default_passwd_cb SSL_CTX_set_default_passwd_cb_userdata BIO_new_file PEM_read_bio_DHparams BIO_free SSL_CTX_use_certificate_file SSL_CTX_use_PrivateKey_file SSL_CTX_check_private_key SSL_CTX_load_verify_locations SSL_load_client_CA_file SSL_CTX_set_client_CA_list SSL_CTX_set_default_verify_paths strcmp X509_get_default_cert_file Tls_Init memcpy calloc OPENSSL_init_ssl OPENSSL_init_crypto BIO_set_init BIO_set_data BIO_clear_flags BIO_get_data BIO_get_shutdown BIO_set_shutdown BIO_test_flags BIO_set_flags BIO_get_init BIO_meth_new BIO_meth_set_write BIO_meth_set_read BIO_meth_set_puts BIO_meth_set_ctrl BIO_meth_set_create BIO_meth_set_destroy SSL_accept SSL_get_error SSL_connect SSL_is_init_finished ERR_clear_error BIO_write BIO_read BIO_ctrl_pending BIO_s_mem X509_NAME_print_ex X509_get_issuer_name i2a_ASN1_INTEGER __strcpy_chk EVP_sha1 X509_digest libssl.so.1.1 libcrypto.so.1.1 libc.so.6 GLIBC_2.14 GLIBC_2.4 GLIBC_2.3.4 GLIBC_2.2.5 OPENSSL_1_1_0 /usr/lib:/usr/lib/x86_64-linux-gnu                                                                                                                                             P           ii        ti	        ui	                    m                    m         p             8      x             `8                                       $                   (                   ,                   0                   4                   8                   <                   @                   D                   H                   L                           @             G      H             M      P             S      X             Y      `             a      h             i                   :                                   "                    +                    /                                                    (                    0                    8                    @                    H                    P                    X         	           `         
           h                    p                    x                                                                                                                                                                                                                                                                                                                                                                                                       !                    #                     $           (         %           0         &           8         '           @         (           H         )           P         *           X         ,           `         -           h         .           p         0           x         1                    2                    3                    4                    5                    6                    7                    8                    9                    :                    ;                    <                    =                    >                    ?                    @                    A                     B                    C                    D                    E                     F           (         G           0         H           8         I           @         J           H         K           P         L           X         M           `         N           h         O           p         P           x         Q                    R                    S                    T                    U                    V                    W                    X                    Y                    Z                    [                    \                    ]                    ^                    _                    `                    a                     b                    c                    d                    e                     f           (         g           0         h           8         i           @         j           H         k           P         l           X         m           `         n           h         o           p         p           x         q                    r                    s                    t                    u                    v                    w                    x                    y                    z                    {                    |                    }                    ~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       HH  HtH     5  %  @ %  h    %  h   %  h   %  h   %  h   %  h   %  h   %  h   p%  h   `%  h	   P%  h
   @%  h   0%  h    %z  h   %r  h    %j  h   %b  h   %Z  h   %R  h   %J  h   %B  h   %:  h   %2  h   %*  h   p%"  h   `%  h   P%  h   @%
  h   0%  h    %  h   %  h    %  h   %  h    %  h!   %  h"   %  h#   %  h$   %  h%   %  h&   %  h'   p%  h(   `%  h)   P%  h*   @%  h+   0%  h,    %z  h-   %r  h.    %j  h/   %b  h0   %Z  h1   %R  h2   %J  h3   %B  h4   %:  h5   %2  h6   %*  h7   p%"  h8   `%  h9   P%  h:   @%
  h;   0%  h<    %  h=   %  h>    %  h?   %  h@   %  hA   %  hB   %  hC   %  hD   %  hE   %  hF   %  hG   p%  hH   `%  hI   P%  hJ   @%  hK   0%  hL    %z  hM   %r  hN    %j  hO   %b  hP   %Z  hQ   %R  hR   %J  hS   %B  hT   %:  hU   %2  hV   %*  hW   p%"  hX   `%  hY   P%  hZ   @%
  h[   0%  h\    %  h]   %  h^    %  h_   %  h`   %  ha   %  hb   %  hc   %  hd   %  he   %  hf   %  hg   p%  hh   `%  hi   P%  hj   @%  hk   0%  hl    %z  hm   %r  hn    %j  ho   %b  hp   %Z  hq   %R  hr   %J  hs   %B  ht   %:  hu   %2  hv   %*  hw   p%"  hx   `%  hy   P%  hz   @%  f        H=  H  H9tH  Ht	        H=i  H5b  H)HH?HHHtH  HtfD      =5   u+UH=r   HtH=~  Yd  ]     w    UH=DW  HSHH  dH%(   HD$1H  HHHh  HD$dH3%(   u	H1[]f.     AWAVAUIATUHSHL%  dH%(   HD$1I$   uAHy
     H=V  H uI$1I}X  H[@ I$HxV  L   HP     H\$dH3%(   6  H[]A\A]A^A_@ 1HyX  HI$HHT$  HH  I$p  II$L   I)=  I9I$t8H@  L  E1HU  HHH5U  1   L L  Hx@I7  HH3  HH  II$H=U  Hp    LHHI$I~@Hp  L  `1HVALHHI~@=H%HHty   H=.U  I$ taHp  H=V    LHHI$I~@L  Hp  HHALHHI$LHh  1D     fD  CIHuI$11  ID  HHUG  LIZAWAVIAUA1ATUSH8T$dH%(   HD$(1Hx(H  L%	  HI$   L+T  LvV  HA  I$LD$H=T  LL$Lp    HH{ HAI$H;H  Lp  H$  H$HH{ HHALL$I$LLp    H{ HHAI$LD$LLp    H{ HHAAuA @  r  I$LL  Lp  pHAH{ HHAI$H{ X  I$HX  I$   HE H{ 8	  E PU    I$H  HD$(dH3%(   /  I$H{ H  H8[]A\A]A^A_LR  A ^LCR  A @  u)L9R  A   uA    LR  H#R  LDL R  ALR  AL	R  AALQ  HQ  LD     I$H   fD  |$HI$Lp    H{ HHA@ HD$(dH3%(   uH8[]A\A]A^A_ff.     AWE1AVAUATUHSH8|$dH%(   HD$(1HHI1LIHH"HA7L$[  H{(Hf  H-  HE    H=P  IHE Hp  HL$  LH{ HL$HHE H;Hp  H  HL$HT$  HT$HLH{ HL$HHE DHp  HL$  HL$H{ LHHE H{ LLp  B  LH{ HAHE |$Lp    H{ LHAMHE HP  LDLp  L  LH{ HAHE H{ X  HE HX  HE K   A$H{ L8	  H{ HE txp  D$    HE A$JA$L   HE Hc  HE H{   D$HL$(dH3%(      H8[]A\A]A^A_    @  Ht$$IHE LX  HHE rT$$fH{ HT$L@  HH{ HE -D  HcH{(IHC8   ED$KAWAVIAUATAUSHH-  Hy0dH%(   HD$1Ly HE H  H   H{ IHE X  HE HX  HE LLAE    8	  uAE PAU HU    H  HE H{   HE L  LIcHH*HHL$dH3%(      H[]A\A]A^A_    HE H{ p  AE PAU HE L   D  HE H  HE H{   fD     H5M  L(	  6L   HE H  HE H{   ff.      AUAHATUHSHHR  dH%(   HD$1D$    HAtAHK     HP     HL$dH3%(   q  H[]A\A]     HyL  1X  H1HAHHtbHp  IHL   I2  I9HtJH@  L  E1H\K  HHH5dK  1   VD     GfD  L  Ht$   HI:3     x!HHh    HH1fAD$uhHMd$`H  H|$(  MtA<$ uHHp  IL11LH5K  HA@     f.     |$u1aff.     fAWAVAUATUSH   H$ H   H$ HHHO  dH%(   H$8   1AD$,    HHI   HHqE1   HT$0LJ  HRH  	  AXZEu]A   Dl$(A   HL  DHcH>H@  ,HH1H1H|$.fD  A   H$8   dH3%(     HH   D[]A\A]A^A_fD  HI  L   HP  A   HIvHT$,H  8HA   H@  {H1HH1`fHHD$H|$ tH|$HH$H11  t$,I  D$(    5f     HLp    LHHAD$(pt$(H<$HHuH<$
H|$HLHh  @ HHD$3H1H5~H  H1A   @  \fD  H1H5VH  H1E@  7f     kHHD$f     KHHD$H<$Ll$0MID$(    HD$9fD  HLLp  LL$  LL$LHHAD$(H|$t$(9H|$    LH=LI &     2H!%t  DHrHD@ HL)ID HIf     P 3I)@ LHHuff.     @ AWAVAUATIUHSH   H.  dH%(   HD$x1H"  HAHqE1HT$dLG     HRH  	  AYAZA  DD$\E  AED$h    LD$lm    It$HT$dHA@  A^  HI|$
  I|$ HD$H
  HD$A  HIt$(HL$pHHT$`x  A  D$`d  l  HE  Dt$LL|$lHD$@HD$8HD$0HD$(HD$ HD$H$HD$hI7    HD$pLHJt(H@     AD;d$`  HT$pIcL,    H<H
     H=2E  H t   HH=E  L .  HD$pLHJt(A@  x    A   HD$xdH3%(   A  H   D[]A\A]A^A_f     HD  L   HP  A   HF  L   HAP  D  HD  HD$@HD$8HD$0HD$(HD$ HD$H$IH^  |$d11     LH   HH1H5D  P  Lf.     Cu(x u"HD$pJ|(A
  H$A     Su(xTu"x uHD$pJ|(A
  HD$
L  x   HD$pJ|(A
  HD$ fHHL$   l   HIHLE1j E111LLQ^_IH     HLc|$hLHLnLf1HLc|$lLMiQ HLmLLLzHAAj HL$  HH5B  IHL$ ALA  H5rB  $    pHL$0ALA  H5mB  $    DHL$8ALA  H5B  $    HL$@ALA  H5A  $    HL$HALA  H5A  $    HL$PALA  H5_A  $    LLYLLHZY  gHHL$   l   HHLHHL*LD  H1H5@  HP  fD  OuMx uGHD$pJ|(A
  HD$(fDt$L?fD  H1H5B  HP  ~OusxUumx ugHD$pJ|(A
  HD$0HH1H5B  P  LM0LPL8H1HH5:@  P  Cu'xNu!x uHD$pJ|(A
  HD$8KH   H=?   u HD$pJ|(A
  HD$@(1H5?  HAP  AUAHATUHSHH  dH%(   HD$1HAt9H>>     HP     H\$dH3%(      H[]A\A]HyL  
  H1HAHHtdHp  IHL   I$  I9HtLH@  L  E1H=  HHH5=  1   `       OfD  LH  /f     AUATUHdH%(   HD$1.IHtJ1   H=(  1   H=  HmIHt=Ht81HHLpt$HD$dH3%(   u1HL]A\A]    LE1H5L-&fD  HHcdH%(   HD$1H  HH  Lt#HD$dH3%(   u3H	  LH HD$dH3%(   uH	  LH HdH%(   HD$1HD$dH3%(   uH  H Hp	  H\ff.     AWAVAUATUSH   H$ H   H$ HH-  LE dH%(   H$   1HH Ht> I`  MX  A@  1HAIH{(HE Lk`Hb     H=<  IHE Lp    LH{ HAHE H;Lp  L    HAH{ LHAHE LLp    LH{ HAHE H{ X  HE HX  HE A$   H{ L8	  tHE H{ p  A$PA$HU ~jH  HE H{   H$   dH3%(      H   []A\A]A^A_f.     H1H5?;  A0       L   HU H;I  MLH;  I       1HE H{ L   P  HE H{ p  GD  SHHHdH%(   HD$1HtHt  H   HC    H{PHtHCP    H{@HtHC@    H{HHtHCH    H{(HtP~THC(    H{0HtP~HC0    HD$dH3%(   u1H[H  H    fD  H  H    UHHdH%(   HD$1HD$dH3%(   uHh  HH H@0H]fAWAVAUIATIUSH(  H-.  dH%(   H$  1D$x    D$|    HE $       $      $      $      $      $       $        HyL  1X  L1HAHHU  HE p  LU HD$X    HD$8HD$P    HD$(    HD$    HD$    HD$     HD$@    HD$0      HD$H    A   L5^8  HD$    Ic1I<AX  8-I^  H   LLU  udAD9  E1H8  LH7  H58  A@     H$  dH3%(   7  H(  []A\A]A^A_       LH=7   u>AD9  E1H7  LH7  H57  A@          
   LH=7     AD9  E1H57  LHR7  H5,7  A@     !f     Ic1I<AX  LU HD$AD9D$   Et$   EAA\$|D$   E1AEtAD$   EtAD$   EtAD$   EtA$   tA H\$Ht;     HEHD$H\$0Ht;     HEHD$0HT$ Ht:     HEHD$ H\$Ht;     HEHD$HT$Ht:     HEHD$H\$(Ht;     HEHD$(h   AR(HxHH     IH1H)hHH4  Ml$ AD$   H\$@Et$8ID$`Ht"HE Ht$tHX  t$ttI\$(H\$HHt"HE Ht$tHX  L$ttI\$0Ht$PH  HE LH$     HHt_HE p  HD$8IHE L   Hs  H9HE 6  LH@    E1H 3  LHH5(3  1L    fD  HZ4  L   LP     ffD     LH=t4   u^AD9  E1H!4  LHH4  H54  A@     D  Ic1I<AX  LU HD$fH4  	   LH tsH3  
   LH    AD9   Ic1I<AX  LU HD$(    Ic1I<AX  LU HD$[fAD9~7IcIHD$@?fD  Ic1I<AX  LU HD$ fE1H 3  H53  LA@      LU     H3  	   LH .  AD9~Ic1I<AX  LU HD$0H|$8L$`  H$@    H@HHD$@HD$@L$   LLD$ID$HHE   HE L$  LLL$  HE H  HE L  HHE LH\$8H2  H  HE LHH2  LI  HE HLLD$H2  L  HE HLLL$H2  L  HE HLH2  Hq2    HE HLHx2  H`2    HE H    M   LHLI$HHHE H$   H2  L  HE LH$`  I4$H1    HE LH$@  I4$H1    HE LH$  I4$H1    I|$HuID$@HH  HD$XHt(1H7   Hu$     I|$@L18I|$@HDI|$HH51LI  ID$XOH'ID$PD$x   AL$I|$@It$XI|$@HIL$@I|$P1m   HE I<$HP       LH1D  HD$H    HD$       H=/  L   AD9c  E1HN/  LH/  H5E/  A@     :I|$@-ID$ HD$HE  A)  D  AY    A  A  1HyHD$@H E1H\$@HT$H1LD$PHoT HLD$PHL1   H*   HD$ HtHHiH\$@H5HHLjH\$(H  HE L$`  L  HE LHH|$H  H5e\  HHH  111HD$ gH|$ H
HE L  H  H|$@H1   HXH\$H  HE L  HE LHH|$H  H|$@   HV  HT$0HD$H|$HHHELHHD$0HE   H|$@   HqLHE     H|$@2  HE LH$@    HE H  Ht$HtHE H|$HH  HD$Ht$H$  HE H|$HL  HT$H|$@H   HE Ht$LH|$H  HHHt
H|$@HE L  HE H  A   HHD$@H]L|$@1  {   L1  L|   Lc
   H=,  L uVAD98  E1H+  LH+  H5+  A@     xHM 1H5#/  L1@  H+  	   LH    AD9H$   IcLI4A  tLU Ic1I<AX  LU HD$PHM H|$H11H5)  @  #HE H@  HV1H55.  LH1L   HM H1H52+  1@  IcIHD$H\H*  	   LH    AD9H$   sH=DHD%      	D%   	D %    	gHD$@HAA HL$`  HHT$H|$@1 H|$@H|$@LH5)  LT$hLD$`5LD$`LT$h`  AD9L  HT$xH|$@   HHE L  HM 1H5+  H|$H1@  H|$@HE L  HE H@  H0H|$HE1HT$IHt'  H5+  1H|$@HM H|$H1H5+  @  H|$@m  Lt$H11HE LP  HE H@  HLHT$0E1IH&  H5+  1H|$@
*HM 1H5*  LH5#(  LT$hLD$`LD$`LT$hu5AD9jE1Hs'  LH'  H5j'  A@     _LH5'  LT$hLD$`NLD$`LT$hu5AD9   HT$|Ic1I<AX  LU HD$XLH5}'  LT$hLD$`LD$`LT$h   AD9~eH$   E1H&  LH'  H5&  A@     E1H~&  LH '  H5u&  A@     jE1HR&  LH&  H5I&  A@     >LH5&  LT$hLD$`-LD$`LT$huAD9~JH$   LH5&  LT$hLD$`LD$`LT$hunAD9~9H$   E1H%  LH:&  H5%  A@     E1H%  LH&  H5w%  A@     lLH5%  LT$hLD$`[LD$`LT$huAD9~JH$   
LH5%  LT$hLD$`LD$`LT$hunAD9~9H$   E1H$  LHv%  H5$  A@     E1H$  LHR%  H5$  A@     H&  j LL/%  PH#  1Hi$  H5#%  A@  A]   A^ZfAUATUSH   H$ H   H$ H	  )  H5+(  A   dH%(   H$)  1IHL1H5$  HS  HtzHwx  w  H   H=w  	        w     11Hw  0tSHH=qw  	  H1HH5T'  1@  H$)  dH3%(   T  H)  D[]A\A]@ 1   1   117  HH=v  	  HE11HHH5$    HE11H	H5#  H  HE11H
H5#  H  HE11HH5#  H  HE11HH5#  H  HE11HMH5#  H  HE11HH5#  H  HtHLH  H1H}#  HH5z#  PA@ HdH%(   HD$1HD$dH3%(   u	Hof.     U1HHdH%(   HD$11HSHHD$dH3%(   uH   ]VfD  ATIUHSHdH%(   HD$11H  XHH~w7HN  HcH>   HL$dH3%(      H[]A\1HD  1   t~1   HD fh1HH(u  1H5  H h  HH?HxH u  H    HaHHRDH   =1H2Ht  H   HD  AVAAUATIUHSHdH%(   HD$11H  M   HXt  ILDLH`  LAH   AH  	   HAEtKEFHh   E1(     Hu<HD$dH3%(   uSHD[]A\A]A^@ Et+AuAtD  
   HE1 	   H@ AVAAUATIUHSHdH%(   HD$11H  HAs  LDIHLh  LAH   AH  
   HAEtLEGHh   E1(     Hu=HD$dH3%(   uTHD[]A\A]A^D  Et+AuAtD  	   Hf     	   Hff.     ATIHUHHdH%(   HD$1wHL$dH3%(   uHHL]A\nff.      ATE1UHdH%(   HD$1HtHA   uHD$dH3%(   u,HD]A\H1HNH!f.     AUAATUHHdH%(   HD$1H=p   tcH   H=p  HIH`DLe   LHD$dH3%(      HL]A\A]    H5I    H5XHH.p  H="p  H5VH=p  H5HH=o  H5H=o  H52MH=o  H5oHE1@ HdH%(   HD$1GDGHD$dH3%(   u1Hh     U11   SH   HdH%(   HD$1HG    HPDH{P
   D11-IEEHD$dH3%(   uHo  H;H H   H[]ff.     UHHdH%(   HD$1H8o  H5HH 0  HD$dH3%(   uH1]h     HLYn  dH%(   HD$1MtHD$dH3%(      LHHn     H P(Hx0IHn  HH@(    H       )   1HHH  I@   I H I@H5  I@HZ  I@ H  I@8Hd  I@@H  I@HHI@XHs  I@h.eD  AVIAUATUSHdH%(   HD$1GAAm  H tB  DH}@AAD$vAD$   E4  H}@u~H}P11   H}@IoAE~H}@tA   A	     AtyA   AHD$dH3%(   G  HD[]A\A]A^f     H}P   ;AuHl  H   A   H      Ah   M AfEu0ef.     A    G@ A   A1H7l  AH   AH#HHM Ag   utHk  H   AhQAg   Euh   Aff.     fATAUHSHHdH%(   HD$1HtHnk  H   HE    ]1t#HL$dH3%(   u?H[]A\f.     Ht$   HD$    y	|$DDD_ff.     @ AVAUATUSHHdH%(   HD$1    DgA   IAH   H   EuFH}P11   9      HD$dH3%(   0  HD[]A\A]A^fKH}PDL\H}@AN   HVC  HcH>f;htA    Ay    cHEuTAuztvHi  AH   3f     H}@DAHcHHg   EA    EIfD  EA   Aff.     fAVAUATE1USHdH%(   HD$1    Gt)HD$dH3%(   "  HD[]A\A]A^D  IAH1HH   H}PLDVH}@A   =t   H}@DA~HcfHH[g   OuJHEuu6AuYtUHh  H   fD  ;hA     E1    A    AfD  H#wdH%(   HD$1@u.HD$dH3%(   u5Hwg  H?H H  H@ HD$dH3%(   u1H@ ATIU@   SHdH%(   HD$1Hg  H H  THHD$dH3%(   uHLH[]A\:f.     AVAUATUSHdH%(   HD$1Gt*HD$dH3%(     H[]A\A]A^f     A@   HHC    L-\f  HDcIE    HLp@IE   DHAH{HtIE   HC    AbIE H;  ~kIE H   H5   HC/f     L%e  HI$   HLh@I$  1HAC        H{P'Hu     AWAVAUIATIUH@   SHdH%(   HD$1L54e  IILH     HHtDHIL  HHD$dH3%(   uIHLLHH[]A\A]A^A_fD  1MHT$dH3%(   uH[]A\A]A^A_@ USHdH%(   HD$1H=  	&  HHN
 0<	*  HH9uFPF  FLFHHv=     FDFE@FDFF@FDF	F@F
E1X	w^k@	   HcHcH=+c  |ZH5  H<  HEHl     PHZ  R   APLH<  1ASARH0Hb  H\$dH3%(   u%H[]D  H<  DCgzf.     AWAVAUATUSL$  H   H$ L9uH   Hb  dH%(   H$  1HHI11  D$x $   IpHH  LIA  .1LHL11
   LL=  H$   AOHHD$        LH11H    L1LH11
   LhL=  H$   AOHHD$       LH11H     LLH=11
   LDLL$  =  NH$@  HHD$       LH11H@   LLL|$ts1Ld$(A@ LL~:AHI11
   L`H?  D)9O    =    NuA 11   LLd$(%L=LL$`  L$  Hp8    LHL"Hp8    LHHT$01LHHT$(;HT$(HL$QLD$DH=9  D  HH@@47A@qI9uHH=i9  Lp    LHHAHH|$P(   Lp    LHHAHH=%9  Lp    LHHAHH|$ Lp    LHHAHH=8  Lp    LHHAHH|$Lp    LHHAHH=8  Lp    LHHAHLLp    LHHAHH=V8  Lp    LHHAHLLp    LHHAHH=	  Lp    LHHAHH|$Lp    LHHAHH=	  Lp    LHHAHH|$Hp    LHHH$  dH3%(   umH  L[]A\A]A^A_    H$   $    HD$ H$   HD$H$@  HD$H$  $    $@   HD$f01	@ AUATUHSHH_dH%(   HD$1H$    H   ;   IA1HIH56  SHS  Et_A<$@t4L@1f     0H	u   E1   LHH56  SH   H$Hb\  HRHtiH
HW\  HJHRHP\  HQ\  H|$dH3<%(      H[]A\A]f.     H5  HE    HE 1f     H[      H[      H[      D  @:8u-   @ H@8uA4u0	)E1   LHH55  S1>  HH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   OpenSSL 1.1.1c  28 May 2019 -local ?-local? channel ": not a TLS channel bad channel " sbits (NONE) accept alert connect unknown read write loop exit start done info verify tls::password handshake failed:  protocol ?verbose? protocol protocol not supported subcommand ?args? days serial Email Unknown parameter Error generating private key C ST O OU CN Error signing certificate SSL SSL channel "%s": error: %s error channel ?options? -cadir  option no argument given for  -cafile -certfile -cipher -command -dhparams -keyfile -model -password -require -request -server -servername -ssl2 -ssl3 -tls1 -tls1.1 -tls1.2 -tls1.3 ": must be  bad  no valid protocol selected -eofchar -encoding -translation -blocking binary true 8.4 tls::ciphers tls::handshake tls::import tls::unimport tls::status tls::version tls::misc 1.7.20 tls req    Hp@keysize keyfile certfile ?info? Information list must have even number of arguments     Error generating certificate request    -cadir, -cafile, -certfile, -cipher, -command, -dhparams, -keyfile, -model, -password, -require, -request, -server, -servername, -ssl2, -ssl3, -tls1, -tls1.1, -tls1.2, or tls1.3       Could not find DH parameters file       Could not read DH parameters from file  unable to set certificate file  unable to set public key file   private key does not match the certificate public key   couldn't construct ssl session:         setting TLS host name extension failed  could not initialize SSL library        #
# Copyright (C) 1997-2000 Matt Newman <matt@novadigm.com> 
#
namespace eval tls {
    variable logcmd tclLog
    variable debug 0
 
    # Default flags passed to tls::import
    variable defaults {}

    # Maps UID to Server Socket
    variable srvmap
    variable srvuid 0

    # Over-ride this if you are using a different socket command
    variable socketCmd
    if {![info exists socketCmd]} {
        set socketCmd [info command ::socket]
    }

    # This is the possible arguments to tls::socket and tls::init
    # The format of this is a list of lists
    ## Each inner list contains the following elements
    ### Server (matched against "string match" for 0/1)
    ### Option name
    ### Variable to add the option to:
    #### sopts: [socket] option
    #### iopts: [tls::import] option
    ### How many arguments the following the option to consume
    variable socketOptionRules {
        {0 -async sopts 0}
        {* -myaddr sopts 1}
        {0 -myport sopts 1}
        {* -type sopts 1}
        {* -cadir iopts 1}
        {* -cafile iopts 1}
        {* -certfile iopts 1}
        {* -cipher iopts 1}
        {* -command iopts 1}
        {* -dhparams iopts 1}
        {* -keyfile iopts 1}
        {* -password iopts 1}
        {* -request iopts 1}
        {* -require iopts 1}
        {* -autoservername discardOpts 1}
        {* -servername iopts 1}
        {* -ssl2 iopts 1}
        {* -ssl3 iopts 1}
        {* -tls1 iopts 1}
        {* -tls1.1 iopts 1}
        {* -tls1.2 iopts 1}
        {* -tls1.3 iopts 1}
    }

    # tls::socket and tls::init options as a humane readable string
    variable socketOptionsNoServer
    variable socketOptionsServer

    # Internal [switch] body to validate options
    variable socketOptionsSwitchBody
}

proc tls::_initsocketoptions {} {
    variable socketOptionRules
    variable socketOptionsNoServer
    variable socketOptionsServer
    variable socketOptionsSwitchBody

    # Do not re-run if we have already been initialized
    if {[info exists socketOptionsSwitchBody]} {
        return
    }

    # Create several structures from our list of options
    ## 1. options: a text representation of the valid options for the current
    ##             server type
    ## 2. argSwitchBody: Switch body for processing arguments
    set options(0) [list]
    set options(1) [list]
    set argSwitchBody [list]
    foreach optionRule $socketOptionRules {
        set ruleServer [lindex $optionRule 0]
        set ruleOption [lindex $optionRule 1]
        set ruleVarToUpdate [lindex $optionRule 2]
        set ruleVarArgsToConsume [lindex $optionRule 3]

        foreach server [list 0 1] {
            if {![string match $ruleServer $server]} {
                continue
            }

            lappend options($server) $ruleOption
        }

        switch -- $ruleVarArgsToConsume {
            0 {
                set argToExecute {
                    lappend @VAR@ $arg
                    set argsArray($arg) true
                } 
            }
            1 {
                set argToExecute {
                    incr idx
                    if {$idx >= [llength $args]} {
                        return -code error "\"$arg\" option must be followed by value"
                    }
                    set argValue [lindex $args $idx]
                    lappend @VAR@ $arg $argValue
                    set argsArray($arg) $argValue
                }
            }
            default {
                return -code error "Internal argument construction error"
            }
        }

        lappend argSwitchBody $ruleServer,$ruleOption [string map [list @VAR@ $ruleVarToUpdate] $argToExecute]
    }

    # Add in the final options
    lappend argSwitchBody {*,-*} {return -code error "bad option \"$arg\": must be one of $options"}
    lappend argSwitchBody default break

    # Set the final variables
    set socketOptionsNoServer   [join $options(0) {, }]
    set socketOptionsServer     [join $options(1) {, }]
    set socketOptionsSwitchBody $argSwitchBody
}

proc tls::initlib {dir dll} {
    # Package index cd's into the package directory for loading.
    # Irrelevant to unixoids, but for Windows this enables the OS to find
    # the dependent DLL's in the CWD, where they may be.
    set cwd [pwd]
    catch {cd $dir}
    if {[string equal $::tcl_platform(platform) "windows"] &&
	![string equal [lindex [file system $dir] 0] "native"]} {
	# If it is a wrapped executable running on windows, the openssl
	# dlls must be copied out of the virtual filesystem to the disk
	# where Windows will find them when resolving the dependency in
	# the tls dll. We choose to make them siblings of the executable.
	package require starkit
	set dst [file nativename [file dirname $starkit::topdir]]
	foreach sdll [glob -nocomplain -directory $dir -tails *eay32.dll] {
	    catch {file delete -force            $dst/$sdll}
	    catch {file copy   -force $dir/$sdll $dst/$sdll}
	}
    }
    set res [catch {uplevel #0 [list load [file join [pwd] $dll]]} err]
    catch {cd $cwd}
    if {$res} {
	namespace eval [namespace parent] {namespace delete tls}
	return -code $res $err
    }
    rename tls::initlib {}
}


#
# Backwards compatibility, also used to set the default
# context options
#
proc tls::init {args} {
    variable defaults
    variable socketOptionsNoServer
    variable socketOptionsServer
    variable socketOptionsSwitchBody

    tls::_initsocketoptions

    # Technically a third option should be used here: Options that are valid
    # only a both servers and non-servers
    set server -1
    set options $socketOptionsServer

    # Validate arguments passed
    set initialArgs $args
    set argc [llength $args]

    array set argsArray [list]
    for {set idx 0} {$idx < $argc} {incr idx} {
	set arg [lindex $args $idx]
	switch -glob -- $server,$arg $socketOptionsSwitchBody
    }

    set defaults $initialArgs
}
#
# Helper function - behaves exactly as the native socket command.
#
proc tls::socket {args} {
    variable socketCmd
    variable defaults
    variable socketOptionsNoServer
    variable socketOptionsServer
    variable socketOptionsSwitchBody

    tls::_initsocketoptions

    set idx [lsearch $args -server]
    if {$idx != -1} {
	set server 1
	set callback [lindex $args [expr {$idx+1}]]
	set args [lreplace $args $idx [expr {$idx+1}]]

	set usage "wrong # args: should be \"tls::socket -server command ?options? port\""
        set options $socketOptionsServer
    } else {
	set server 0

	set usage "wrong # args: should be \"tls::socket ?options? host port\""
        set options $socketOptionsNoServer
    }

    # Combine defaults with current options
    set args [concat $defaults $args]

    set argc [llength $args]
    set sopts {}
    set iopts [list -server $server]

    array set argsArray [list]
    for {set idx 0} {$idx < $argc} {incr idx} {
	set arg [lindex $args $idx]
	switch -glob -- $server,$arg $socketOptionsSwitchBody
    }

    if {$server} {
	if {($idx + 1) != $argc} {
	    return -code error $usage
	}
	set uid [incr ::tls::srvuid]

	set port [lindex $args [expr {$argc-1}]]
	lappend sopts $port
	#set sopts [linsert $sopts 0 -server $callback]
	set sopts [linsert $sopts 0 -server [list tls::_accept $iopts $callback]]
	#set sopts [linsert $sopts 0 -server [list tls::_accept $uid $callback]]
    } else {
	if {($idx + 2) != $argc} {
	    return -code error $usage
	}

	set host [lindex $args [expr {$argc-2}]]
	set port [lindex $args [expr {$argc-1}]]

        # If an "-autoservername" option is found, honor it
        if {[info exists argsArray(-autoservername)] && $argsArray(-autoservername)} {
            if {![info exists argsArray(-servername)]} {
                set argsArray(-servername) $host
                lappend iopts -servername $host
            }
        }

	lappend sopts $host $port
    }
    #
    # Create TCP/IP socket
    #
    set chan [eval $socketCmd $sopts]
    if {!$server && [catch {
	#
	# Push SSL layer onto socket
	#
	eval [list tls::import] $chan $iopts
    } err]} {
	set info ${::errorInfo}
	catch {close $chan}
	return -code error -errorinfo $info $err
    }
    return $chan
}

# tls::_accept --
#
#   This is the actual accept that TLS sockets use, which then calls
#   the callback registered by tls::socket.
#
# Arguments:
#   iopts	tls::import opts
#   callback	server callback to invoke
#   chan	socket channel to accept/deny
#   ipaddr	calling IP address
#   port	calling port
#
# Results:
#   Returns an error if the callback throws one.
#
proc tls::_accept { iopts callback chan ipaddr port } {
    log 2 [list tls::_accept $iopts $callback $chan $ipaddr $port]

    set chan [eval [list tls::import $chan] $iopts]

    lappend callback $chan $ipaddr $port
    if {[catch {
	uplevel #0 $callback
    } err]} {
	log 1 "tls::_accept error: ${::errorInfo}"
	close $chan
	error $err $::errorInfo $::errorCode
    } else {
	log 2 "tls::_accept - called \"$callback\" succeeded"
    }
}
#
# Sample callback for hooking: -
#
# error
# verify
# info
#
proc tls::callback {option args} {
    variable debug

    #log 2 [concat $option $args]

    switch -- $option {
	"error"	{
	    foreach {chan msg} $args break

	    log 0 "TLS/$chan: error: $msg"
	}
	"verify"	{
	    # poor man's lassign
	    foreach {chan depth cert rc err} $args break

	    array set c $cert

	    if {$rc != "1"} {
		log 1 "TLS/$chan: verify/$depth: Bad Cert: $err (rc = $rc)"
	    } else {
		log 2 "TLS/$chan: verify/$depth: $c(subject)"
	    }
	    if {$debug > 0} {
		return 1;	# FORCE OK
	    } else {
		return $rc
	    }
	}
	"info"	{
	    # poor man's lassign
	    foreach {chan major minor state msg} $args break

	    if {$msg != ""} {
		append state ": $msg"
	    }
	    # For tracing
	    upvar #0 tls::$chan cb
	    set cb($major) $minor

	    log 2 "TLS/$chan: $major/$minor: $state"
	}
	default	{
	    return -code error "bad option \"$option\":\
		    must be one of error, info, or verify"
	}
    }
}

proc tls::xhandshake {chan} {
    upvar #0 tls::$chan cb

    if {[info exists cb(handshake)] && \
	$cb(handshake) == "done"} {
	return 1
    }
    while {1} {
	vwait tls::${chan}(handshake)
	if {![info exists cb(handshake)]} {
	    return 0
	}
	if {$cb(handshake) == "done"} {
	    return 1
	}
    }
}

proc tls::password {} {
    log 0 "TLS/Password: did you forget to set your passwd!"
    # Return the worlds best kept secret password.
    return "secret"
}

proc tls::log {level msg} {
    variable debug
    variable logcmd

    if {$level > $debug || $logcmd == ""} {
	return
    }
    set cmd $logcmd
    lappend cmd $msg
    uplevel #0 $cmd
}

 tcl l4lX(ppL GMT Bad time value %s %2d %02d:%02d:%02d %d%s 0123456789ABCDEF sha1_hash subject issuer notBefore notAfter Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec interpreter uses an incompatible stubs mechanism Tcl    ;d  +   o  Xw  (x  x  {8  ~    h8  Xt    (\  X        8d  8      HP  p    8  X  xP  |  X      x(  L  h  8    $	  (h	  	  	  h
  8h
  
                 zR x  $      n   FJw ?;*3$"       D   u           (   \   `vf    EPD0C
CAA H      v   FBB E(A0D8FP
8A0A(B BBBE d      Hy   FBE G(A0A8Dp
8A0A(B BBBC
8A0A(B BBBA  H   <   |    FEB B(A0D8DpF
8A0A(B BBBHH     ~   FBE B(D0A8DP
8A0A(B BBBH 8     (   FHA D(D@Z
(A ABBI `     !   FBB B(A0A8G L@IA~A\AQAAA
8D0A(B BBBG   t     FBB B(D0D8Gg_OB
8D0A(B BBBJH]AyNCA  8     '   FHA D(D@R
(A ABBA 0   4      FBA D0{
 DBBH     h  D}    H K
E^
B        D    H u
B  T     K   FBB B(A0A8G L@I@
8A0A(B BBBK              EG 
AB     $  N    EG z
AB  \   H  ^   FBB E(D0A8G
8A0A(B BBBH?K`G @     \   FBA A(G L@LS
(D ABBE     6    H d
E            Z    EI @
FA 0   0  LK   FDD F0e
 AABA @   d  h   FEB D(D0D@
0D(A BBBE @     D   FEB D(D0D@
0D(A BBBF (      R    FGG0i
IBE  (     Tv    FDD0{
DBA  4   D  -   FEA G0m
 DBBH        |  H    H z
A  (         EJL0p
AAB       HX    EG C
CA          H w
A  @     hS   FEB A(A0D@
0D(A BBBJ 0   H      FDD D0O
 AABK @   |      FBB A(A0G@
0D(A BBBC @     j   FBB D(A0D@t
0D(A BBBF        l    H B
FV
A   0   (  f    FDH D0}
 IABB  @   \  @X   FBB A(A0D@n
0A(A BBBJ  `     \    FBB E(D0I8DPb
8M0A(B BBBH\
8A0A(B BBBA @   	     AAD0
8L@HHGPOXB`I0[
AAF   X   H	     FBB B(A0A8HQG5
8D0A(B BBBH        	         8   	     BBA D(D@
(A ABBK                                                                                                                                                                                                                                                                                                                                                                                                                8      `8             $      (      ,      0      4      8      <      @      D      H      L                                                     0                          p                           x                    o    `                                
       .	                                                                                 `             p      	              o          o           o          o                                                                                                                                                                                 60      F0      V0      f0      v0      0      0      0      0      0      0      0      0      1      1      &1      61      F1      V1      f1      v1      1      1      1      1      1      1      1      1      2      2      &2      62      F2      V2      f2      v2      2      2      2      2      2      2      2      2      3      3      &3      63      F3      V3      f3      v3      3      3      3      3      3      3      3      3      4      4      &4      64      F4      V4      f4      v4      4      4      4      4      4      4      4      4      5      5      &5      65      F5      V5      f5      v5      5      5      5      5      5      5      5      5      6      6      &6      66      F6      V6      f6      v6      6      6      6      6      6      6      6      6      7      7      &7      67      F7      V7      f7      v7      7      7      7      7      7      7                                                                                    QXilG+aO .5}*nuezwYz>~mejTR_cN
#)V@vA& 0W7nH%3Ryua}6AJGj67u_gpB}C(f=anIpMm2[`_]4~cT~	0 9;e7
ra}b$Th{<Hb:ZziT[G      M      S      Y      a      i                      :              97d040f1fa4159db3b0d06badf0c4d81744077.debug    \ .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .data.rel.ro .dynamic .got.plt .data .bss .gnu_debuglink                                                                              8      8      $                                 o       `      `      $                             (                                                   0                         .	                             8   o                                              E   o                                               T             `      `      p                           ^      B                                             h              0       0                                    c              0       0                                  n             7      7                                   w             7      7      R                             }                                                                                  0                                                      d                                                      	                                          p      p                                                x      x                                                            `                                                                                   r                                                                                                                                                                                                                                                           4                                                                                                                                                                                                                                tackle.vfs/lib/markdown/markdown.tcl                                                                100644  1751    1751    72516       14145011620 22606   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        #
# The MIT License (MIT)
#
# Copyright (c) 2014 Caius Project
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

package require textutil::tabify

## \file
# \brief Functions for converting markdown to HTML.

##
# \brief Functions for converting markdown to HTML.
#
namespace eval Markdown {

    namespace export convert

    ##
    #
    # Converts text written in markdown to HTML.
    #
    # @param markdown  currently takes as a single argument the text in markdown
    #
    # The output of this function is only a fragment, not a complete HTML
    # document. The format of the output is generic XHTML.
    #
    proc convert {markdown} {
        set markdown [regsub {\r\n?} $markdown {\n}]
        set markdown [::textutil::tabify::untabify2 $markdown 4]
        set markdown [string trimright $markdown]

        # COLLECT REFERENCES
        array unset ::Markdown::_references
        array set ::Markdown::_references [collect_references markdown]

        # PROCESS
        return [apply_templates markdown]
    }

    #
    # Register a language specific converter. This converter can be
    # used for fenced code blocks to transform the code block into a
    # prettified HTML.
    #
    proc register {lang_specifier converter} {
	set ::Markdown::converter($lang_specifier) $converter
    }

    #
    # Return a dict (attribute value pairs) of language specifiers and
    # the number of occurrences as they were used in fenced code blocks.
    #
    proc get_lang_counter {} {
	return [array get ::Markdown::lang_counter]
    }

    #
    # Reset the language counters of fenced code blocks.
    #
    proc reset_lang_counter {} {
	array unset ::Markdown::lang_counter
    }

    ## \private
    proc collect_references {markdown_var} {
        upvar $markdown_var markdown

        set lines [split $markdown \n]
        set no_lines [llength $lines]
        set index 0

        array set references {}

        while {$index < $no_lines} {
            set line [lindex $lines $index]

            if {[regexp \
                {^[ ]{0,3}\[((?:[^\]]|\[[^\]]*?\])+)\]:\s*(\S+)(?:\s+(([\"\']).*\4|\(.*\))\s*$)?} \
                $line match ref link title]} \
            {
                set title [string trim [string range $title 1 end-1]]
                if {$title eq {}} {
                    set next_line [lindex $lines [expr $index + 1]]

                    if {[regexp \
                        {^(?:\s+(?:([\"\']).*\1|\(.*\))\s*$)} \
                        $next_line]} \
                    {
                        set title [string range [string trim $next_line] 1 end-1]
                        incr index
                    }
                }
                set ref [string tolower $ref]
                set link [string trim $link {<>}]
                set references($ref) [list $link $title]
            }

            incr index
        }

        return [array get references]
    }

    ## \private
    proc apply_templates {markdown_var {parent {}}} {
        upvar $markdown_var markdown

        set lines    [split $markdown \n]
        set no_lines [llength $lines]
        set index    0
        set result   {}

        set ul_match {^[ ]{0,3}(?:\*(?!\s*\*\s*\*\s*$)|-(?!\s*-\s*-\s*$)|\+) }
        set ol_match {^[ ]{0,3}\d+\. }

        # PROCESS MARKDOWN
        while {$index < $no_lines} {
            set line [lindex $lines $index]

            switch -regexp -matchvar matches -- $line {
                {^\s*$} {
                    # EMPTY LINES
                    if {![regexp {^\s*$} [lindex $lines [expr $index - 1]]]} {
                        append result "\n\n"
                    }
                    incr index
                }
                {^[ ]{0,3}\[(?:[^\]]|\[[^\]]*?\])+\]:\s*\S+(?:\s+(?:([\"\']).*\1|\(.*\))\s*$)?} {
                    # SKIP REFERENCES
                    set next_line [lindex $lines [expr $index + 1]]

                    if {[regexp \
                        {^(?:\s+(?:([\"\']).*\1|\(.*\))\s*$)} \
                        $next_line]} \
                    {
                        incr index
                    }

                    incr index
                }
                {^[ ]{0,3}-[ ]*-[ ]*-[- ]*$} -
                {^[ ]{0,3}_[ ]*_[ ]*_[_ ]*$} -
                {^[ ]{0,3}\*[ ]*\*[ ]*\*[\* ]*$} {
                    # HORIZONTAL RULES
                    append result "<hr/>"
                    incr index
                }
                {^[ ]{0,3}#{1,6}} {
                    # ATX STYLE HEADINGS
                    set h_level 0
                    set h_result {}

                    while {$index < $no_lines && ![is_empty_line $line]} {
                        incr index

                        if {!$h_level} {
                            regexp {^\s*#+} $line m
                            set h_level [string length [string trim $m]]
                        }

                        lappend h_result $line

                        set line [lindex $lines $index]
                    }

                    set h_result [\
                        parse_inline [\
                            regsub -all {^\s*#+\s*|\s*#+\s*$} [join $h_result \n] {} \
                        ]\
                    ]

                    append result "<h$h_level>$h_result</h$h_level>"
                }
                {^[ ]{0,3}\>} {
                    # BLOCK QUOTES
                    set bq_result {}

                    while {$index < $no_lines} {
                        incr index

                        lappend bq_result [regsub {^[ ]{0,3}\>[ ]?} $line {}]

                        if {[is_empty_line [lindex $lines $index]]} {
                            set eoq 0

                            for {set peek $index} {$peek < $no_lines} {incr peek} {
                                set line [lindex $lines $peek]

                                if {![is_empty_line $line]} {
                                    if {![regexp {^[ ]{0,3}\>} $line]} {
                                        set eoq 1
                                    }
                                    break
                                }
                            }

                            if {$eoq} { break }
                        }

                        set line [lindex $lines $index]
                    }
                    set bq_result [string trim [join $bq_result \n]]

                    append result <blockquote>\n \
                                    [apply_templates bq_result] \
                                  \n</blockquote>
                }
                {^\s{4,}\S+} {
                    # CODE BLOCKS
                    set code_result {}

                    while {$index < $no_lines} {
                        incr index

                        lappend code_result [html_escape [\
                            regsub {^    } $line {}]\
                        ]

                        set eoc 0
                        for {set peek $index} {$peek < $no_lines} {incr peek} {
                            set line [lindex $lines $peek]

                            if {![is_empty_line $line]} {
                                if {![regexp {^\s{4,}} $line]} {
                                    set eoc 1
                                }
                                break
                            }
                        }

                        if {$eoc} { break }

                        set line [lindex $lines $index]
                    }
                    set code_result [join $code_result \n]

                    append result <pre><code> $code_result </code></pre>
                }
                {^(?:(?:`{3,})|(?:~{3,}))\{?(\S+)?\}?\s*$} {
                    # FENCED CODE BLOCKS
                    set code_result {}
                    if {[string index $line 0] eq {`}} {
                        set end_match {^`{3,}\s*$}
                    } else {
                        set end_match {^~{3,}\s*$}
                    }
		    #
		    # A language specifier might be provided
		    # immediately after the leading delimiters.
		    #
		    #     ```tcl
		    #
		    # The language specifier is used for two purposes:
		    # a) As a CSS class name
		    #    (useful e.g. for highlight.js)
		    # b) As a name for a source code to HTML converter.
		    #    When such a converter is registered,
		    #    the codeblock will be sent through this converter.
		    #
		    set lang_specifier [string tolower [lindex $matches end]]
		    if {$lang_specifier ne ""} {
			set code_CCS_class " class='$lang_specifier'"
			incr ::Markdown::lang_counter($lang_specifier)
		    } else {
			set code_CCS_class ""
		    }

                    while {$index < $no_lines} {
                        incr index

                        set line [lindex $lines $index]

                        if {[regexp $end_match $line]} {
                            incr index
                            break
                        }

                        lappend code_result $line
                    }
                    set code_result [join $code_result \n]

		    #
		    # If there is a converter registered, apply it on
		    # the resulting snippet.
		    #
		    if {[info exists ::Markdown::converter($lang_specifier)]} {
			set code_result [{*}$::Markdown::converter($lang_specifier) $code_result]
		    } else {
                        set code_result [html_escape $code_result]
                }
                    append result \
			"<pre class='code'>" \
			<code$code_CCS_class> \
			$code_result \
			</code></pre>
                }

                {^[ ]{0,3}(?:\*|-|\+) |^[ ]{0,3}\d+\. } {
                    # LISTS
                    set list_result {}

                    # continue matching same list type
                    if {[regexp $ol_match $line]} {
                        set list_type ol
                        set list_match $ol_match
                    } else {
                        set list_type ul
                        set list_match $ul_match
                    }

                    set last_line AAA

                    while {$index < $no_lines} \
                    {
                        if {![regexp $list_match [lindex $lines $index]]} {
                            break
                        }

                        set item_result {}
                        set in_p 1
                        set p_count 1

                        if {[is_empty_line $last_line]} {
                            incr p_count
                        }

                        set last_line $line
                        set line [regsub "$list_match\\s*" $line {}]

                        # prevent recursion on same line
                        set line [regsub {\A(\d+)\.(\s+)}   $line {\1\\.\2}]
                        set line [regsub {\A(\*|\+|-)(\s+)} $line {\\\1\2}]

                        lappend item_result $line

                        for {set peek [expr $index + 1]} {$peek < $no_lines} {incr peek} {
                            set line [lindex $lines $peek]

                            if {[is_empty_line $line]} {
                                set in_p 0
                            }\
                            elseif {[regexp {^    } $line]} {
                                if {!$in_p} {
                                    incr p_count
                                }
                                set in_p 1
                            }\
                            elseif {[regexp $list_match $line]} {
                                if {!$in_p} {
                                    incr p_count
                                }
                                break
                            }\
                            elseif {!$in_p} {
                                break
                            }

                            set last_line $line
                            lappend item_result [regsub {^    } $line {}]
                        }

                        set item_result [join $item_result \n]

                        if {$p_count > 1} {
                            set item_result [apply_templates item_result li]
                        } else {
                            if {[regexp -lineanchor \
                                {(\A.*?)((?:^[ ]{0,3}(?:\*|-|\+) |^[ ]{0,3}\d+\. ).*\Z)} \
                                $item_result \
                                match para rest]} \
                            {
                                set item_result [parse_inline $para]
                                append item_result [apply_templates rest]
                            } else {
                                set item_result [parse_inline $item_result]
                            }
                        }

                        lappend list_result "<li>$item_result</li>"
                        set index $peek
                    }

                    append result <$list_type>\n \
                                    [join $list_result \n] \
                                </$list_type>\n\n
                }
                {^<(?:p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)} {
                    # HTML BLOCKS
                    set re_htmltag {<(/?)(\w+)(?:\s+\w+=(?:\"[^\"]+\"|'[^']+'))*\s*>}
                    set buffer {}

                    while {$index < $no_lines} \
                    {
                        while {$index < $no_lines} \
                        {
                            incr index

                            append buffer $line \n

                            if {[is_empty_line $line]} {
                                break
                            }

                            set line [lindex $lines $index]
                        }

                        set tags [regexp -inline -all $re_htmltag  $buffer]
                        set stack_count 0

                        foreach {match type name} $tags {
                            if {$type eq {}} {
                                incr stack_count +1
                            } else {
                                incr stack_count -1
                            }
                        }

                        if {$stack_count == 0} { break }
                    }

                    append result $buffer
                }
                {(?:^\s{0,3}|[^\\]+)\|} {
                    # SIMPLE TABLES
                    set cell_align {}
                    set row_count 0

                    while {$index < $no_lines} \
                    {
                        # insert a space between || to handle empty cells
                        set row_cols [regexp -inline -all {(?:[^|]|\\\|)+} \
                            [regsub -all {\|(?=\|)} [string trim $line] {| }] \
                        ]

                        if {$row_count == 0} \
                        {
                            set sep_cols [lindex $lines [expr $index + 1]]

                            # check if we have a separator row
                            if {[regexp {^\s{0,3}\|?(?:\s*:?-+:?(?:\s*$|\s*\|))+} $sep_cols]} \
                            {
                                set sep_cols [regexp -inline -all {(?:[^|]|\\\|)+} \
                                    [string trim $sep_cols]]

                                foreach {cell_data} $sep_cols \
                                {
                                    switch -regexp $cell_data {
                                        {:-*:} {
                                            lappend cell_align center
                                        }
                                        {:-+} {
                                            lappend cell_align left
                                        }
                                        {-+:} {
                                            lappend cell_align right
                                        }
                                        default {
                                            lappend cell_align {}
                                        }
                                    }
                                }

                                incr index
                            }

                            append result "<table class=\"table\">\n"
                            append result "<thead>\n"
                            append result "  <tr>\n"

                            if {$cell_align ne {}} {
                                set num_cols [llength $cell_align]
                            } else {
                                set num_cols [llength $row_cols]
                            }

                            for {set i 0} {$i < $num_cols} {incr i} \
                            {
                                if {[set align [lindex $cell_align $i]] ne {}} {
                                    append result "    <th style=\"text-align: $align\">"
                                } else {
                                    append result "    <th>"
                                }

                                append result [parse_inline [string trim \
                                    [lindex $row_cols $i]]] </th> "\n"
                            }

                            append result "  </tr>\n"
                            append result "</thead>\n"
                        } else {
                            if {$row_count == 1} {
                                append result "<tbody>\n"
                            }

                            append result "  <tr>\n"

                            if {$cell_align ne {}} {
                                set num_cols [llength $cell_align]
                            } else {
                                set num_cols [llength $row_cols]
                            }

                            for {set i 0} {$i < $num_cols} {incr i} \
                            {
                                if {[set align [lindex $cell_align $i]] ne {}} {
                                    append result "    <td style=\"text-align: $align\">"
                                } else {
                                    append result "    <td>"
                                }

                                append result [parse_inline [string trim \
                                    [lindex $row_cols $i]]] </td> "\n"
                            }

                            append result "  </tr>\n"
                        }

                        incr row_count

                        set line [lindex $lines [incr index]]

                        if {![regexp {(?:^\s{0,3}|[^\\]+)\|} $line]} {
                            switch $row_count {
                                1 {
                                    append result "</table>\n"
                                }
                                default {
                                    append result "</tbody>\n"
                                    append result "</table>\n"
                                }
                            }

                            break
                        }
                    }
                }
                default {
                    # PARAGRAPHS AND SETTEXT STYLE HEADERS
                    set p_type p
                    set p_result {}

                    while {($index < $no_lines) && ![is_empty_line $line]} \
                    {
                        incr index

                        switch -regexp $line {
                            {^[ ]{0,3}=+$} {
                                set p_type h1
                                break
                            }
                            {^[ ]{0,3}-+$} {
                                set p_type h2
                                break
                            }
                            {^[ ]{0,3}(?:\*|-|\+) |^[ ]{0,3}\d+\. } {
                                if {$parent eq {li}} {
                                    incr index -1
                                    break
                                } else {
                                    lappend p_result $line
                                }
                            }
                            {^[ ]{0,3}-[ ]*-[ ]*-[- ]*$} -
                            {^[ ]{0,3}_[ ]*_[ ]*_[_ ]*$} -
                            {^[ ]{0,3}\*[ ]*\*[ ]*\*[\* ]*$} -
                            {^[ ]{0,3}#{1,6}} \
                            {
                                incr index -1
                                break
                            }
                            default {
                                lappend p_result $line
                            }
                        }

                        set line [lindex $lines $index]
                    }

                    set p_result [\
                        parse_inline [\
                            string trim [join $p_result \n]\
                        ]\
                    ]

                    if {[is_empty_line [regsub -all {<!--.*?-->} $p_result {}]]} {
                        # Do not make a new paragraph for just comments.
                        append result $p_result
                    } else {
                        append result "<$p_type>$p_result</$p_type>"
                    }
                }
            }
        }

        return $result
    }

    ## \private
    proc parse_inline {text} {
        set text [regsub -all -lineanchor {[ ]{2,}$} $text <br/>]

        set index 0
        set result {}

        set re_backticks   {\A`+}
        set re_whitespace  {\s}
        set re_inlinelink  {\A\!?\[((?:[^\]]|\[[^\]]*?\])+)\]\s*\(\s*((?:[^\s\)]+|\([^\s\)]+\))+)?(\s+([\"'])(.*)?\4)?\s*\)}
        set re_reflink     {\A\!?\[((?:[^\]]|\[[^\]]*?\])+)\](?:\s*\[((?:[^\]]|\[[^\]]*?\])*)\])?}
        set re_htmltag     {\A</?\w+\s*>|\A<\w+(?:\s+\w+=(?:\"[^\"]+\"|\'[^\']+\'))*\s*/?>}
        set re_autolink    {\A<(?:(\S+@\S+)|(\S+://\S+))>}
        set re_comment     {\A<!--.*?-->}
        set re_entity      {\A\&\S+;}

        while {[set chr [string index $text $index]] ne {}} {
            switch $chr {
                "\\" {
                    # ESCAPES
                    set next_chr [string index $text [expr $index + 1]]

                    if {[string first $next_chr {\`*_\{\}[]()#+-.!>|}] != -1} {
                        set chr $next_chr
                        incr index
                    }
                }
                {_} -
                {*} {
                    # EMPHASIS
                    if {[regexp $re_whitespace [string index $result end]] &&
                        [regexp $re_whitespace [string index $text [expr $index + 1]]]} \
                    {
                        #do nothing
                    } \
                    elseif {[regexp -start $index \
                        "\\A(\\$chr{1,3})((?:\[^\\$chr\\\\]|\\\\\\$chr)*)\\1" \
                        $text m del sub]} \
                    {
                        switch [string length $del] {
                            1 {
                                append result "<em>[parse_inline $sub]</em>"
                            }
                            2 {
                                append result "<strong>[parse_inline $sub]</strong>"
                            }
                            3 {
                                append result "<strong><em>[parse_inline $sub]</em></strong>"
                            }
                        }

                        incr index [string length $m]
                        continue
                    }
                }
                {`} {
                    # CODE
                    regexp -start $index $re_backticks $text m
                    set start [expr $index + [string length $m]]

                    if {[regexp -start $start -indices $m $text m]} {
                        set stop [expr [lindex $m 0] - 1]

                        set sub [string trim [string range $text $start $stop]]

                        append result "<code>[html_escape $sub]</code>"
                        set index [expr [lindex $m 1] + 1]
                        continue
                    }
                }
                {!} -
                {[} {
                    # LINKS AND IMAGES
                    if {$chr eq {!}} {
                        set ref_type img
                    } else {
                        set ref_type link
                    }

                    set match_found 0

                    if {[regexp -start $index $re_inlinelink $text m txt url ign del title]} {
                        # INLINE
                        incr index [string length $m]

                        set url [html_escape [string trim $url {<> }]]
                        set txt [parse_inline $txt]
                        set title [parse_inline $title]

                        set match_found 1
                    } elseif {[regexp -start $index $re_reflink $text m txt lbl]} {
                        if {$lbl eq {}} {
                            set lbl [regsub -all {\s+} $txt { }]
                        }

                        set lbl [string tolower $lbl]

                        if {[info exists ::Markdown::_references($lbl)]} {
                            lassign $::Markdown::_references($lbl) url title

                            set url [html_escape [string trim $url {<> }]]
                            set txt [parse_inline $txt]
                            set title [parse_inline $title]

                            # REFERENCED
                            incr index [string length $m]
                            set match_found 1
                        }
                    }

                    # PRINT IMG, A TAG
                    if {$match_found} {
                        if {$ref_type eq {link}} {
                            if {$title ne {}} {
                                append result "<a href=\"$url\" title=\"$title\">$txt</a>"
                            } else {
                                append result "<a href=\"$url\">$txt</a>"
                            }
                        } else {
                            if {$title ne {}} {
                                append result "<img src=\"$url\" alt=\"$txt\" title=\"$title\"/>"
                            } else {
                                append result "<img src=\"$url\" alt=\"$txt\"/>"
                            }
                        }

                        continue
                    }
                }
                {<} {
                    # HTML TAGS, COMMENTS AND AUTOLINKS
                    if {[regexp -start $index $re_comment $text m]} {
                        append result $m
                        incr index [string length $m]
                        continue
                    } elseif {[regexp -start $index $re_autolink $text m email link]} {
                        if {$link ne {}} {
                            set link [html_escape $link]
                            append result "<a href=\"$link\">$link</a>"
                        } else {
                            set mailto_prefix "mailto:"
                            if {![regexp "^${mailto_prefix}(.*)" $email mailto email]} {
                                # $email does not contain the prefix "mailto:".
                                set mailto "mailto:$email"
                            }
                            append result "<a href=\"$mailto\">$email</a>"
                        }
                        incr index [string length $m]
                        continue
                    } elseif {[regexp -start $index $re_htmltag $text m]} {
                        append result $m
                        incr index [string length $m]
                        continue
                    }

                    set chr [html_escape $chr]
                }
                {&} {
                    # ENTITIES
                    if {[regexp -start $index $re_entity $text m]} {
                        append result $m
                        incr index [string length $m]
                        continue
                    }

                    set chr [html_escape $chr]
                }
                {>} -
                {'} -
                "\"" {
                    # OTHER SPECIAL CHARACTERS
                    set chr [html_escape $chr]
                }
                default {}
            }

            append result $chr
            incr index
        }

        return $result
    }

    ## \private
    proc is_empty_line {line} {
        return [regexp {^\s*$} $line]
    }

    ## \private
    proc html_escape {text} {
        return [string map {& &amp; < &lt; > &gt; \" &quot;} $text]
    }
}

package provide Markdown 1.1.1
return
                                                                                                                                                                                  tackle.vfs/lib/markdown/pkgIndex.tcl                                                                100644  1751    1751    114         14145011620 22456   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        package ifneeded Markdown 1.1.1 [list source [file join $dir markdown.tcl]]
                                                                                                                                                                                                                                                                                                                                                                                                                                                    tackle.vfs/lib/http1.0/pkgIndex.tcl                                                                 100664  1751    1751    1337        14145011620 22064   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # Tcl package index file, version 1.0
# This file is generated by the "pkg_mkIndex" command
# and sourced either when an application starts up or
# by a "package unknown" script.  It invokes the
# "package ifneeded" command to set up package-related
# information so that packages will be loaded automatically
# in response to "package require" commands.  When this
# script is sourced, the variable $dir must contain the
# full path name of this file's directory.

package ifneeded http 1.0 [list tclPkgSetup $dir http 1.0 {{http.tcl source {httpCopyDone httpCopyStart httpEof httpEvent httpFinish httpMapReply httpProxyRequired http_code http_config http_data http_formatQuery http_get http_reset http_size http_status http_wait}}}]
                                                                                                                                                                                                                                                                                                 tackle.vfs/lib/http1.0/http.tcl                                                                     100664  1751    1751    22731       14145011620 21313   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # http.tcl
# Client-side HTTP for GET, POST, and HEAD commands.
# These routines can be used in untrusted code that uses the Safesock
# security policy.
# These procedures use a callback interface to avoid using vwait,
# which is not defined in the safe base.
#
# See the http.n man page for documentation

package provide http 1.0

array set http {
    -accept */*
    -proxyhost {}
    -proxyport {}
    -useragent {Tcl http client package 1.0}
    -proxyfilter httpProxyRequired
}
proc http_config {args} {
    global http
    set options [lsort [array names http -*]]
    set usage [join $options ", "]
    if {[llength $args] == 0} {
	set result {}
	foreach name $options {
	    lappend result $name $http($name)
	}
	return $result
    }
    regsub -all -- - $options {} options
    set pat ^-([join $options |])$
    if {[llength $args] == 1} {
	set flag [lindex $args 0]
	if {[regexp -- $pat $flag]} {
	    return $http($flag)
	} else {
	    return -code error "Unknown option $flag, must be: $usage"
	}
    } else {
	foreach {flag value} $args {
	    if {[regexp -- $pat $flag]} {
		set http($flag) $value
	    } else {
		return -code error "Unknown option $flag, must be: $usage"
	    }
	}
    }
}

 proc httpFinish { token {errormsg ""} } {
    upvar #0 $token state
    global errorInfo errorCode
    if {[string length $errormsg] != 0} {
	set state(error) [list $errormsg $errorInfo $errorCode]
	set state(status) error
    }
    catch {close $state(sock)}
    catch {after cancel $state(after)}
    if {[info exists state(-command)]} {
	if {[catch {eval $state(-command) {$token}} err]} {
	    if {[string length $errormsg] == 0} {
		set state(error) [list $err $errorInfo $errorCode]
		set state(status) error
	    }
	}
	unset state(-command)
    }
}
proc http_reset { token {why reset} } {
    upvar #0 $token state
    set state(status) $why
    catch {fileevent $state(sock) readable {}}
    httpFinish $token
    if {[info exists state(error)]} {
	set errorlist $state(error)
	unset state(error)
	eval error $errorlist
    }
}
proc http_get { url args } {
    global http
    if {![info exists http(uid)]} {
	set http(uid) 0
    }
    set token http#[incr http(uid)]
    upvar #0 $token state
    http_reset $token
    array set state {
	-blocksize 	8192
	-validate 	0
	-headers 	{}
	-timeout 	0
	state		header
	meta		{}
	currentsize	0
	totalsize	0
        type            text/html
        body            {}
	status		""
    }
    set options {-blocksize -channel -command -handler -headers \
		-progress -query -validate -timeout}
    set usage [join $options ", "]
    regsub -all -- - $options {} options
    set pat ^-([join $options |])$
    foreach {flag value} $args {
	if {[regexp $pat $flag]} {
	    # Validate numbers
	    if {[info exists state($flag)] && \
		    [regexp {^[0-9]+$} $state($flag)] && \
		    ![regexp {^[0-9]+$} $value]} {
		return -code error "Bad value for $flag ($value), must be integer"
	    }
	    set state($flag) $value
	} else {
	    return -code error "Unknown option $flag, can be: $usage"
	}
    }
    if {! [regexp -nocase {^(http://)?([^/:]+)(:([0-9]+))?(/.*)?$} $url \
	    x proto host y port srvurl]} {
	error "Unsupported URL: $url"
    }
    if {[string length $port] == 0} {
	set port 80
    }
    if {[string length $srvurl] == 0} {
	set srvurl /
    }
    if {[string length $proto] == 0} {
	set url http://$url
    }
    set state(url) $url
    if {![catch {$http(-proxyfilter) $host} proxy]} {
	set phost [lindex $proxy 0]
	set pport [lindex $proxy 1]
    }
    if {$state(-timeout) > 0} {
	set state(after) [after $state(-timeout) [list http_reset $token timeout]]
    }
    if {[info exists phost] && [string length $phost]} {
	set srvurl $url
	set s [socket $phost $pport]
    } else {
	set s [socket $host $port]
    }
    set state(sock) $s

    # Send data in cr-lf format, but accept any line terminators

    fconfigure $s -translation {auto crlf} -buffersize $state(-blocksize)

    # The following is disallowed in safe interpreters, but the socket
    # is already in non-blocking mode in that case.

    catch {fconfigure $s -blocking off}
    set len 0
    set how GET
    if {[info exists state(-query)]} {
	set len [string length $state(-query)]
	if {$len > 0} {
	    set how POST
	}
    } elseif {$state(-validate)} {
	set how HEAD
    }
    puts $s "$how $srvurl HTTP/1.0"
    puts $s "Accept: $http(-accept)"
    puts $s "Host: $host"
    puts $s "User-Agent: $http(-useragent)"
    foreach {key value} $state(-headers) {
	regsub -all \[\n\r\]  $value {} value
	set key [string trim $key]
	if {[string length $key]} {
	    puts $s "$key: $value"
	}
    }
    if {$len > 0} {
	puts $s "Content-Length: $len"
	puts $s "Content-Type: application/x-www-form-urlencoded"
	puts $s ""
	fconfigure $s -translation {auto binary}
	puts -nonewline $s $state(-query)
    } else {
	puts $s ""
    }
    flush $s
    fileevent $s readable [list httpEvent $token]
    if {! [info exists state(-command)]} {
	http_wait $token
    }
    return $token
}
proc http_data {token} {
    upvar #0 $token state
    return $state(body)
}
proc http_status {token} {
    upvar #0 $token state
    return $state(status)
}
proc http_code {token} {
    upvar #0 $token state
    return $state(http)
}
proc http_size {token} {
    upvar #0 $token state
    return $state(currentsize)
}

 proc httpEvent {token} {
    upvar #0 $token state
    set s $state(sock)

     if {[eof $s]} {
	httpEof $token
	return
    }
    if {$state(state) == "header"} {
	set n [gets $s line]
	if {$n == 0} {
	    set state(state) body
	    if {![regexp -nocase ^text $state(type)]} {
		# Turn off conversions for non-text data
		fconfigure $s -translation binary
		if {[info exists state(-channel)]} {
		    fconfigure $state(-channel) -translation binary
		}
	    }
	    if {[info exists state(-channel)] &&
		    ![info exists state(-handler)]} {
		# Initiate a sequence of background fcopies
		fileevent $s readable {}
		httpCopyStart $s $token
	    }
	} elseif {$n > 0} {
	    if {[regexp -nocase {^content-type:(.+)$} $line x type]} {
		set state(type) [string trim $type]
	    }
	    if {[regexp -nocase {^content-length:(.+)$} $line x length]} {
		set state(totalsize) [string trim $length]
	    }
	    if {[regexp -nocase {^([^:]+):(.+)$} $line x key value]} {
		lappend state(meta) $key $value
	    } elseif {[regexp ^HTTP $line]} {
		set state(http) $line
	    }
	}
    } else {
	if {[catch {
	    if {[info exists state(-handler)]} {
		set n [eval $state(-handler) {$s $token}]
	    } else {
		set block [read $s $state(-blocksize)]
		set n [string length $block]
		if {$n >= 0} {
		    append state(body) $block
		}
	    }
	    if {$n >= 0} {
		incr state(currentsize) $n
	    }
	} err]} {
	    httpFinish $token $err
	} else {
	    if {[info exists state(-progress)]} {
		eval $state(-progress) {$token $state(totalsize) $state(currentsize)}
	    }
	}
    }
}
 proc httpCopyStart {s token} {
    upvar #0 $token state
    if {[catch {
	fcopy $s $state(-channel) -size $state(-blocksize) -command \
	    [list httpCopyDone $token]
    } err]} {
	httpFinish $token $err
    }
}
 proc httpCopyDone {token count {error {}}} {
    upvar #0 $token state
    set s $state(sock)
    incr state(currentsize) $count
    if {[info exists state(-progress)]} {
	eval $state(-progress) {$token $state(totalsize) $state(currentsize)}
    }
    if {([string length $error] != 0)} {
	httpFinish $token $error
    } elseif {[eof $s]} {
	httpEof $token
    } else {
	httpCopyStart $s $token
    }
}
 proc httpEof {token} {
    upvar #0 $token state
    if {$state(state) == "header"} {
	# Premature eof
	set state(status) eof
    } else {
	set state(status) ok
    }
    set state(state) eof
    httpFinish $token
}
proc http_wait {token} {
    upvar #0 $token state
    if {![info exists state(status)] || [string length $state(status)] == 0} {
	vwait $token\(status)
    }
    if {[info exists state(error)]} {
	set errorlist $state(error)
	unset state(error)
	eval error $errorlist
    }
    return $state(status)
}

# Call http_formatQuery with an even number of arguments, where the first is
# a name, the second is a value, the third is another name, and so on.

proc http_formatQuery {args} {
    set result ""
    set sep ""
    foreach i $args {
	append result  $sep [httpMapReply $i]
	if {$sep != "="} {
	    set sep =
	} else {
	    set sep &
	}
    }
    return $result
}

# do x-www-urlencoded character mapping
# The spec says: "non-alphanumeric characters are replaced by '%HH'"
# 1 leave alphanumerics characters alone
# 2 Convert every other character to an array lookup
# 3 Escape constructs that are "special" to the tcl parser
# 4 "subst" the result, doing all the array substitutions

 proc httpMapReply {string} {
    global httpFormMap
    set alphanumeric	a-zA-Z0-9
    if {![info exists httpFormMap]} {

	for {set i 1} {$i <= 256} {incr i} {
	    set c [format %c $i]
	    if {![string match \[$alphanumeric\] $c]} {
		set httpFormMap($c) %[format %.2x $i]
	    }
	}
	# These are handled specially
	array set httpFormMap {
	    " " +   \n %0d%0a
	}
    }
    regsub -all \[^$alphanumeric\] $string {$httpFormMap(&)} string
    regsub -all \n $string {\\n} string
    regsub -all \t $string {\\t} string
    regsub -all {[][{})\\]\)} $string {\\&} string
    return [subst $string]
}

# Default proxy filter.
 proc httpProxyRequired {host} {
    global http
    if {[info exists http(-proxyhost)] && [string length $http(-proxyhost)]} {
	if {![info exists http(-proxyport)] || ![string length $http(-proxyport)]} {
	    set http(-proxyport) 8080
	}
	return [list $http(-proxyhost) $http(-proxyport)]
    } else {
	return {}
    }
}
                                       tackle.vfs/lib/json/json_write.tcl                                                                  100664  1751    1751    12256       14145011620 22273   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # json_write.tcl --
#
#	Commands for the generation of JSON (Java Script Object Notation).
#
# Copyright (c) 2009-2011 Andreas Kupries <andreas_kupries@sourceforge.net>
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# RCS: @(#) $Id: json_write.tcl,v 1.2 2011/08/24 20:09:44 andreas_kupries Exp $

# ### ### ### ######### ######### #########
## Requisites

package require Tcl 8.5

namespace eval ::json::write {
    namespace export \
	string array object indented aligned

    namespace ensemble create
}

# ### ### ### ######### ######### #########
## API.

proc ::json::write::indented {{bool {}}} {
    variable indented

    if {[llength [info level 0]] > 2} {
	return -code error {wrong # args: should be "json::write indented ?bool?"}
    } elseif {[llength [info level 0]] == 2} {
	if {![::string is boolean -strict $bool]} {
	    return -code error "Expected boolean, got \"$bool\""
	}
	set indented $bool
	if {!$indented} {
	    variable aligned 0
	}
    }

    return $indented
}

proc ::json::write::aligned {{bool {}}} {
    variable aligned

    if {[llength [info level 0]] > 2} {
	return -code error {wrong # args: should be "json::write aligned ?bool?"}
    } elseif {[llength [info level 0]] == 2} {
	if {![::string is boolean -strict $bool]} {
	    return -code error "Expected boolean, got \"$bool\""
	}
	set aligned $bool
	if {$aligned} {
	    variable indented 1
	}
    }

    return $aligned
}

proc ::json::write::string {s} {
    variable quotes
    return "\"[::string map $quotes $s]\""
}

proc ::json::write::array {args} {
    # always compact form.
    return "\[[join $args ,]\]"
}

proc ::json::write::object {args} {
    # The dict in args maps string keys to json-formatted data. I.e.
    # we have to quote the keys, but not the values, as the latter are
    # already in the proper format.

    variable aligned
    variable indented

    if {[llength $args] %2 == 1} {
	return -code error {wrong # args, expected an even number of arguments}
    }

    set dict {}
    foreach {k v} $args {
	lappend dict [string $k] $v
    }

    if {$aligned} {
	set max [MaxKeyLength $dict]
    }

    if {$indented} {
	set content {}
	foreach {k v} $dict {
	    if {$aligned} {
		set k [AlignLeft $max $k]
	    }
	    if {[::string match *\n* $v]} {
		# multi-line value
		lappend content "    $k : [Indent $v {    } 1]"
	    } else {
		# single line value.
		lappend content "    $k : $v"
	    }
	}
	if {[llength $content]} {
	    return "\{\n[join $content ,\n]\n\}"
	} else {
	    return "\{\}"
	}
    } else {
	# ultra compact form.
	set tmp {}
	foreach {k v} $dict {
	    lappend tmp "$k:$v"
	}
	return "\{[join $tmp ,]\}"
    }
}

# ### ### ### ######### ######### #########
## Internals.

proc ::json::write::Indent {text prefix skip} {
    set pfx ""
    set result {}
    foreach line [split $text \n] {
	if {!$skip} { set pfx $prefix } else { incr skip -1 }
	lappend result ${pfx}$line
    }
    return [join $result \n]
}

proc ::json::write::MaxKeyLength {dict} {
    # Find the max length of the keys in the dictionary.

    set lengths 0 ; # This will be the max if the dict is empty, and
		    # prevents the mathfunc from throwing errors for
		    # that case.

    foreach str [dict keys $dict] {
	lappend lengths [::string length $str]
    }

    return [tcl::mathfunc::max {*}$lengths]
}

proc ::json::write::AlignLeft {fieldlen str} {
    return [format %-${fieldlen}s $str]
    #return $str[::string repeat { } [expr {$fieldlen - [::string length $str]}]]
}

# ### ### ### ######### ######### #########

namespace eval ::json::write {
    # Configuration of the layout to write.

    # indented = boolean. objects are indented.
    # aligned  = boolean. object keys are aligned vertically.

    # aligned  => indented.

    # Combinations of the format specific entries
    # I A |
    # - - + ---------------------
    # 0 0 | Ultracompact (no whitespace, single line)
    # 1 0 | Indented
    # 0 1 | Not possible, per the implications above.
    # 1 1 | Indented + vertically aligned keys
    # - - + ---------------------

    variable indented 1
    variable aligned  1

    variable quotes \
	[list "\"" "\\\"" \\ \\\\ \b \\b \f \\f \n \\n \r \\r \t \\t \
	     \x00 \\u0000 \x01 \\u0001 \x02 \\u0002 \x03 \\u0003 \
	     \x04 \\u0004 \x05 \\u0005 \x06 \\u0006 \x07 \\u0007 \
	     \x0b \\u000b \x0e \\u000e \x0f \\u000f \x10 \\u0010 \
	     \x11 \\u0011 \x12 \\u0012 \x13 \\u0013 \x14 \\u0014 \
	     \x15 \\u0015 \x16 \\u0016 \x17 \\u0017 \x18 \\u0018 \
	     \x19 \\u0019 \x1a \\u001a \x1b \\u001b \x1c \\u001c \
	     \x1d \\u001d \x1e \\u001e \x1f \\u001f \x7f \\u007f \
	     \x80 \\u0080 \x81 \\u0081 \x82 \\u0082 \x83 \\u0083 \
	     \x84 \\u0084 \x85 \\u0085 \x86 \\u0086 \x87 \\u0087 \
	     \x88 \\u0088 \x89 \\u0089 \x8a \\u008a \x8b \\u008b \
	     \x8c \\u008c \x8d \\u008d \x8e \\u008e \x8f \\u008f \
	     \x90 \\u0090 \x91 \\u0091 \x92 \\u0092 \x93 \\u0093 \
	     \x94 \\u0094 \x95 \\u0095 \x96 \\u0096 \x97 \\u0097 \
	     \x98 \\u0098 \x99 \\u0099 \x9a \\u009a \x9b \\u009b \
	     \x9c \\u009c \x9d \\u009d \x9e \\u009e \x9f \\u009f ]
}

# ### ### ### ######### ######### #########
## Ready

package provide json::write 1.0.3
return
                                                                                                                                                                                                                                                                                                                                                  tackle.vfs/lib/json/pkgIndex.tcl                                                                    100664  1751    1751    471         14145011620 21615   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # Tcl package index file, version 1.1

if {![package vsatisfies [package provide Tcl] 8.4]} {return}
package ifneeded json 1.3.4 [list source [file join $dir json.tcl]]

if {![package vsatisfies [package provide Tcl] 8.5]} {return}
package ifneeded json::write 1.0.3 [list source [file join $dir json_write.tcl]]
                                                                                                                                                                                                       tackle.vfs/lib/json/json.tcl                                                                        100664  1751    1751    16435       14145011620 21064   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # json.tcl --
#
#	JSON parser for Tcl. Management code, Tcl/C detection and selection.
#
# Copyright (c) 2013 by Andreas Kupries

# @mdgen EXCLUDE: jsonc.tcl

package require Tcl 8.4
namespace eval ::json {}

# ### ### ### ######### ######### #########
## Management of json implementations.

# ::json::LoadAccelerator --
#
#	Loads a named implementation, if possible.
#
# Arguments:
#	key	Name of the implementation to load.
#
# Results:
#	A boolean flag. True if the implementation
#	was successfully loaded; and False otherwise.

proc ::json::LoadAccelerator {key} {
    variable accel
    set r 0
    switch -exact -- $key {
	critcl {
	    # Critcl implementation of json requires Tcl 8.4.
	    if {![package vsatisfies [package provide Tcl] 8.4]} {return 0}
	    if {[catch {package require tcllibc}]} {return 0}
	    # Check for the jsonc 1.1.1 API we are fixing later.
	    set r [llength [info commands ::json::many_json2dict_critcl]]
	}
	tcl {
	    variable selfdir
	    source [file join $selfdir json_tcl.tcl]
	    set r 1
	}
        default {
            return -code error "invalid accelerator/impl. package $key:\
                must be one of [join [KnownImplementations] {, }]"
        }
    }
    set accel($key) $r
    return $r
}

# ::json::SwitchTo --
#
#	Activates a loaded named implementation.
#
# Arguments:
#	key	Name of the implementation to activate.
#
# Results:
#	None.

proc ::json::SwitchTo {key} {
    variable accel
    variable loaded
    variable apicmds

    if {[string equal $key $loaded]} {
	# No change, nothing to do.
	return
    } elseif {![string equal $key ""]} {
	# Validate the target implementation of the switch.

	if {![info exists accel($key)]} {
	    return -code error "Unable to activate unknown implementation \"$key\""
	} elseif {![info exists accel($key)] || !$accel($key)} {
	    return -code error "Unable to activate missing implementation \"$key\""
	}
    }

    # Deactivate the previous implementation, if there was any.

    if {![string equal $loaded ""]} {
	foreach c $apicmds {
	    rename ::json::${c} ::json::${c}_$loaded
	}
    }

    # Activate the new implementation, if there is any.

    if {![string equal $key ""]} {
	foreach c $apicmds {
	    rename ::json::${c}_$key ::json::${c}
	}
    }

    # Remember the active implementation, for deactivation by future
    # switches.

    set loaded $key
    return
}

# ::json::Implementations --
#
#	Determines which implementations are
#	present, i.e. loaded.
#
# Arguments:
#	None.
#
# Results:
#	A list of implementation keys.

proc ::json::Implementations {} {
    variable accel
    set res {}
    foreach n [array names accel] {
	if {!$accel($n)} continue
	lappend res $n
    }
    return $res
}

# ::json::KnownImplementations --
#
#	Determines which implementations are known
#	as possible implementations.
#
# Arguments:
#	None.
#
# Results:
#	A list of implementation keys. In the order
#	of preference, most prefered first.

proc ::json::KnownImplementations {} {
    return {critcl tcl}
}

proc ::json::Names {} {
    return {
	critcl {tcllibc based}
	tcl    {pure Tcl}
    }
}

# ### ### ### ######### ######### #########
## Initialization: Data structures.

namespace eval ::json {
    variable  selfdir [file dirname [info script]]
    variable  accel
    array set accel   {tcl 0 critcl 0}
    variable  loaded  {}

    variable apicmds {
	json2dict
	many-json2dict
    }
}

# ### ### ### ######### ######### #########
## Wrapper fix for the jsonc package to match APIs.

proc ::json::many-json2dict_critcl {args} {
    eval [linsert $args 0 ::json::many_json2dict_critcl]
}

# ### ### ### ######### ######### #########
## Initialization: Choose an implementation,
## most prefered first. Loads only one of the
## possible implementations. And activates it.

namespace eval ::json {
    variable e
    foreach e [KnownImplementations] {
	if {[LoadAccelerator $e]} {
	    SwitchTo $e
	    break
	}
    }
    unset e
}

# ### ### ### ######### ######### #########
## Tcl implementation of validation, shared for Tcl and C implementation.
##
## The regexp based validation is consistently faster than json-c.
## Suspected reasons: Tcl REs are mainly in C as well, and json-c has
## overhead in constructing its own data structures. While irrelevant
## to validation json-c still builds them, it has no mode doing pure
## syntax checking.

namespace eval ::json {
    # Regular expression for tokenizing a JSON text (cf. http://json.org/)

    # tokens consisting of a single character
    variable singleCharTokens { "{" "}" ":" "\\[" "\\]" "," }
    variable singleCharTokenRE "\[[join $singleCharTokens {}]\]"

    # quoted string tokens
    variable escapableREs { "[\\\"\\\\/bfnrt]" "u[[:xdigit:]]{4}" "." }
    variable escapedCharRE "\\\\(?:[join $escapableREs |])"
    variable unescapedCharRE {[^\\\"]}
    variable stringRE "\"(?:$escapedCharRE|$unescapedCharRE)*\""

    # as above, for validation
    variable escapableREsv { "[\\\"\\\\/bfnrt]" "u[[:xdigit:]]{4}" }
    variable escapedCharREv "\\\\(?:[join $escapableREsv |])"
    variable stringREv "\"(?:$escapedCharREv|$unescapedCharRE)*\""

    # (unquoted) words
    variable wordTokens { "true" "false" "null" }
    variable wordTokenRE [join $wordTokens "|"]

    # number tokens
    # negative lookahead (?!0)[[:digit:]]+ might be more elegant, but
    # would slow down tokenizing by a factor of up to 3!
    variable positiveRE {[1-9][[:digit:]]*}
    variable cardinalRE "-?(?:$positiveRE|0)"
    variable fractionRE {[.][[:digit:]]+}
    variable exponentialRE {[eE][+-]?[[:digit:]]+}
    variable numberREa "${cardinalRE}(?:$fractionRE)?(?:$exponentialRE)?"
    variable numberREb "${fractionRE}(?:$exponentialRE)?"
    variable numberREc "${cardinalRE}\[.\](?:$exponentialRE)?"
    variable numberRE  "$numberREa|$numberREb|$numberREc"
    variable numberRE  "$numberREa|$numberREb|$numberREc"

    # JSON token, and validation
    variable tokenRE "$singleCharTokenRE|$stringRE|$wordTokenRE|$numberRE"
    variable tokenREv "$singleCharTokenRE|$stringREv|$wordTokenRE|$numberRE"

    # 0..n white space characters
    set whiteSpaceRE {[[:space:]]*}

    # Regular expression for validating a JSON text
    variable validJsonRE "^(?:${whiteSpaceRE}(?:$tokenREv))*${whiteSpaceRE}$"
}


# Validate JSON text
# @param jsonText JSON text
# @return 1 iff $jsonText conforms to the JSON grammar
#           (@see http://json.org/)
proc ::json::validate {jsonText} {
    variable validJsonRE

    return [regexp -- $validJsonRE $jsonText]
}

# ### ### ### ######### ######### #########
## These three procedures shared between Tcl and Critcl implementations.
## See also package "json::write".

proc ::json::dict2json {dictVal} {
    # XXX: Currently this API isn't symmetrical, as to create proper
    # XXX: JSON text requires type knowledge of the input data
    set json ""
    set prefix ""

    foreach {key val} $dictVal {
	# key must always be a string, val may be a number, string or
	# bare word (true|false|null)
	if {0 && ![string is double -strict $val]
	    && ![regexp {^(?:true|false|null)$} $val]} {
	    set val "\"$val\""
	}
    	append json "$prefix\"$key\": $val" \n
	set prefix ,
    }

    return "\{${json}\}"
}

proc ::json::list2json {listVal} {
    return "\[[join $listVal ,]\]"
}

proc ::json::string2json {str} {
    return "\"$str\""
}

# ### ### ### ######### ######### #########
## Ready

package provide json 1.3.4
                                                                                                                                                                                                                                   tackle.vfs/lib/json/jsonc.tcl                                                                       100664  1751    1751    10215       14145011620 21215   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # jsonc.tcl --
#
#       Implementation of a JSON parser in C.
#	Binding to a yacc/bison parser by Mikhail.
#
# Copyright (c) 2013,2015 - critcl wrapper - Andreas Kupries <andreas_kupries@users.sourceforge.net>
# Copyright (c) 2013      - C binding      - mi+tcl.tk-2013@aldan.algebra.com

package require critcl
# @sak notprovided jsonc
package provide jsonc 1.1.2
package require Tcl 8.4

#critcl::cheaders -g
#critcl::debug memory symbols
critcl::cheaders -Ic c/*.h
critcl::csources c/*.c

# # ## ### Import base declarations, forwards ### ## # #

critcl::ccode {
    #include <json_y.h>
}

# # ## ### Main Conversion ### ## # #

namespace eval ::json {
    critcl::ccommand json2dict_critcl {dummy I objc objv} {
	struct context context = { NULL };

	if (objc != 2) {
	    Tcl_WrongNumArgs(I, 1, objv, "json");
	    return TCL_ERROR;
	}

	context.text   = Tcl_GetStringFromObj(objv[1], &context.remaining);
	context.I      = I;
	context.has_error = 0;
	context.result = TCL_ERROR;

	jsonparse (&context);
	return context.result;
    }

    # Issue with critcl 2 used here. Cannot use '-', incomplete distinction of C and Tcl names.
    # The json.tcl file making use of this code has a wrapper fixing the issue.
    critcl::ccommand many_json2dict_critcl {dummy I objc objv} {
	struct context context = { NULL };

	int                      max;
	int                      found;

	Tcl_Obj* result = Tcl_NewListObj (0, NULL);

	if ((objc < 2) || (objc > 3)) {
	    Tcl_WrongNumArgs(I, 1, objv, "jsonText ?max?");
	    return TCL_ERROR;
	}

	if (objc == 3) {
	    if (Tcl_GetIntFromObj(I, objv[2], &max) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (max <= 0) {
		Tcl_AppendResult (I, "Bad limit ",
				  Tcl_GetString (objv[2]),
				  " of json entities to extract.",
				  NULL);
		Tcl_SetErrorCode (I, "JSON", "BAD-LIMIT", NULL);
		return TCL_ERROR;
	    }

	} else {
	    max = -1;
	}

	context.text   = Tcl_GetStringFromObj(objv[1], &context.remaining);
	context.I      = I;
	context.has_error = 0;
	found  = 0;

	/* Iterate over the input until
	 * - we have gotten all requested values.
	 * - we have run out of input
	 * - we have run into an error
	 */

	while ((max < 0) || max) {
	    context.result = TCL_ERROR;
	    jsonparse (&context);

	    /* parse error, abort */
	    if (context.result != TCL_OK) {
		Tcl_DecrRefCount (result);
		return TCL_ERROR;
	    }

	    /* Proper value extracted, extend result */
	    found ++;
	    Tcl_ListObjAppendElement(I, result,
				     Tcl_GetObjResult (I));

	    /* Count down on the number of still missing
	     * values, if not asking for all (-1)
	     */
	    if (max > 0) max --;

	    /* Jump over trailing whitespace for proper end-detection */
	    jsonskip (&context);

	    /* Abort if we have consumed all input */
	    if (!context.remaining) break;

	    /* Clear scratch pad before continuing */
	    context.obj = NULL;
	}

	/* While all parses were ok we reached end of
	 * input without getting all requested values,
	 * this is an error
	 */
	if (max > 0) {
	    char buf [30];
	    sprintf (buf, "%d", found);
            Tcl_ResetResult (I);
	    Tcl_AppendResult (I, "Bad limit ",
			      Tcl_GetString (objv[2]),
			      " of json entities to extract, found only ",
			      buf,
			      ".",
			      NULL);
	    Tcl_SetErrorCode (I, "JSON", "BAD-LIMIT", "TOO", "LARGE", NULL);
	    Tcl_DecrRefCount (result);
	    return TCL_ERROR;
	}

	/* We are good and done */
	Tcl_SetObjResult(I, result);
	return TCL_OK;
    }

    if 0 {critcl::ccommand validate_critcl {dummy I objc objv} {
	struct context context = { NULL };

	if (objc != 2) {
	    Tcl_WrongNumArgs(I, 1, objv, "jsonText");
	    return TCL_ERROR;
	}

	context.text   = Tcl_GetStringFromObj(objv[1], &context.remaining);
	context.I      = I;
	context.result = TCL_ERROR;

	/* Iterate over the input until we have run
	 * out of text, or encountered an error. We
	 * use only the lexer here, and told it to not
	* create superfluous token values.
	 */

	while (context.remaining) {
	    if (jsonlex (&context) == -1) {
		Tcl_SetObjResult(I, Tcl_NewBooleanObj (0));
		return TCL_OK;
	    }
	}

	/* We are good and done */
	Tcl_SetObjResult(I, Tcl_NewBooleanObj (1));
	return TCL_OK;
    }}
}
                                                                                                                                                                                                                                                                                                                                                                                   tackle.vfs/lib/json/json_tcl.tcl                                                                    100664  1751    1751    21105       14145011620 21714   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        #
#   JSON parser for Tcl.
#
#   See http://www.json.org/ && http://www.ietf.org/rfc/rfc4627.txt
#
#   Total rework of the code published with version number 1.0 by
#   Thomas Maeder, Glue Software Engineering AG
#
#   $Id: json.tcl,v 1.7 2011/11/10 21:05:58 andreas_kupries Exp $
#

if {![package vsatisfies [package provide Tcl] 8.5]} {
    package require dict
}

# Parse JSON text into a dict
# @param jsonText JSON text
# @return dict (or list) containing the object represented by $jsonText
proc ::json::json2dict_tcl {jsonText} {
    variable tokenRE

    set tokens [regexp -all -inline -- $tokenRE $jsonText]
    set nrTokens [llength $tokens]
    set tokenCursor 0

    #puts I:($jsonText)
    #puts T:\t[join $tokens \nT:\t]
    return [parseValue $tokens $nrTokens tokenCursor]
}

# Parse multiple JSON entities in a string into a list of dictionaries
# @param jsonText JSON text to parse
# @param max      Max number of entities to extract.
# @return list of (dict (or list) containing the objects) represented by $jsonText
proc ::json::many-json2dict_tcl {jsonText {max -1}} {
    variable tokenRE

    if {$max == 0} {
	return -code error -errorCode {JSON BAD-LIMIT ZERO} \
	    "Bad limit 0 of json entities to extract."
    }

    set tokens [regexp -all -inline -- $tokenRE $jsonText]
    set nrTokens [llength $tokens]
    set tokenCursor 0

    set result {}
    set found 0
    set n $max
    while {$n != 0} {
	if {$tokenCursor >= $nrTokens} break
	lappend result [parseValue $tokens $nrTokens tokenCursor]
	incr found
	if {$n > 0} {incr n -1}
    }

    if {$n > 0} {
	return -code error -errorCode {JSON BAD-LIMIT TOO LARGE} \
	    "Bad limit $max of json entities to extract, found only $found."
    }

    return $result
}

# Throw an exception signaling an unexpected token
proc ::json::unexpected {tokenCursor token expected} {
    return -code error -errorcode [list JSON UNEXPECTED $tokenCursor $expected] \
	"unexpected token \"$token\" at position $tokenCursor; expecting $expected"
}

# Get rid of the quotes surrounding a string token and substitute the
# real characters for escape sequences within it
# @param token
# @return unquoted unescaped value of the string contained in $token
proc ::json::unquoteUnescapeString {tokenCursor token} {
    variable stringREv
    set unquoted [string range $token 1 end-1]

    if {![regexp $stringREv $token]} {
	unexpected $tokenCursor $token STRING
    }

    set res [subst -nocommands -novariables $unquoted]
    return $res
}

# Parse an object member
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @param objectDictName name (in caller's context) of dict
#                       representing the JSON object of which to
#                       parse the next member
proc ::json::parseObjectMember {tokens nrTokens tokenCursorName objectDictName} {
    upvar $tokenCursorName tokenCursor
    upvar $objectDictName objectDict

    set token [lindex $tokens $tokenCursor]
    set tc $tokenCursor
    incr tokenCursor

    set leadingChar [string index $token 0]
    if {$leadingChar eq "\""} {
        set memberName [unquoteUnescapeString $tc $token]

        if {$tokenCursor == $nrTokens} {
            unexpected $tokenCursor "END" "\":\""
        } else {
            set token [lindex $tokens $tokenCursor]
            incr tokenCursor

            if {$token eq ":"} {
                set memberValue [parseValue $tokens $nrTokens tokenCursor]
                dict set objectDict $memberName $memberValue
            } else {
                unexpected $tokenCursor $token "\":\""
            }
        }
    } else {
        unexpected $tokenCursor $token "STRING"
    }
}

# Parse the members of an object
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @param objectDictName name (in caller's context) of dict
#                       representing the JSON object of which to
#                       parse the next member
proc ::json::parseObjectMembers {tokens nrTokens tokenCursorName objectDictName} {
    upvar $tokenCursorName tokenCursor
    upvar $objectDictName objectDict

    while true {
        parseObjectMember $tokens $nrTokens tokenCursor objectDict

        set token [lindex $tokens $tokenCursor]
        incr tokenCursor

        switch -exact $token {
            "," {
                # continue
            }
            "\}" {
                break
            }
            default {
                unexpected $tokenCursor $token "\",\"|\"\}\""
            }
        }
    }
}

# Parse an object
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @return parsed object (Tcl dict)
proc ::json::parseObject {tokens nrTokens tokenCursorName} {
    upvar $tokenCursorName tokenCursor

    if {$tokenCursor == $nrTokens} {
        unexpected $tokenCursor "END" "OBJECT"
    } else {
        set result [dict create]

        set token [lindex $tokens $tokenCursor]

        if {$token eq "\}"} {
            # empty object
            incr tokenCursor
        } else {
            parseObjectMembers $tokens $nrTokens tokenCursor result
        }

        return $result
    }
}

# Parse the elements of an array
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @param resultName name (in caller's context) of the list
#                   representing the JSON array
proc ::json::parseArrayElements {tokens nrTokens tokenCursorName resultName} {
    upvar $tokenCursorName tokenCursor
    upvar $resultName result

    while true {
        lappend result [parseValue $tokens $nrTokens tokenCursor]

        if {$tokenCursor == $nrTokens} {
            unexpected $tokenCursor "END" "\",\"|\"\]\""
        } else {
            set token [lindex $tokens $tokenCursor]
            incr tokenCursor

            switch -exact $token {
                "," {
                    # continue
                }
                "\]" {
                    break
                }
                default {
                    unexpected $tokenCursor $token "\",\"|\"\]\""
                }
            }
        }
    }
}

# Parse an array
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @return parsed array (Tcl list)
proc ::json::parseArray {tokens nrTokens tokenCursorName} {
    upvar $tokenCursorName tokenCursor

    if {$tokenCursor == $nrTokens} {
        unexpected $tokenCursor "END" "ARRAY"
    } else {
        set result {}

        set token [lindex $tokens $tokenCursor]

        set leadingChar [string index $token 0]
        if {$leadingChar eq "\]"} {
            # empty array
            incr tokenCursor
        } else {
            parseArrayElements $tokens $nrTokens tokenCursor result
        }

        return $result
    }
}

# Parse a value
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @return parsed value (dict, list, string, number)
proc ::json::parseValue {tokens nrTokens tokenCursorName} {
    upvar $tokenCursorName tokenCursor

    if {$tokenCursor == $nrTokens} {
        unexpected $tokenCursor "END" "VALUE"
    } else {
        set token [lindex $tokens $tokenCursor]
	set tc $tokenCursor
        incr tokenCursor

        set leadingChar [string index $token 0]
        switch -exact -- $leadingChar {
            "\{" {
                return [parseObject $tokens $nrTokens tokenCursor]
            }
            "\[" {
                return [parseArray $tokens $nrTokens tokenCursor]
            }
            "\"" {
                # quoted string
                return [unquoteUnescapeString $tc $token]
            }
            "t" -
            "f" -
            "n" {
                # bare word: true, false, null (return as is)
                return $token
            }
            default {
                # number?
                if {[string is double -strict $token]} {
                    return $token
                } else {
                    unexpected $tokenCursor $token "VALUE"
                }
            }
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                           tackle.vfs/lib/uri/pkgIndex.tcl                                                                     100664  1751    1751    356         14145011620 21445   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        if {![package vsatisfies [package provide Tcl] 8.2]} {
    # FRINK: nocheck
    return
}
package ifneeded uri      1.2.7 [list source [file join $dir uri.tcl]]
package ifneeded uri::urn 1.0.3 [list source [file join $dir urn-scheme.tcl]]
                                                                                                                                                                                                                                                                                  tackle.vfs/lib/uri/urn-scheme.tcl                                                                   100664  1751    1751    11273       14145011620 22002   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # urn-scheme.tcl - Copyright (C) 2001 Pat Thoyts <patthoyts@users.sf.net>
#
# extend the uri package to deal with URN (RFC 2141)
# see http://www.normos.org/ietf/rfc/rfc2141.txt
#
# Released under the tcllib license.
#
# $Id: urn-scheme.tcl,v 1.11 2005/09/28 04:51:24 andreas_kupries Exp $
# -------------------------------------------------------------------------

package require uri      1.1.2

namespace eval ::uri {}
namespace eval ::uri::urn {}

# -------------------------------------------------------------------------

# Description:
#   Called by uri::split with a url to split into its parts.
#
proc ::uri::SplitUrn {uri} {
    #@c Split the given uri into then URN component parts
    #@a uri: the URI to split without it's scheme part.
    #@r List of the component parts suitable for 'array set'

    upvar \#0 [namespace current]::urn::URNpart pattern
    array set parts {nid {} nss {}}
    if {[regexp -- ^$pattern $uri -> parts(nid) parts(nss)]} {
        return [array get parts]
    } else {
        error "invalid urn syntax: \"$uri\" could not be parsed"
    }
}


# -------------------------------------------------------------------------

proc ::uri::JoinUrn args {
    #@c Join the parts of a URN scheme URI
    #@a list of nid value nss value
    #@r a valid string representation for your URI
    variable urn::NIDpart

    array set parts [list nid {} nss {}]
    array set parts $args
    if {! [regexp -- ^$NIDpart$ $parts(nid)]} {
        error "invalid urn: nid is invalid"
    }
    set url "urn:$parts(nid):[urn::quote $parts(nss)]"
    return $url
}

# -------------------------------------------------------------------------

# Quote the disallowed characters according to the RFC for URN scheme.
# ref: RFC2141 sec2.2
proc ::uri::urn::quote {url} {
    variable trans
    
    set ndx 0
    set result ""
    while {[regexp -indices -- "\[^$trans\]" $url r]} {
        set ndx [lindex $r 0]

        set ch [string index $url $ndx]
        if {$ch eq "\0"} {
            error "invalid character: character $chr is not allowed"
        }

        # Decode into UTF-8 bytes.
        set rep {}
        foreach ch [split [encoding convertto utf-8 $ch] {}] {
            scan $ch %c chr
            append rep %[format %.2X $chr]
        }
        
        incr ndx -1
        append result [string range $url 0 $ndx] $rep
        incr ndx 2
        set url [string range $url $ndx end]
    }
    append result $url
    return $result
}

# -------------------------------------------------------------------------
# Perform the reverse of urn::quote.

if { [package vcompare [package provide Tcl] 8.3] < 0 } {
    # Before Tcl 8.3 we do not have 'regexp -start'. We simulate it by
    # using 'string range' and adjusting the match results.

    proc ::uri::urn::unquote {url} {
        set result ""
        set start 0
        while {[regexp -indices {%[0-9a-fA-F]{2}} [string range $url $start end] match]} {
            foreach {first last} $match break
            incr first $start ; # Make the indices relative to the true string.
            incr last  $start ; # I.e. undo the effect of the 'string range' on match results.
            append result [string range $url $start [expr {$first - 1}]]
            append result [format %c 0x[string range $url [incr first] $last]]
            set start [incr last]
        }
        append result [string range $url $start end]
        # Recode the array of utf-8 bytes to the proper internal rep.
        return [encoding convertfrom utf-8 $result]
    }
} else {
    proc ::uri::urn::unquote {url} {
        set result ""
        set start 0
        while {[regexp -start $start -indices {%[0-9a-fA-F]{2}} $url match]} {
            foreach {first last} $match break
            append result [string range $url $start [expr {$first - 1}]]
            append result [format %c 0x[string range $url [incr first] $last]]
            set start [incr last]
        }
        append result [string range $url $start end]
        # Recode the array of utf-8 bytes to the proper internal rep.
        return [encoding convertfrom utf-8 $result]
    }
}

# -------------------------------------------------------------------------

::uri::register {urn URN} {
	variable NIDpart {[a-zA-Z0-9][a-zA-Z0-9-]{0,31}}
        variable esc {%[0-9a-fA-F]{2}}
        variable trans {a-zA-Z0-9$_.+!*'(,):=@;-}
        variable NSSpart "($esc|\[$trans\])+"
        variable URNpart "($NIDpart):($NSSpart)"
        variable schemepart $URNpart
	variable url "urn:$NIDpart:$NSSpart"
}

# -------------------------------------------------------------------------

package provide uri::urn 1.0.3

# -------------------------------------------------------------------------
# Local Variables:
#   indent-tabs-mode: nil
# End:
                                                                                                                                                                                                                                                                                                                                     tackle.vfs/lib/uri/uri.tcl                                                                          100664  1751    1751    122675      14145011620 20564   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # uri.tcl --
#
#	URI parsing and fetch
#
# Copyright (c) 2000 Zveno Pty Ltd
# Copyright (c) 2006 Pierre DAVID <Pierre.David@crc.u-strasbg.fr>
# Copyright (c) 2006 Andreas Kupries <andreas_kupries@users.sourceforge.net>
# Copyright (c) 2017 Keith Nash <kjnash@users.sourceforge.net>
# Steve Ball, http://www.zveno.com/
# Derived from urls.tcl by Andreas Kupries
#
# CVS: $Id: uri.tcl,v 1.36 2011/03/23 04:39:54 andreas_kupries Exp $

package require Tcl 8.2

namespace eval ::uri {

    namespace export split join
    namespace export resolve isrelative
    namespace export geturl
    namespace export canonicalize
    namespace export register
    namespace export setQuirkOption

    variable file:counter 0

    variable Quirks
    set Quirks(NoInitialSlash)      1
    set Quirks(NoExtraKeys)         0
    set Quirks(HostAsDriveLetter)   0
    set Quirks(RemoveDoubleSlashes) 1
    # Defaults for v1.2.7: {1 0 0 1}

    # --------------------------------------------------------------------------
    # These variables are used by uri::register and are a repository of
    # scheme-related pattern information that may be accessed by external code.
    # None is used by the other commands of this package.
    # --------------------------------------------------------------------------
    variable schemes       {}
    variable schemePattern ""
    variable url           ""
    variable url2part
    array set url2part     {}

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # basic regular expressions used in URL syntax.

    namespace eval basic {
	# ----------------------------------------------------------------------
	# These variables are used to construct the variables used by commands.
	# ----------------------------------------------------------------------
	variable	digit		{[0-9]}
	variable	hex		{[0-9A-Fa-f]}
	variable	alphaDigit	{[A-Za-z0-9]}
	variable	alphaDigitMinus	{[A-Za-z0-9-]}
	variable	escape		"%${hex}${hex}"
	variable	digits		"${digit}+"

	variable	toplabel	\
		"(${alphaDigit}${alphaDigitMinus}*${alphaDigit}\\.?|${alphaDigit}\\.?)"
	variable	domainlabel	\
		"(${alphaDigit}${alphaDigitMinus}*${alphaDigit}|${alphaDigit})"

	variable	hostname	\
		"((${domainlabel}\\.)*${toplabel})"
	variable	hostnumber4	\
		"(?:${digits}\\.${digits}\\.${digits}\\.${digits})"
	variable	hostnumber6	{(?:\[[^]]*\])}
	variable	hostnumber	"(${hostnumber4}|${hostnumber6})"

	variable	usrCharN	{[a-zA-Z0-9$_.+!*'(,);?&=-]}
	variable	usrChar		"(${usrCharN}|${escape})"

	# ----------------------------------------------------------------------
	# >>> THESE VARIABLES ARE THE ONLY ONES USED BY COMMANDS <<<
	# ----------------------------------------------------------------------

	variable	hostspec	"${hostname}|${hostnumber}"
	variable	port		"${digit}*"
	variable	user		"${usrChar}*"
	variable	password	$user

	# ----------------------------------------------------------------------
	# This variable (and escape, hostname, hostnumber, port, user, password
	# from above) are used to construct the variables in the block below.
	# ----------------------------------------------------------------------

	variable	xCharN		{[a-zA-Z0-9$_.+!*'(,);/?:@&=-]}

	# ----------------------------------------------------------------------
	# These variables (and "escape") are used in the patterns defined in the
	# calls to uri::register at the end of the file.  They are not used by
	# any commands.
	# ----------------------------------------------------------------------

	variable	xChar		"(${xCharN}|${escape})"
	variable	host		"(${hostname}|${hostnumber})"
	variable	hostOrPort	"${host}(:${port})?"
	variable	login		"(${user}(:${password})?@)?${hostOrPort}"
	variable	alpha		{[a-zA-Z]}

	# ----------------------------------------------------------------------
	# These variables are not used by anything in this file.
	# ----------------------------------------------------------------------

	variable	loAlpha		{[a-z]}
	variable	hiAlpha		{[A-Z]}
	variable	safe		{[$_.+-]}
	variable	extra		{[!*'(,)]}
	# danger in next pattern, order important for []
	variable	national	{[][|\}\{\^~`]}
	variable	punctuation	{[<>#%"]}	;#" fake emacs hilit
	variable	reserved	{[;/?:@&=]}

	# next is <national | punctuation>
	variable	unsafe		{[][<>"#%\{\}|\\^~`]} ;#" emacs hilit

	#	unreserved	= alpha | digit | safe | extra
	#	xchar		= unreserved | reserved | escape

	variable	unreserved	{[a-zA-Z0-9$_.+!*'(,)-]}
	variable	uChar		"(${unreserved}|${escape})"

    } ;# basic {}
}

# ::uri::setQuirkOption
#
#	Accessor command for quirk options; uses "set" semantics.
#
#	Quirk options allow deviations from RFC 3986, and are fully documented
#	in the man page uri(n).
#
#	Currently defined quirk options are:
#	    NoInitialSlash
#	    NoExtraKeys
#	    RemoveDoubleSlashes
#	    HostAsDriveLetter
#
# Arguments:
#	key	name of a quirk option
#       value	(optional, boolean) new value
#
# Results:
#	The value of the quirk option.

proc ::uri::setQuirkOption {key args} {
    variable Quirks

    if {![info exists Quirks($key)]} {
	return -code error {unknown key}
    }

    set lenny [llength $args]
    if {$lenny == 0} {
	return $Quirks($key)
    } elseif {$lenny == 1} {
	set value [lindex $args 0]
	if {![string is boolean -strict $value]} {
	    return -code error {boolean value required}
	}
	set Quirks($key) [expr {$value && $value}]
	return $value
    } else {
        return -code error {wrong # args: should be "::uri::setQuirkOption\
		key ?newBooleanValue?"}
    }
}


# ::uri::register --
#
#	Register a scheme (and aliases) in the package. The command
#	creates a namespace below "::uri" with the same name as the
#	scheme and executes the script declaring the pattern variables
#	for this scheme in the new namespace. At last it updates the
#	uri variables keeping track of overall scheme information.
#
#	The script has to declare at least the variable "schemepart",
#	the pattern for an url of the registered scheme after the
#	scheme declaration. Not declaring this variable is an error.
#
#	Registration provides a number of pattern variables for use by external
#	code.  It is unconnected to the commands provided by the uri package.
#	See the warnings near the end of this file where uri::register is
#	called.
#
# Arguments:
#	schemeList	Name of the scheme to register, plus aliases
#       script		Script declaring the scheme patterns
#
# Results:
#	None.

proc ::uri::register {schemeList script} {
    variable schemes
    variable schemePattern
    variable url
    variable url2part

    # Check scheme and its aliases for existence.
    foreach scheme $schemeList {
	if {[lsearch -exact $schemes $scheme] >= 0} {
	    return -code error \
		    "trying to register scheme (\"$scheme\") which is already known"
	}
    }

    # Get the main scheme
    set scheme  [lindex $schemeList 0]

    if {[catch {namespace eval $scheme $script} msg]} {
	catch {namespace delete $scheme}
	return -code error \
	    "error while evaluating scheme script: $msg"
    }

    if {![info exists ${scheme}::schemepart]} {
	namespace delete $scheme
	return -code error \
	    "Variable \"schemepart\" is missing."
    }

    # Now we can extend the variables which keep track of the registered schemes.

    eval [linsert $schemeList 0 lappend schemes]
    set schemePattern	"([::join $schemes |]):"

    foreach s $schemeList {
	# FRINK: nocheck
	set url2part($s) "${s}:[set ${scheme}::schemepart]"
	# FRINK: nocheck
	append url "(${s}:[set ${scheme}::schemepart])|"
    }
    set url [string trimright $url |]
    return
}

# ::uri::split --
#
#	Splits the given <a url> into its constituents.
#
# Arguments:
#	url	the URL to split
#
# Results:
#	Tcl list containing constituents, suitable for 'array set'.

proc ::uri::split {url {defaultscheme http}} {

    set url [string trim $url]
    set scheme {}

    # RFC 3986 Sec 3.1: scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    regexp -- {^([A-Za-z][A-Za-z0-9+.-]*):} $url dummy scheme

    if {$scheme == {}} {
	set scheme $defaultscheme
	switch -- $scheme {
	    http - https - ftp {
		# x/y     -> //x/y    PREPEND //
		# /x/y    -> ///x/y   PREPEND //
		# //x/y   -> //x/y
		# ///x/y  -> ///x/y
		# ////x/y -> ////x/y
		if {[string range $url 0 1] != "//"} {
		    set url //$url
		}
	    }
	}
    }

    # ease maintenance: dynamic dispatch, able to handle all schemes
    # added in future!

    if {[::info procs Split[string totitle $scheme]] == {}} {
	error "unknown scheme '$scheme' in '$url'"
    }

    regsub -- "^${scheme}:" $url {} url

    # Pass url without scheme: to the per-scheme handler.
    set       parts(scheme) [string tolower $scheme]
    array set parts [Split[string totitle $scheme] $url]

    # Does not decode encoded characters.

    return [array get parts]
}

proc ::uri::SplitFtp {url} {
    # @c Splits the given ftp-<a url> into its constituents.
    # @a url: The url to split, without! scheme specification.
    # @r List containing the constituents, suitable for 'array set'.

    # general syntax:
    # //<user>:<password>@<host>:<port>/<cwd1>/.../<cwdN>/<name>;type=<typecode>
    #
    # additional rules:
    #
    # <user>:<password> are optional, detectable by presence of @.
    # <password> is optional too.
    #
    # "//" [ <user> [":" <password> ] "@"] <host> [":" <port>] "/"
    #	<cwd1> "/" ..."/" <cwdN> "/" <name> [";type=" <typecode>]

    upvar \#0 [namespace current]::ftp::typepart ftptype

    array set parts {user {} pwd {} host {} port {} path {} type {} scheme ftp}

    # slash off possible type specification

    if {[regexp -indices -- "${ftptype}$" $url dummy ftype]} {

	set from	[lindex $ftype 0]
	set to		[lindex $ftype 1]

	set parts(type)	[string range   $url $from $to]

	set from	[lindex $dummy 0]
	set url		[string replace $url $from end]
    }

    # Handle user, password, host and port

    if {[string match "//*" $url]} {
	set url [string range $url 2 end]

	array set parts [GetUPHP url]
	# (also removes UPHP from url)
    }

    set parts(path) $url
    AddQuirk3986 parts

    return [array get parts]
}

proc ::uri::JoinFtp args {
    set uphp [eval [linsert $args 0 ComposeUPHP {}]]

    array set components {
	pbare 0 path {} type {}
    }
    array set components $args

    set type {}
    if {[string length $components(type)]} {
	set type \;type=$components(type)
    }

    RemoveQuirk3986 components

    # Botches to accept certain invalid arguments instead of raising an error.

    set PathFirst [string index $components(path) 0]
    if {($PathFirst != {}) && ($PathFirst != {/})} {
	# The path is invalid: if it is not empty it must begin with "/".
	# This botch allows the command nevertheless to return a valid URI.
	set components(path) "/$components(path)"
    }

    if {($components(path) == {}) && ($components(type) != "")} {
	set components(path) "/"
	# FTP requires a non-empty path if $type is non-empty.
	# RFC 1738 Sec. 5, 
	# This botch enforces that.
    }

    return ftp://${uphp}$components(path)$type
}

proc ::uri::SplitHttps {url} {
    return [SplitHttpInner https $url]
}

proc ::uri::SplitHttp {url} {
    return [SplitHttpInner http $url]
}

proc ::uri::SplitHttpInner {scheme url} {
    # @c Splits the given http-<a url> into its constituents.
    # @a url: The url to split, without! scheme specification.
    # @r List containing the constituents, suitable for 'array set'.

    # general syntax:
    # //<host>:<port>/<path>?<searchpart>
    #
    #   where <host> and <port> are as described in Section 3.1. If :<port>
    #   is omitted, the port defaults to 80.  No user name or password is
    #   allowed.  <path> is an HTTP selector, and <searchpart> is a query
    #   string. The <path> is optional, as is the <searchpart> and its
    #   preceding "?". If neither <path> nor <searchpart> is present, the "/"
    #   may also be omitted.
    #
    #   Within the <path> and <searchpart> components, "/", ";", "?" are
    #   reserved.  The "/" character may be used within HTTP to designate a
    #   hierarchical structure.
    #
    # path == <cwd1> "/" ..."/" <cwdN> "/" <name> ["#" <fragment>]

    array set parts {host {} port {} path {} query {} fragment {}}
    array set parts [list scheme $scheme]

    set fragmentPattern "#(.*)\$"

    # slash off possible fragment.

    # NOTE: This must be done before the query, because a fragment can
    # follow a query, and slashing off the query first will take the
    # fragment with it. Bug #3235340.

    if {[regexp -indices -- $fragmentPattern $url match fragment]} {
	set from [lindex $fragment 0]
	set to   [lindex $fragment 1]

	set parts(fragment) [string range $url $from $to]

	set url [string replace $url [lindex $match 0] end]
    }

    # slash off possible query. the 'search' regexp, while official,
    # is not good enough. We have apparently lots of urls in the wild
    # which contain unquoted urls with queries in a query. The RE
    # finds the embedded query, not the actual one. Using string first
    # now instead of a RE

    if {[set pos [string first ? $url]] >= 0} {
	incr pos
	set parts(query) [string range   $url $pos end]
	incr pos -1
	set url          [string replace $url $pos end]
    }

    if {[string match "//*" $url]} {
	set url [string range $url 2 end]

	array set parts [GetUPHP url]
	# (also removes UPHP from url)
    }

    set parts(path) $url
    AddQuirk3986 parts

    return [array get parts]
}

proc ::uri::JoinHttp {args} {
    return [eval [linsert $args 0 ::uri::JoinHttpInner http 80]]
}

proc ::uri::JoinHttps {args} {
    return [eval [linsert $args 0 ::uri::JoinHttpInner https 443]]
}

proc ::uri::JoinHttpInner {scheme defport args} {
    set uphp [eval [linsert $args 0 ComposeUPHP $defport]]

    array set components {pbare 0 path {} query {} fragment {}}
    array set components $args

    set query {}
    if {[string length $components(query)]} {
	set query ?$components(query)
    }

    if { $components(fragment) != "" } {
	set components(fragment) "#$components(fragment)"
    } else {
	set components(fragment) ""
    }

    RemoveQuirk3986 components

    # Botch to accept certain invalid arguments instead of raising an error.

    set PathFirst [string index $components(path) 0]
    if {($PathFirst != {}) && ($PathFirst != {/})} {
	# The path is invalid: if it is not empty it must begin with "/".
	# This botch allows the command nevertheless to return a valid URI.
	set components(path) "/$components(path)"
    }

    return $scheme://$uphp$components(path)$query$components(fragment)
}

proc ::uri::SplitFile {url} {
    # @c Splits the given file-<a url> into its constituents.
    # @a url: The url to split, without! scheme specification.
    # @r List containing the constituents, suitable for 'array set'.
    variable Quirks

    upvar #0 [namespace current]::basic::hostspec	hostspec

    if {[string match "//*" $url]} {
	set url [string range $url 2 end]

	set hostPattern "^($hostspec)"

	if {    $Quirks(HostAsDriveLetter)
	     && ($::tcl_platform(platform) == "windows")
	} {
	    # Catch drive letter
	    append hostPattern :?
	} else {
	    # Proceed as usual
	}

	if {[regexp -indices -- $hostPattern $url match host]} {
	    set fh	[lindex $host 0]
	    set th	[lindex $host 1]

	    set parts(host)	[string range $url $fh $th]

	    set  matchEnd   [lindex $match 1]
	    incr matchEnd

	    set url	[string range $url $matchEnd end]
	}
    }

    # This always begins with "/" if $url is a valid absolute file:// URL.
    set parts(path) $url

    return [array get parts]
}

proc ::uri::JoinFile args {
    variable Quirks
    array set components {
	host {} port {} path {}
    }
    array set components $args

    if {    $Quirks(HostAsDriveLetter)
	 && ($::tcl_platform(platform) == "windows")
    } {
	# This misfeature is kept for compatibility with legacy code.
	if {[string length $components(host)]} {
	    return file://$components(host):$components(path)
	} else {
	    return file://$components(path)
	}
    } else {
        # Botch to accept certain invalid arguments instead of raising an error.
	if {[string index $components(path) 0] != "/"} {
	    # The path argument is invalid: it must begin with "/" (an empty
	    # path is not allowed for the scheme "file", RFC 1738 Sec. 5).
	    # This botch allows the command nevertheless to return a valid URI.
	    set components(path) "/$components(path)"
	} else {
	}

	return file://$components(host)$components(path)
    }
}

proc ::uri::SplitMailto {url} {
    # @c Splits the given mailto-<a url> into its constituents.
    # @a url: The url to split, without! scheme specification.
    # @r List containing the constituents, suitable for 'array set'.

    if {[string match "*@*" $url]} {
	set url [::split $url @]
	return [list user [lindex $url 0] host [lindex $url 1]]
    } else {
	return [list user $url]
    }
}

proc ::uri::JoinMailto args {
    array set components {
	user {} host {}
    }
    array set components $args

    return mailto:$components(user)@$components(host)
}

proc ::uri::SplitNews {url} {
    if { [string first @ $url] >= 0 } {
	return [list message-id $url]
    } else {
	return [list newsgroup-name $url]
    }
}

proc ::uri::JoinNews args {
    array set components {
	message-id {} newsgroup-name {}
    }
    array set components $args
    return news:$components(message-id)$components(newsgroup-name)
}

proc ::uri::SplitLdaps {url} {
    ::uri::SplitLdap $url
}

proc ::uri::SplitLdap {url} {
    # @c Splits the given Ldap-<a url> into its constituents.
    # @a url: The url to split, without! scheme specification.
    # @r List containing the constituents, suitable for 'array set'.

    # general syntax:
    # //<host>:<port>/<dn>?<attrs>?<scope>?<filter>?<extensions>
    #
    #   where <host> and <port> are as described in Section 5 of RFC 1738.
    #   No user name or password is allowed.
    #   If omitted, the port defaults to 389 for ldap, 636 for ldaps
    #   <dn> is the base DN for the search
    #   <attrs> is a comma separated list of attributes description
    #   <scope> is either "base", "one" or "sub".
    #   <filter> is a RFC 2254 filter specification
    #   <extensions> are documented in RFC 2255
    #

    array set parts {host {} port {} dn {} attrs {} scope {} filter {} extensions {}}

    #          host        port           dn          attrs       scope               filter     extns
    set re {//((?:[^:?/]+)|(?:\[[^\]]*\]))(?::([0-9]+))?(?:/([^?]+)(?:\?([^?]*)(?:\?(base|one|sub)?(?:\?([^?]*)(?:\?(.*))?)?)?)?)?}

    if {! [regexp $re $url match parts(host) parts(port) \
		parts(dn) parts(attrs) parts(scope) parts(filter) \
		parts(extensions)]} then {
	return -code error "unable to match URL \"$url\""
    }

    set parts(attrs) [::split $parts(attrs) ","]

    return [array get parts]
}

proc ::uri::JoinLdap {args} {
    return [eval [linsert $args 0 ::uri::JoinLdapInner ldap 389]]
}

proc ::uri::JoinLdaps {args} {
    return [eval [linsert $args 0 ::uri::JoinLdapInner ldaps 636]]
}

proc ::uri::JoinLdapInner {scheme defport args} {
    array set components {host {} port {} dn {} attrs {} scope {} filter {} extensions {}}
    set       components(port) $defport
    array set components $args

    set port {}
    if {[string length $components(port)] && $components(port) != $defport} {
	set port :$components(port)
    }

    set url "$scheme://$components(host)$port"

    set components(attrs) [::join $components(attrs) ","]

    set s ""
    foreach c {dn attrs scope filter extensions} {
	if {[string equal $c "dn"]} then {
	    append s "/"
	} else {
	    append s "?"
	}
	if {! [string equal $components($c) ""]} then {
	    append url "${s}$components($c)"
	    set s ""
	}
    }

    return $url
}

proc ::uri::ComposeUPHP {defport args} {
    # user:pwd@host:port

    array set components {
	user {} pwd {} host {} port {}
    }
    set       components(port) $defport
    array set components $args

    set userPwd {}
    if {[string length $components(user)] || [string length $components(pwd)]} {
	set userPwd $components(user)[expr {[string length $components(pwd)] ? ":$components(pwd)" : {}}]@
    }

    set port {}
    if {[string length $components(port)] && $components(port) != $defport} {
	set port :$components(port)
    }

    return ${userPwd}$components(host)${port}
}

proc ::uri::GetUPHP {urlvar} {
    # @c Parse user, password host and port out of the url stored in
    # @c variable <a urlvar>.
    # @d Side effect: The extracted information is removed from the given url.
    # @r List containing the extracted information in a format suitable for
    # @r 'array set'.
    # @a urlvar: Name of the variable containing the url to parse.

    upvar \#0 [namespace current]::basic::user		user
    upvar \#0 [namespace current]::basic::password	password
    upvar \#0 [namespace current]::basic::hostspec	hostspec
    upvar \#0 [namespace current]::basic::port		port

    upvar $urlvar url
    set url_save $url

    array set parts {user {} pwd {} host {} port {}}

    # syntax
    # "//" [ <user> [":" <password> ] "@"] <host> [":" <port>] "/"
    # "//" already cut off by caller

    set upPattern "^(${user})(:(${password}))?@"

    if {[regexp -indices -- $upPattern $url match theUser c d thePassword]} {
	set fu	[lindex $theUser 0]
	set tu	[lindex $theUser 1]

	set fp	[lindex $thePassword 0]
	set tp	[lindex $thePassword 1]

	set parts(user)	[string range $url $fu $tu]
	set parts(pwd)	[string range $url $fp $tp]

	set  matchEnd   [lindex $match 1]
	incr matchEnd

	set url	[string range $url $matchEnd end]
    }

    set hpPattern "^($hostspec)(:($port))?"

    if {[regexp -indices -- $hpPattern $url match theHost c d e f g h thePort]} {
	set fh	[lindex $theHost 0]
	set th	[lindex $theHost 1]

	set fp	[lindex $thePort 0]
	set tp	[lindex $thePort 1]

	set parts(host)	[string range $url $fh $th]
	set parts(port)	[string range $url $fp $tp]

	set  matchEnd   [lindex $match 1]
	incr matchEnd

	set url	[string range $url $matchEnd end]
    }
    
    if {(![string match /* $url]) && ($url ne {})} {
	error [list {invalid url} $url $url_save]
    }

    return [array get parts]
}

# ::uri::resolve --
#
#	Resolve an arbitrary URL, given a base URL
#
# This code depends on the ability of uri::split to process relative URIs.
# N.B. http(s): and ftp: path does not begin with "/" and may be empty.
# The file: path (unix or win) always begins "/", even if a host is specified.
#
# RFC 3986 Sec. 5.2 defines how URI relative resolution should proceed.
# This command is a "strict parser" in the sense of Sec. 5.2.2: it does not
# allow a relative URI such as "http:foo/bar.html".  See also the last example
# in Sec. 5.4.2 and uri-rfc2396.test test uri-rfc2396-11.19.
#
# Arguments:
#	base	base URL (absolute)
#	url	arbitrary URL
#
# Results:
#	Returns a URL

proc ::uri::resolve {base url} {
    if {[isrelative $url]} {
	set canon 1
	array set baseparts [split $base]

	switch -- $baseparts(scheme) {
	    http -
	    https -
	    ftp -
	    file {
		set changed 0
		array set relparts [split $baseparts(scheme):$url]
		if {[array names relparts path] != {path}} {
		    set relparts(path) {}
		}
		if { [string match /* $url] } {
		    set baseparts(path)  $relparts(path)
		    if {    [info exists baseparts(pbare)]
		         && [info exists relparts(pbare)]
		    } {
			# This test and action are sufficient to make
			# uri::resolve work for all schemes and quirk options.
			set baseparts(pbare) $relparts(pbare)
		    }
		    catch {
			if {$relparts(host) != ""} {
			    # RFC 3986 section 4.2 and 5.2.2.
			    # url has no scheme, but has authority
			    # ("UPHP" or User,Password,Host,Port). Use that
			    # authority. Do not transfer credentials or port
			    # number from the base authority.
			    set baseparts(host) $relparts(host)
			    set baseparts(user) {}
			    set baseparts(pwd)  {}
			    set baseparts(port) {}
			    set baseparts(user) $relparts(user)
			    set baseparts(pwd)  $relparts(pwd)
			    set baseparts(port) $relparts(port)
			}
		    }
		    set changed 1
		} elseif {    [string match */ $baseparts(path)]
			   && ([string length $relparts(path)] > 0)
		} {
		    set baseparts(path) "$baseparts(path)$relparts(path)"
		    set changed 1
		} elseif { [string length $relparts(path)] > 0 } {
		    set path [lreplace [::split $baseparts(path) /] end end]
		    set baseparts(path) "[::join $path /]/$relparts(path)"
		    set changed 1
		} else {
		    # Do not overwrite baseparts(path).  In this case,
		    # RFC 3986 Sec. 5.2.2 does not demand canonicalization.
		    # FIXME check whether the RFC assumes the base URI is
		    # already canonical.
		    set canon 0
		}
	    }
	    default {
		return -code error "unable to resolve relative URL \"$url\""
	    }
	}

	# query and fragment are defined for http, https; not for file, ftp
	# Fragment is useful in HTML documents that are accessed by file or ftp,
	# but this is not supported by the RFCs.
	switch -- $baseparts(scheme) {
	    http -
	    https {
		if {[array names relparts query] != {query}} {
		    set relparts(query) {}
		}
		if {[array names relparts fragment] != {fragment}} {
		    set relparts(fragment) {}
		}

		if {$changed || ($relparts(query) != {})} {
		    set baseparts(query) $relparts(query)
		    set changed 1
		} else {
		    # Keep base query.
		    # FIXME error if url has empty query "?".
		    # FIXME (in split/join) empty query "?".
		}

		# RFC 3986 section 5.2.2 requires that the base fragment
		# is always discarded.
		set baseparts(fragment) $relparts(fragment)
		# FIXME error if url has empty fragment "#".
		# FIXME (in split/join) empty fragment "#".
	    }
	    ftp -
	    file -
	    default {
	    }
	}

	set url [eval [linsert [array get baseparts] 0 join]]
	if {$canon} {
	    # RFC 3986 section 5.2.2 requires us to canonicalize the path.
	    set url [canonicalize $url]
	} else {
	}
	return $url
    } else {
	# RFC 3986 section 5.2.2 requires us to canonicalize the path.
	set url [canonicalize $url]
	return $url
    }
}

# ::uri::isrelative --
#
#	Determines whether a URL is absolute or relative
#
# Arguments:
#	url	URL to check
#
# Results:
#	Returns 1 if the URL is relative, 0 otherwise

proc ::uri::isrelative url {
    return [expr {![regexp -- {^[A-Za-z][A-Za-z0-9+.-]*:} $url]}]
}

# ::uri::geturl --
#
#	Fetch the data from an arbitrary URL.
#
#	This package provides a handler for the file:
#	scheme, since this conflicts with the file command.
#
# Arguments:
#	url	address of data resource
#	args	configuration options
#
# Results:
#	Depends on scheme

proc ::uri::geturl {url args} {
    array set urlparts [split $url]

    switch -- $urlparts(scheme) {
	file {
	    return [eval [linsert $args 0 file_geturl $url]]
	}
	default {
	    # Load a geturl package for the scheme first and only if
	    # that fails the scheme package itself. This prevents
	    # cyclic dependencies between packages.
	    if {[catch {package require $urlparts(scheme)::geturl}]} {
		package require $urlparts(scheme)
	    }
	    return [eval [linsert $args 0 $urlparts(scheme)::geturl $url]]
	}
    }
}

# ::uri::file_geturl --
#
#	geturl implementation for file: scheme
#
# TODO:
#	This is an initial, basic implementation.
#	Eventually want to support all options for geturl.
#
# Arguments:
#	url	URL to fetch
#	args	configuration options
#
# Results:
#	Returns data from file

proc ::uri::file_geturl {url args} {
    variable file:counter

    set var [namespace current]::file[incr file:counter]
    upvar #0 $var state
    array set state {data {}}

    array set parts [split $url]

    set ch [open $parts(path)]
    # Could determine text/binary from file extension,
    # except on Macintosh
    # fconfigure $ch -translation binary
    set state(data) [read $ch]
    close $ch

    return $var
}

# ::uri::join --
#
#	Format a URL
#
# Arguments:
#	args	components, key-value format
#
# Results:
#	A URL

proc ::uri::join args {
    array set components $args

    return [eval [linsert $args 0 Join[string totitle $components(scheme)]]]
}

# ::uri::canonicalize --
#
#	Canonicalize a URL
#
# Acknowledgements:
#	Andreas Kupries <andreas_kupries@users.sourceforge.net>
#	Keith Nash <kjnash@users.sourceforge.net>
#
# Arguments:
#	uri	URI (which contains a path component)
#
# Results:
#	The URI with the filename path in its canonical form.
#	This is not full URI "normalization" which may require further
#	processing.

proc ::uri::canonicalize uri {
    # Make uri canonical with respect to dots (path changing commands)
    #
    # Remove single dots (.)  => pwd not changing
    # Remove double dots (..) => gobble previous segment of path
    #
    # Fixes for this command:
    #
    # * Ignore any url which cannot be split into components by this
    #   module. Just assume that such urls do not have a path to
    #   canonicalize.
    #
    # * Ignore any url which could be split into components, but does
    #   not have a path component.
    #
    # In the text above 'ignore' means
    # 'return the url unchanged to the caller'.

    if {[catch {array set u [::uri::split $uri]}]} {
	return $uri
    }
    if {![info exists u(path)]} {
	return $uri
    }

    # RemoveDotSegments works perfectly well on paths without a leading "/", but
    # removing and re-adding the quirks ensures RFC 3986 conformance in a few
    # corner cases.
    RemoveQuirk3986 u
    set u(path) [RemoveDotSegments $u(path)]
    AddQuirk3986 u

    set uri [eval [linsert [array get u] 0 ::uri::join]]

    return $uri
}


# ::uri::RemoveDotSegments --
#
#	Remove any segments "." and ".." from a URI path.
#	Optionally remove empty segments {}.
#
#	Intended to implement the "remove_dot_segments" routine
#	defined in RFC 3986 Sec. 5.2.4.
#
# Acknowledgements:
#	Andreas Kupries <andreas_kupries@users.sourceforge.net>
#	Keith Nash <kjnash@users.sourceforge.net>
#
# Arguments:
#	path	path component of a URI
#
# Results:
#	The URI path in its canonical form.

proc ::uri::RemoveDotSegments path {
    variable Quirks

    set oldList [::split $path /]

    if {[lindex $oldList 0] == {}} {
	set lead 1
    } else {
	set lead 0
    }

    set end [llength $oldList]
    incr end -1

    # i - index of element seg in oldList
    # j - index of last element written to newList
    set i 0
    set j -1
    set newList {}
    foreach seg $oldList {
	if {    $Quirks(RemoveDoubleSlashes)
	     && ($seg == {}) && ($i != 0) && ($i != $end)
	} {
	    # Throw away this empty segment.
	    # This merges adjacent "/".
	    # If the first or last segment is empty, it is handled at "else".
	    # Other empty segments are also handled at "else" if this quirk has
	    # not been requested.
	} elseif {($seg == {.}) && ($i == $end)} {
	    # Replace "." with {} to keep a trailing "/" in path.
	    lappend newList {}
	    incr j
	} elseif {$seg == {.}} {
	    # Throw away this "." segment.
	} elseif {($seg == {..}) && ($j > $lead - 1) && ($i == $end)} {
	    # Remove the element previously added to newList, and
	    # replace it with {} to keep a trailing "/" in path.
	    set newList [lreplace $newList $j $j {}]
	} elseif {($seg == {..}) && ($j > $lead - 1)} {
	    # Remove the element previously added to newList.
	    set newList [lreplace $newList $j $j]
	    incr j -1
	} elseif {($seg == {..}) && ($i == $end)} {
	    # Can't go any deeper in newList, but this path needs a
	    # leading "/".
	    lappend newList {}
	    incr j
	} elseif {$seg == {..}} {
	    # Can't go any deeper in newList.
	} else {
	    # A "normal" path segment!
	    lappend newList $seg
	    incr j
	}

	incr i
    }

    return [::join $newList /]
}


# ::uri::RemoveQuirk3986
#
#	Work on an array produced by uri::split. Read the path and pbare
#	elements, and convert the path element to RFC 3986 compliance from
#	NoInitialSlash and NoExtraKeys quirks modes IF the caller has requested
#	these quirks AND they are used by the array's scheme.
#
#	Full RFC 3986 compliance is not possible if the caller has set both the
#	quirks NoInitialSlash and NoExtraKeys.  This mode is offered for
#	backward compatibility.  See documentation uri(n).
#
# Arguments:
#	arrName	    Name of array in the caller's stack frame that holds the
#		    results of uri::split.
# Results:
#	No return value.  The array is modified as a side effect.

proc ::uri::RemoveQuirk3986 {arrName} {
    variable Quirks
    upvar 1 $arrName u

    if {    $Quirks(NoInitialSlash)
	 && ([lsearch {http https ftp} $u(scheme)] != -1)
    } {
        if {$Quirks(NoExtraKeys)} {
	    array set u {pbare 0}
	} else {
	    # Keep existing value of u(pbare).
	}

	set PathFirst [string index $u(path) 0]
	if {($PathFirst != {}) && ($PathFirst != {/})} {
	    # If the quirk is set and used, then the leading "/" of the path has
	    # been stripped.  Put it back.
	    set u(path) "/$u(path)"
	} elseif {($PathFirst != {}) && ($PathFirst == {/})} {
	    # In principle we should prepend "/" to u(path) here too, but this
	    # leads to perverse results, e.g. uri::join with path "/" becomes
	    # path "//".
	} elseif {($PathFirst == {}) && (!$u(pbare))} {
	    # This is how {} and / are distinguished for the value of the
	    # 3986-defined path, when the quirk is set and used, i.e. when the
	    # leading "/" of the path has been stripped.
	    set u(path) "/"
	} else {
	    # Leave u(path) unchanged.
	}
    }

    if {$Quirks(NoInitialSlash) && (!$Quirks(NoExtraKeys))} {
	# pbare is required
    } else {
	array unset u pbare
    }

    return
}

# ::uri::AddQuirk3986
#
#	Work on an array produced by uri::split. Read the path element, and
#	convert the path and pbare elements from RFC 3986 compliance to
#	NoInitialSlash and NoExtraKeys quirks modes IF the caller has requested
#	these quirks AND they are used by the array's scheme.
#
# Arguments:
#	arrName	    Name of array in the caller's stack frame that holds the
#		    results of uri::split.
# Results:
#	No return value.  The array is modified as a side effect.

proc ::uri::AddQuirk3986 arrName {
    variable Quirks
    upvar 1 $arrName u

    array unset u pbare

    if {    $Quirks(NoInitialSlash)
	 && ([lsearch {http https ftp} $u(scheme)] != -1)
    } {
	if {$Quirks(NoExtraKeys)} {
	    # u(pbare) is refused
	} elseif {($u(path) == {})} {
	    set u(pbare) 1
	} else {
	    set u(pbare) 0
	}
	# In principle we should remove only the first "/", not all
	# of them, but it in this quirk regime it is cleaner to keep the
	# rule that the path never begins with "/".
	set u(path) [string trimleft $u(path) /]
    } else {
    }

    return
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# regular expressions covering various url schemes

# Currently known URL schemes:
#
# (RFC 1738)
# ------------------------------------------------
# scheme	basic syntax of scheme specific part
# ------------------------------------------------
# ftp		//<user>:<password>@<host>:<port>/<cwd1>/.../<cwdN>/<name>;type=<typecode>
#    		//<user>:<password>@<host>:<port>/fpath;type=<typecode>
#
# http		//<host>:<port>/<hpath>?<searchpart>
#
# gopher	//<host>:<port>/<gophertype><selector>
#				<gophertype><selector>%09<search>
#		<gophertype><selector>%09<search>%09<gopher+_string>
#
# mailto	<rfc822-addr-spec>
# news		<newsgroup-name>
#		<message-id>
# nntp		//<host>:<port>/<newsgroup-name>/<article-number>
# telnet	//<user>:<password>@<host>:<port>/
# wais		//<host>:<port>/<database>
#		//<host>:<port>/<database>?<search>
#		//<host>:<port>/<database>/<wtype>/<wpath>
# file		//<host>/<fpath>
# prospero	//<host>:<port>/<hsoname>;<field>=<value>
# ------------------------------------------------
#
# (RFC 2111)
# ------------------------------------------------
# scheme	basic syntax of scheme specific part
# ------------------------------------------------
# mid	message-id
#		message-id/content-id
# cid	content-id
# ------------------------------------------------
#
# (RFC 2255)
# ------------------------------------------------
# scheme	basic syntax of scheme specific part
# ------------------------------------------------
# ldap		//<host>:<port>/<dn>?<attrs>?<scope>?<filter>?<extensions>
# ------------------------------------------------


# ------------------------------------------------------------------------------
#     IMPORTANT WARNINGS
# ------------------------------------------------------------------------------
# (1) THE PATTERNS DEFINED BELOW (with one exception) ARE NOT USED FOR PARSING
#     URLs BY ANY OF THIS PACKAGE'S COMMANDS.
# (2) THAT EXCEPTION IS THE VARIABLE ::uri::ftp::typepart
# (3) AS LONG AS THAT VARIABLE IS ASSIGNED THE CORRECT VALUE, ALL THE
#     uri::register CALLS CAN BE DELETED WITHOUT AFFECTING THE uri::* COMMANDS.
# (2) REGISTRATION OF A SCHEME DOES NOT IMPLEMENT COMMANDS FOR THAT SCHEME.
# (3) REGISTRATION OF A SCHEME IS NOT NECESSARY TO IMPLEMENT COMMANDS FOR THAT
#     SCHEME.
#     Instead:
# (4) THE PATTERNS ARE FOR REFERENCE, AND CAN BE ACCESSED VIA THESE NAMESPACE
#     VARIABLES, OR IN SOME CASES VIA VARIABLES MAINTAINED BY uri::register.
# (5) THE VARIABLES schemepart AND url ARE MENTIONED IN THE DOCUMENTATION.
# (6) UNDOCUMENTED VARIABLES MIGHT BE ACCESSED BY THIRD-PARTY CODE.
# (7) THEREFORE EVERYTHING IS RETAINED FOR BACKWARD COMPATIBILITY.
# ------------------------------------------------------------------------------

# FTP
uri::register ftp {
    # Please read the warnings above.
    variable escape [set [namespace parent [namespace current]]::basic::escape]
    variable login  [set [namespace parent [namespace current]]::basic::login]

    variable	charN	{[a-zA-Z0-9$_.+!*'(,)?:@&=-]}
    variable	char	"(${charN}|${escape})"
    variable	segment	"${char}*"
    variable	path	"${segment}(/${segment})*"

    variable	type		{[AaDdIi]}
    variable	typepart	";type=(${type})"
    # Used elsewhere: typepart

    variable	schemepart	\
		    "//${login}(/${path}(${typepart})?)?"

    variable	url		"ftp:${schemepart}"
}

# FILE
uri::register file {
    # Please read the warnings above.
    variable	host [set [namespace parent [namespace current]]::basic::host]
    variable	path [set [namespace parent [namespace current]]::ftp::path]

    variable	schemepart	"//(${host}|localhost)?/${path}"
    variable	url		"file:${schemepart}"
}

# HTTP
uri::register {http https} {
    # Please read the warnings above.
    variable	escape \
        [set [namespace parent [namespace current]]::basic::escape]
    variable	hostOrPort	\
        [set [namespace parent [namespace current]]::basic::hostOrPort]

    variable	charN		{[a-zA-Z0-9$_.+!*'(,);:@&=-]}
    variable	char		"($charN|${escape})"
    variable	segment		"${char}*"

    variable	path		"${segment}(/${segment})*"
    variable	search		$segment
    variable	schemepart	\
	    "//${hostOrPort}(/${path}(\\?${search})?)?"

    variable	url		"http:${schemepart}"
}

# GOPHER
uri::register gopher {
    # Please read the warnings above.
    variable	xChar \
        [set [namespace parent [namespace current]]::basic::xChar]
    variable	hostOrPort \
        [set [namespace parent [namespace current]]::basic::hostOrPort]
    variable	search \
        [set [namespace parent [namespace current]]::http::search]

    variable	type		$xChar
    variable	selector	"$xChar*"
    variable	string		$selector
    variable	schemepart	\
	    "//${hostOrPort}(/(${type}(${selector}(%09${search}(%09${string})?)?)?)?)?"
    variable	url		"gopher:${schemepart}"
}

# MAILTO
uri::register mailto {
    # Please read the warnings above.
    variable xChar [set [namespace parent [namespace current]]::basic::xChar]
    variable host  [set [namespace parent [namespace current]]::basic::host]

    variable schemepart	"$xChar+(@${host})?"
    variable url	"mailto:${schemepart}"
}

# NEWS
uri::register news {
    # Please read the warnings above.
    variable escape [set [namespace parent [namespace current]]::basic::escape]
    variable alpha  [set [namespace parent [namespace current]]::basic::alpha]
    variable host   [set [namespace parent [namespace current]]::basic::host]

    variable	aCharN		{[a-zA-Z0-9$_.+!*'(,);/?:&=-]}
    variable	aChar		"($aCharN|${escape})"
    variable	gChar		{[a-zA-Z0-9$_.+-]}
    variable	newsgroup-name	"${alpha}${gChar}*"
    variable	message-id	"${aChar}+@${host}"
    variable	schemepart	"\\*|${newsgroup-name}|${message-id}"
    variable	url		"news:${schemepart}"
}

# WAIS
uri::register wais {
    # Please read the warnings above.
    variable	uChar \
        [set [namespace parent [namespace current]]::basic::xChar]
    variable	hostOrPort \
        [set [namespace parent [namespace current]]::basic::hostOrPort]
    variable	search \
        [set [namespace parent [namespace current]]::http::search]

    variable	db		"${uChar}*"
    variable	type		"${uChar}*"
    variable	path		"${uChar}*"

    variable	database	"//${hostOrPort}/${db}"
    variable	index		"//${hostOrPort}/${db}\\?${search}"
    variable	doc		"//${hostOrPort}/${db}/${type}/${path}"

    #variable	schemepart	"${doc}|${index}|${database}"

    variable	schemepart \
	    "//${hostOrPort}/${db}((\\?${search})|(/${type}/${path}))?"

    variable	url		"wais:${schemepart}"
}

# PROSPERO
uri::register prospero {
    # Please read the warnings above.
    variable	escape \
        [set [namespace parent [namespace current]]::basic::escape]
    variable	hostOrPort \
        [set [namespace parent [namespace current]]::basic::hostOrPort]
    variable	path \
        [set [namespace parent [namespace current]]::ftp::path]

    variable	charN		{[a-zA-Z0-9$_.+!*'(,)?:@&-]}
    variable	char		"(${charN}|$escape)"

    variable	fieldname	"${char}*"
    variable	fieldvalue	"${char}*"
    variable	fieldspec	";${fieldname}=${fieldvalue}"

    variable	schemepart	"//${hostOrPort}/${path}(${fieldspec})*"
    variable	url		"prospero:$schemepart"
}

# LDAP
uri::register {ldap ldaps} {
    # Please read the warnings above.
    variable	hostOrPort \
        [set [namespace parent [namespace current]]::basic::hostOrPort]

    # very crude parsing
    variable	dn		{[^?]*}
    variable	attrs		{[^?]*}
    variable	scope		"base|one|sub"
    variable	filter		{[^?]*}
    # extensions are not handled yet

    variable	schemepart	"//${hostOrPort}(/${dn}(\?${attrs}(\?(${scope})(\?${filter})?)?)?)?"
    variable	url		"ldap:$schemepart"
}

package provide uri 1.2.7
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   