#!/usr/bin/env tclsh
##############################################################################
#
#  Author        : Dr. Detlef Groth
#  Created By    : Dr. Detlef Groth
#  Created       : Tue Sep 7 17:58:32 2021
#  Last Modified : <211109.0055>
#
#  Description	 : Standalone deployment tool for Tcl apps using uncompressed tar archives.
#
#  Notes         : - tpack application code comes at the end
#                  - no extra package are required, tar package is embedded 
#
#  History       : 2021-09-10 - release 0.1  
#                  
#	
##############################################################################
#
#  Copyright (c) 2021 Dr. Detlef Groth.
# 
#  License:      MIT
# 
##############################################################################

# tpackTar -- take from tcllib tar
#
#       Creating, extracting, and listing posix tar archives
#
# Copyright (c) 2004    Aaron Faupell <afaupell@users.sourceforge.net>
# Copyright (c) 2013    Andreas Kupries <andreas_kupries@users.sourceforge.net>
#                       (GNU tar @LongLink support).
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# RCS: @(#) $Id: tar,v 1.17 2012/09/11 17:22:24 andreas_kupries Exp $

package require Tcl 8.4
package provide tpackTar 0.11

namespace eval ::tpackTar {}

proc ::tpackTar::parseOpts {acc opts} {
    array set flags $acc
    foreach {x y} $acc {upvar $x $x}
    
    set len [llength $opts]
    set i 0
    while {$i < $len} {
        set name [string trimleft [lindex $opts $i] -]
        if {![info exists flags($name)]} {
	    return -errorcode {TAR INVALID OPTION} \
		-code error "unknown option \"$name\""
	}
        if {$flags($name) == 1} {
            set $name [lindex $opts [expr {$i + 1}]]
            incr i $flags($name)
        } elseif {$flags($name) > 1} {
            set $name [lrange $opts [expr {$i + 1}] [expr {$i + $flags($name)}]]
            incr i $flags($name)
        } else {
            set $name 1
        }
        incr i
    }
}

proc ::tpackTar::pad {size} {
    set pad [expr {512 - ($size % 512)}]
    if {$pad == 512} {return 0}
    return $pad
}

proc ::tpackTar::seekorskip {ch off wh} {
    if {[tell $ch] < 0} {
	if {$wh!="current"} {
	    return -code error -errorcode [list TAR INVALID WHENCE $wh] \
		"WHENCE=$wh not supported on non-seekable channel $ch"
	}
	skip $ch $off
	return
    }
    seek $ch $off $wh
    return
}

proc ::tpackTar::readHeader {data} {
    binary scan $data a100a8a8a8a12a12a8a1a100a6a2a32a32a8a8a155 \
                      name mode uid gid size mtime cksum type \
                      linkname magic version uname gname devmajor devminor prefix

    foreach x {name type linkname} {
        set $x [string trim [set $x] "\x00"]
    }
    foreach x {uid gid size mtime cksum} {
        set $x [format %d 0[string trim [set $x] " \x00"]]
    }
    set mode [string trim $mode " \x00"]

    if {$magic == "ustar "} {
        # gnu tar
        # not fully supported
        foreach x {uname gname prefix} {
            set $x [string trim [set $x] "\x00"]
        }
        foreach x {devmajor devminor} {
            set $x [format %d 0[string trim [set $x] " \x00"]]
        }
    } elseif {$magic == "ustar\x00"} {
        # posix tar
        foreach x {uname gname prefix} {
            set $x [string trim [set $x] "\x00"]
        }
        foreach x {devmajor devminor} {
            set $x [format %d 0[string trim [set $x] " \x00"]]
        }
    } else {
        # old style tar
        foreach x {uname gname devmajor devminor prefix} { set $x {} }
        if {$type == ""} {
            if {[string match */ $name]} {
                set type 5
            } else {
                set type 0
            }
        }
    }

    return [list name $name mode $mode uid $uid gid $gid size $size mtime $mtime \
                 cksum $cksum type $type linkname $linkname magic $magic \
                 version $version uname $uname gname $gname devmajor $devmajor \
                 devminor $devminor prefix $prefix]
}
proc ::tpackTar::untar {tar args} {
    set nooverwrite 0
    set data 0
    set nomtime 0
    set noperms 0
    set chan 0
    parseOpts {dir 1 file 1 glob 1 nooverwrite 0 nomtime 0 noperms 0 chan 0} $args
    if {![info exists dir]} {set dir [pwd]}
    set pattern *
    if {[info exists file]} {
        set pattern [string map {* \\* ? \\? \\ \\\\ \[ \\\[ \] \\\]} $file]
    } elseif {[info exists glob]} {
        set pattern $glob
    }

    set ret {}
    if {$chan} {
	set fh $tar
    } else {
	set fh [::open $tar]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    while {![eof $fh]} {
        array set header [readHeader [read $fh 512]]
	HandleLongLink $fh header
        if {$header(name) == ""} break
	if {$header(prefix) != ""} {append header(prefix) /}
        set name [string trimleft $header(prefix)$header(name) /]
        if {![string match $pattern $name] || ($nooverwrite && [file exists $name])} {
            seekorskip $fh [expr {$header(size) + [pad $header(size)]}] current
            continue
        }

        set name [file join $dir $name]
        if {![file isdirectory [file dirname $name]]} {
            file mkdir [file dirname $name]
            lappend ret [file dirname $name] {}
        }
        if {[string match {[0346]} $header(type)]} {
            if {[catch {::open $name w+} new]} {
                # sometimes if we dont have write permission we can still delete
                catch {file delete -force $name}
                set new [::open $name w+]
            }
            fconfigure $new -encoding binary -translation lf -eofchar {}
            fcopy $fh $new -size $header(size)
            close $new
            lappend ret $name $header(size)
        } elseif {$header(type) == 5} {
            file mkdir $name
            lappend ret $name {}
        } elseif {[string match {[12]} $header(type)] && $::tcl_platform(platform) == "unix"} {
            catch {file delete $name}
            if {![catch {file link [string map {1 -hard 2 -symbolic} $header(type)] $name $header(linkname)}]} {
                lappend ret $name {}
            }
        }
        seekorskip $fh [pad $header(size)] current
        if {![file exists $name]} continue

        if {$::tcl_platform(platform) == "unix"} {
            if {!$noperms} {
                catch {file attributes $name -permissions 0[string range $header(mode) 2 end]}
            }
            catch {file attributes $name -owner $header(uid) -group $header(gid)}
            catch {file attributes $name -owner $header(uname) -group $header(gname)}
        }
        if {!$nomtime} {
            file mtime $name $header(mtime)
        }
    }
    if {!$chan} {
	close $fh
    }
    return $ret
}
proc ::tpackTar::HandleLongLink {fh hv} {
    upvar 1 $hv header thelongname thelongname

    # @LongName Part I.
    if {$header(type) == "L"} {
	# Size == Length of name. Read it, and pad to full 512
	# size.  After that is a regular header for the actual
	# file, where we have to insert the name. This is handled
	# by the next iteration and the part II below.
	set thelongname [string trimright [read $fh $header(size)] \000]
	seekorskip $fh [pad $header(size)] current
	return -code continue
    }
    # Not supported yet: type 'K' for LongLink (long symbolic links).

    # @LongName, part II, get data from previous entry, if defined.
    if {[info exists thelongname]} {
	set header(name) $thelongname
	# Prevent leakage to further entries.
	unset thelongname
    }

    return
}

package provide starkit 0.1

namespace eval starkit {
    proc startup { } {
        lappend ::auto_path [file join [file dirname [info script]] lib]
        return starkit
    }
}
proc getTempDir {} {
    if {[file exists /tmp]} {
        # standard UNIX
        return /tmp
    } elseif {[info exists ::env(TMP)]} {
        # Windows
        return $::env(TMP)
    } elseif {[info exists ::env(TEMP)]} {
        # Windows
        return $::env(TEMP)
    } elseif {[info exists ::env(TMPDIR)]} {
        # OSX
        return $::env(TMPDIR)
    }
}
set rname [file rootname [info script]]
if {[file exists $rname.vfs]} {
    source [file join $rname.vfs main.tcl]
} else {
    set tail [file tail $rname]
    set time [file mtime [info script]]
    set appname [info script]
    set tmpdir [getTempDir]
    set f [open $appname]
    fconfigure $f -translation binary
    set data [read $f][close $f]
    set ctrlz [string first \u001A $data]
    if {$ctrlz > 0} {
        # todo check file dates
        ## standalone file with attached tar archive
        set script [string range $data 0 [expr {$ctrlz - 2}]]
        set archive [string range $data [incr ctrlz] end]
        set scriptfile [file join $tmpdir [file rootname $appname].ttcl]
        set tarfile [file join $tmpdir [file tail [file rootname $appname]].ttar]
        if {[file exists $tarfile]} {
            set ttime [file mtime $tarfile]
            if {$ttime < $time} {
                # script is newer than tar file
                set tmp [open $tarfile w 0600]
                fconfigure $tmp -translation binary
                puts -nonewline $tmp $archive
                close $tmp
            }
        } else {
            set tmp [open $tarfile w 0600]
            fconfigure $tmp -translation binary
            puts -nonewline $tmp $archive
            close $tmp
        }
        #set tmp [open $scriptfile w 0600]
        #fconfigure $tmp -translation binary
        #puts -nonewline $tmp $script
        #close $tmp
    } else {
        set tarfile [file rootname [info script]].ttar
        if {![file exists $tarfile]} {
            puts "Error: File $tarfile does not exists"
            exit 0
        }
    }
    set ttime [file mtime $tarfile]
    set appdir [file join $tmpdir $tail-$ttime]
    foreach dir [glob -nocomplain [file join $tmpdir $rname]*] {
        if {$dir ne $appdir && [file isdir $dir]} {
            file delete -force $dir
        } 
    }
    if {![file exists $appdir]} {
        file mkdir $appdir
        #tpackTar::untar $tarfile -dir $appdir
        tpackTar::untar $tarfile -dir $appdir
    }
    set vfspath [lindex [glob [file join $appdir *]] 0]
    if {[file exists [file join $vfspath tpack.tcl]]} {
        source [file join $vfspath tpack.tcl]
    } elseif {[file exists [file join $vfspath main.tcl]]} {
        source [file join $vfspath main.tcl]
    } else {
        error "Neither tpack.tcl or main.tcl found in tar archive!"
    }
}

## ARCHIVE LOADER END
#//#
# Tackle is a package manager for the Tcl programming language.
# This file provides a command-line interface, e.g.:
# <pre>
#   $ tackle ls
#   tustack
#   tcllib
#   tcltls
#   $ tackle rm tutstack
#   Removed tutstack.
#   $ tackle ls
#   tcllib
#   tcltls
# </pre>
#
# @author    nat-418
# @version   0.0.6
# @see       https://www.github.com/tacklepkg/tackle
#//#
package require http
package require tls
package require textutil

set version 0.0.6

# We begin by inlining a few dependencies
# =======================================

namespace eval ::targz {
    package require tar
    package require zlib
    namespace export unpack

    # Unpacks a gzipped tarball
    #
    # @param  targz       Path to some file.tar.gz
    # @param  destination Path to an output directory for the archive contents
    # @return Path to the unarchived destination directory
    proc unpack {targz destination} {
        try {
            set unpacked  [lindex [exec tar -xvzf $targz] 0]
            set directory [file join $destination $unpacked]

            file rename $unpacked $directory
            file delete -force $targz

            return $directory
        } on error msg {
            puts "System tar not available, falling back to slow tar..."
            puts $msg
        }

        set tar [file rootname $targz]

        try {
            set chan1 [open $targz rb]
            zlib push gunzip $chan1 
            set contents [read $chan1]
            close $chan1
        } on error msg {
            puts "[redText Error:] Failed to decompress tarball: $targz."
            exit 1
        }
        
        try {
            set chan2 [open $tar wb]
            puts -nonewline $chan2 $contents
            close $chan2
        } on error msg {
            puts "[::termColor::red Error:] Failed to write archive: $tar."
            exit 1
        }
        
        set contents    [::tar::contents $tar]
        set directory   [file root $tar]

        set files [lmap path $contents {file tail $path}]

        foreach path $contents {
            try {
                if {[string index $path end] eq "/"} {
                    file mkdir [file join $destination $path]
                } else {
                    file mkdir [file normalize [file join $destination [file dirname $path]]]
                    set chan3 [open [file join $destination $path] wb]
                    puts -nonewline $chan3 [::tar::get $tar $path]
                    close $chan3
                }
            } on error msg {
                puts "Failed to unarchive $path."
            }
        }

        file delete $targz
        file delete $tar

        return $directory
    }
}

namespace eval ::httpRedirects {
    package require http
    package require uri

    namespace export geturl

    # GETs through HTTP redirects
    #
    # @param  url  URL target for the HTTP request
    # @param  args Options to pass to ::http::geturl
    # @return Token representing the respons to the request
    # @see    https://www.tcl.tk/man/tcl/TclCmd/http.html#M17
    proc geturl {url args} {
        array set URI [::uri::split $url]
        for {set i 0} {$i < 5} {incr i} {
            set token [::http::geturl $url {*}$args]

            if {![string match {30[1237]} [::http::ncode $token]]} {
                return $token
             }

            array set meta [string tolower [set ${token}(meta)]]

            if {![info exist meta(location)]} {
                return $token
            }

            array set uri [::uri::split $meta(location)]

            unset meta

            if {$uri(host) eq {}} {set uri(host) $URI(host)}

            # problem w/ relative versus absolute paths
            set url [::uri::join {*}[array get uri]]
        }
    }
}

namespace eval ::termColor {
    namespace export bright red green yellow

    # Apply ANSI bold color escape sequences to a string and then reset.
    #
    # @param  code Color code
    # @param  str  String to be colored
    # @return String with proper escape codes
    # @see    https://en.wikipedia.org/wiki/ANSI_escape_code
    proc highlight {code str} {
        append result "\033\[$code";
        append result $str
        append result "\033\[0m";

        return $result
    }

    proc bright str {highlight "1;29m" $str}
    proc red    str {highlight "1;31m" $str}
    proc green  str {highlight "1;32m" $str}
    proc yellow str {highlight "1;33m" $str}
}

# Here we define the procedures of Tackle proper
# =============================================

# Helper function to perform a GET request. Throws if response is not 200 OK.
#
# @param  url  URL target for the HTTP request
# @return Body of the HTTP response
proc fetch url {
    set token [::httpRedirects::geturl $url]
    set code  [::http::ncode $token]
    set data  [::http::data $token]

    if {$code ne 200} {
        error "HTTP request for $url failed."
    }

    return $data
}

# Search package index for a given package name
#
# @param  index   Dictionary of installable packages
# @param  tracker Dictionary of installed packages
# @param  query   String of what package we are looking for
# @return Void: side-effect is to print search results
proc search {index tracker {query ""}} {
    try {
        set names [dict keys $index]
    } on error msg {
        puts "[::termColor::red Error:] malformed package index."
    }

    foreach name [lsearch -inline -all $names $query*] {
        dict with index $name {
            if [dict exists $tracker $name] {
                set installed [::termColor::yellow installed]
            } else {
                set installed ""
            }

            if {$type eq "module"} {
                set hiName [::termColor::yellow $name]
            } else {
                set hiName [::termColor::green $name]
            }

            puts "$hiName [::termColor::bright v$version] $installed"
            puts "  $description"
            puts "  [string totitle $type] URL: $url"
            puts ""
        }
    }

    exit
}

# Add (i.e. install) packages
#
# @param  index   Dictionary of installable packages
# @param  tracker Dictionary of installed packages
# @param  names   List of package names to install
# @return         Updated dictionary of installed packages
proc add {index tracker names} {
    upvar 2 tacklepath destination

    set installed      [dict keys $tracker]
    set updatedTracker $tracker

    foreach name $names {
        if {$name in $installed || [file isdirectory $name]} {
            puts "$name is already installed, skipping..."
            continue
        }

        dict set updatedTracker $name [dict get $index $name]

        dict with index $name {
            file mkdir $destination
             
            set payload  [fetch $url]
            set filename [file join $destination [file tail $url]]

            set channel [open $filename wb]
            puts -nonewline $channel $payload
            close $channel

            if {$type eq "package"} {
                set unpacked [::targz::unpack $filename $destination]
                dict set updatedTracker $name path $unpacked
            } else {
                dict set updatedTracker $name path $filename
            }
            
            if {[info exists setup]} {
                exec sh -c [subst $setup]
            }

            puts "Added $type $name v$version"
            puts "from $url"
            puts "to $unpacked"
        }
    }

    return $updatedTracker
}

# Remove (i.e. uninstall) packages
#
# @param  tracker Dictionary of installed packages
# @param  names   List of package names to uninstall
# @return Updated dictionary of installed packages
proc rm {tracker names} {
    set installed      [dict keys $tracker]
    set updatedTracker $tracker

    foreach name $names {
        try {
            set path [dict get $tracker $name path]
        } on error msg {
            puts "$name is not installed, skipping..."
            continue
        }

        if {$name in $installed && [file isdirectory $path]} {
            try {
                set updatedTracker [dict remove $updatedTracker $name]
                file delete -force $path
            } on error msg {
                puts "[::termColor::red Error:] failed to remove $name."
                exit 1
            } finally {
                puts "Removed $name."
            }
        } else {
            puts "[::termColor::red Error:] tracker out of sync with packages."
            exit 1
        }
    }
    
    return $updatedTracker
}

# List installed packages
#
# @param  tracker Dictionary of installed packages
# @param  pattern Glob-style pattern of package names
# @return Void: side-effect is to print package names to the console.
proc ls {tracker pattern} {
    set names [dict keys $tracker]

    if {$names eq ""} exit

    puts [string map {" " \n} [lsearch -inline -all $names $pattern*]]

    exit
}

# Show details of an installed package
#
# @param  tracker Dictionary of installed packages
# @param  name    Name of a pattern to detail
# @return Void: side-effect is to print package details to the console.
proc show {tracker name} {
    try {
        set names [dict keys $tracker]
    } on error msg {
        puts "[::termColor::red Error:] malformed package tracker."
    }

    try {
        dict with tracker $name {
            if {$type eq "module"} {
                set hiName [::termColor::yellow $name]
            } else {
                set hiName [::termColor::green $name]
            }
            puts "$hiName [::termColor::bright v$version]"
            puts "  $description"
            puts "  [string totitle $type] URL: $url"
            puts "  Path: $path"
            puts ""
        }
    } on error msg {
        puts "[::termColor::red Error:] $name is not installed."
    }

    exit
}

# Below we handle user input, execute commands, etc.
# ==================================================

# Detect whether command-line flags are present
#
# @param  args  Command-line arguments (e.g. $argv)
# @param  flags List of flags to look for
# @return Boolean where true indicates presence of at least one flag
proc hasFlags {args flags} {
    foreach flag $flags {
        if {$flag in $args} {
            return true
        }
    }
    return false
}

# Get the record of what is installed
#
# @param  trackerFile Path to the tacker.tackle file
# @return Contents of the file
proc readTracker trackerFile {
    set channel [open $trackerFile r]
    set data    [read $channel]
    close $channel

    return $data
}

# Update our record of what is installed
#
# @param  trackerFile Path to the tacker.tackle file
# @param  data        Updated data
# @return Void. Side-effect: write data to tracker file
proc writeTracker {trackerFile data} {
    set channel [open $trackerFile w+]
    puts -nonewline $channel $data
    close $channel
}

# Get and set tracker data with operations
#
# @param  trackerFile Path to the tacker.tackle file
# @param  body        Operations to perform with tracker data
# @return Void. Side-effect: preform body and write tracker data
proc withTracker {trackerFile body} {
    try {
        set tracker [readTracker $trackerFile]
    } on error msg {
        puts "[::termColor::red Error:] could not read tracker file."
        exit 1
    }

    eval $body
    
    try {
        writeTracker $trackerFile $tracker
    } on error msg {
        puts "[::termColor::red Error:] could not write tracker file."
        exit 1
    }
}

set helpMessage [::textutil::undent [::textutil::trimEmptyHeading "
    Tackle package manager version v$version
    https://www.tacklepkg.com
    
    Usage
      tackle \[command\] \[arguments...\]
    
    Meta Options
      -h, --help     show list of command-line options
      -v, --version  show version of tackle
    
    Commands
      help           show list of command-line options
      version        show version of tackle
      search  QUERY  show packages available to install matching QUERY
      add     NAMES  install   packages by NAMES
      rm      NAMES  uninstall packages by NAMES
      ls      QUERY  show installed packages matching QUERY
      show    NAME   show details of installed package NAME
"]]

# Print help message by default
if {$argc eq 0 || [hasFlags $argv {help -h --help}]} {
    puts $helpMexsage
    exit
}

# Print version information
if {[hasFlags $argv {version -v --version}]} {
    puts $version
    exit
}

set command     [lindex $argv 0]
set arguments   [lrange $argv 1 end]
set tacklepath  [file join $::env(HOME) .local share tackle]
set trackerFile [file join $::env(HOME) .config tackle tracker.tackle]

# Create tracker file if it does not already exist.
close [open $trackerFile a]

# We don't need network or file modfication to check local state.
if {$command eq "ls" || $command eq "show"} {
    try {
        set tracker [readTracker $trackerFile]
    } on error msg {
        puts "[::termColor::red Error:] could not read tracker file."
    }

    try {
        $command $tracker $arguments
    } on error msg {
        puts "[::termColor::red Error:] could not perform $command."
    }

    exit
}

# Only search and add need to check the network.
if {$command eq "search" || $command eq "add"} {
    try {
        # Support HTTPS or HTTP requests
        ::http::register https 443 [list ::tls::socket -tls1 1]

        # Get the latest available packages
        set index [fetch \
            https://raw.githubusercontent.com/tacklepkg/packages/master/index.tackle]
    } on error msg {
        puts "[::termColor::red Error:] could not fetch package index."
        exit 1
    }

    withTracker $trackerFile {
        upvar command cmd index ind arguments args
        try {
            set tracker [$cmd $ind $tracker $args]
        } on error msg {
            puts "[::termColor::red Error:] could not perform $cmd."
            puts $msg
            exit 1
        }
    }

    exit
}

if {$command eq "rm"} {
    withTracker $trackerFile {
        upvar command cmd arguments args
        try {
            set tracker [$cmd $tracker $args]
        } on error msg {
            puts "[::termColor::red Error:] could not perform $cmd."
            puts $msg
            exit 1
        }
    }

    exit
}

puts $helpMessage
return
tackle.vfs/main.tcl                                                                                 100664  1751    1751    77          14144020733 17237   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        lappend auto_path [file join [file dirname [info script]] lib]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 tackle.vfs/lib/http/pkgIndex.tcl                                                                    100664  1751    1751    212         14144020733 21620   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        if {![package vsatisfies [package provide Tcl] 8.2]} {return}
package ifneeded autoproxy 1.7 [list source [file join $dir autoproxy.tcl]]
                                                                                                                                                                                                                                                                                                                                                                                      tackle.vfs/lib/http/autoproxy.tcl                                                                   100664  1751    1751    50000       14144020733 22161   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # autoproxy.tcl - Copyright (C) 2002-2008, 2017 Pat Thoyts <patthoyts@users.sf.net>
#
# On Unix the standard for identifying the local HTTP proxy server
# seems to be to use the environment variable http_proxy or ftp_proxy and
# no_proxy to list those domains to be excluded from proxying.
#
# On Windows we can retrieve the Internet Settings values from the registry
# to obtain pretty much the same information.
#
# With this information we can setup a suitable filter procedure for the
# Tcl http package and arrange for automatic use of the proxy.
#
# Example:
#   package require autoproxy
#   autoproxy::init
#   set tok [http::geturl http://wiki.tcl.tk/]
#   http::data $tok
#
# To support https add:
#   package require tls
#   http::register https 443 ::autoproxy::tls_socket

package require Tcl 8.5 ;# ni/in operators
package require http;                   # tcl
package require uri;                    # tcllib
package require base64;                 # tcllib

namespace eval ::autoproxy {
    variable options

    if {! [info exists options]} {
        array set options {
            proxy_host ""
            proxy_port 80
            no_proxy   {}
            basic      {}
            authProc   {}
            tls_package tls
        }
    }

    variable uid
    if {![info exists uid]} { set uid 0 }

    variable winregkey
    set winregkey [join {
        HKEY_CURRENT_USER
        Software Microsoft Windows
        CurrentVersion "Internet Settings"
    } \\]
}

# -------------------------------------------------------------------------
# Description:
#   Obtain configuration options for the server.
#
proc ::autoproxy::cget {option} {
    variable options
    switch -glob -- $option {
        -host -
        -proxy_h* { set options(proxy_host) }
        -port -
        -proxy_p* { set options(proxy_port) }
        -no*      { set options(no_proxy) }
        -basic    { set options(basic) }
        -authProc { set options(authProc) }
        -tls_package { set options(tls_package) }
        default {
            set err [join [lsort [array names options]] ", -"]
            return -code error "bad option \"$option\":\
                       must be one of -$err"
        }
    }
}

# -------------------------------------------------------------------------
# Description:
#  Configure the autoproxy package settings.
#  You may only configure one type of authorisation at a time as once we hit
#  -basic, -digest or -ntlm - all further args are passed to the protocol
#  specific script.
#
#  Of course, most of the point of this package is to fill as many of these
#  fields as possible automatically. You should call autoproxy::init to
#  do automatic configuration and then call this method to refine the details.
#
proc ::autoproxy::configure {args} {
    variable options

    if {[llength $args] == 0} {
        foreach {opt value} [array get options] {
            lappend r -$opt $value
        }
        return $r
    }

    while {[string match "-*" [set option [lindex $args 0]]]} {
        switch -glob -- $option {
            -host -
            -proxy_h* { set options(proxy_host) [Pop args 1]}
            -port -
            -proxy_p* { set options(proxy_port) [Pop args 1]}
            -no*      { set options(no_proxy) [Pop args 1] }
            -basic    { Pop args; configure:basic $args ; break }
            -authProc { set options(authProc) [Pop args 1] }
            -tls_package {
                set tls_package [Pop args 1]
                if {$tls_package ni {tls twapi}} {
                    error "Invalid TLS package option '$tls_package'. Must be 'tls' or 'twapi'"
                }
                set options(tls_package) $tls_package
            }
            --        { Pop args; break }
            default {
                set opts [join [lsort [array names options]] ", -"]
                return -code error "bad option \"$option\":\
                       must be one of -$opts"
            }
        }
        Pop args
    }
}

# -------------------------------------------------------------------------
# Description:
#  Initialise the http proxy information from the environment or the
#  registry (Win32)
#
#  This procedure will load the http package and re-writes the
#  http::geturl method to add in the authorisation header.
#
#  A better solution will be to arrange for the http package to request the
#  authorisation key on receiving an authorisation reqest.
#
proc ::autoproxy::init {{httpproxy {}} {no_proxy {}}} {
    global tcl_platform
    global env
    variable winregkey
    variable options

    # Look for standard environment variables.
    if {[string length $httpproxy] > 0} {

        # nothing to do

    } elseif {[info exists env(http_proxy)]} {
        set httpproxy $env(http_proxy)
        if {[info exists env(no_proxy)]} {
            set no_proxy $env(no_proxy)
        }
    } else {
        if {$tcl_platform(platform) == "windows"} {
            #checker -scope block exclude nonPortCmd
            package require registry 1.0
            array set reg {ProxyEnable 0 ProxyServer "" ProxyOverride {}}
            catch {
                # IE5 changed ProxyEnable from a binary to a dword value.
                switch -exact -- [registry type $winregkey "ProxyEnable"] {
                    dword {
                        set reg(ProxyEnable) [registry get $winregkey "ProxyEnable"]
                    }
                    binary {
                        set v [registry get $winregkey "ProxyEnable"]
                        binary scan $v i reg(ProxyEnable)
                    }
                    default {
                        return -code error "unexpected type found for\
                               ProxyEnable registry item"
                    }
                }
                set reg(ProxyServer) [GetWin32Proxy http]
                set reg(ProxyOverride) [registry get $winregkey "ProxyOverride"]
            }
            if {![string is bool $reg(ProxyEnable)]} {
                set reg(ProxyEnable) 0
            }
            if {$reg(ProxyEnable)} {
                set httpproxy $reg(ProxyServer)
                set no_proxy  $reg(ProxyOverride)
            }
        }
    }

    # If we found something ...
    if {[string length $httpproxy] > 0} {
        # The http_proxy is supposed to be a URL - lets make sure.
        if {![regexp {\w://.*} $httpproxy]} {
            set httpproxy "http://$httpproxy"
        }

        # decompose the string.
        array set proxy [uri::split $httpproxy]

        # turn the no_proxy value into a tcl list
        set no_proxy [string map {; " " , " "} $no_proxy]

        # configure ourselves
        configure -proxy_host $proxy(host) \
            -proxy_port $proxy(port) \
            -no_proxy $no_proxy

        # Lift the authentication details from the environment if present.
        if {[string length $proxy(user)] < 1 \
                && [info exists env(http_proxy_user)] \
                && [info exists env(http_proxy_pass)]} {
            set proxy(user) $env(http_proxy_user)
            set proxy(pwd)  $env(http_proxy_pass)
        }

        # Maybe the proxy url has authentication parameters?
        # At this time, only Basic is supported.
        if {[string length $proxy(user)] > 0} {
            configure -basic -username $proxy(user) -password $proxy(pwd)
        }

        # setup and configure the http package to use our proxy info.
        http::config -proxyfilter [namespace origin filter]
    }
    return $httpproxy
}

# autoproxy::GetWin32Proxy --
#
#	Parse the Windows Internet Settings registry key and return the
#	protocol proxy requested. If the same proxy is in use for all
#	protocols, then that will be returned. Otherwise the string is
#	parsed. Example:
#	 ftp=proxy:80;http=proxy:80;https=proxy:80
#
proc ::autoproxy::GetWin32Proxy {protocol} {
    variable winregkey
    #checker exclude nonPortCmd
    set proxies [split [registry get $winregkey "ProxyServer"] ";"]
    foreach proxy $proxies {
        if {[string first = $proxy] == -1} {
            return $proxy
        } else {
            foreach {prot host} [split $proxy =] break
            if {[string compare $protocol $prot] == 0} {
                return $host
            }
        }
    }
    return -code error "failed to identify an '$protocol' proxy"
}

# -------------------------------------------------------------------------
# Description:
#  Pop the nth element off a list. Used in options processing.
proc ::autoproxy::Pop {varname {nth 0}} {
    upvar $varname args
    set r [lindex $args $nth]
    set args [lreplace $args $nth $nth]
    return $r
}

# -------------------------------------------------------------------------
# Description
#   An example user authentication procedure.
# Returns:
#   A two element list consisting of the users authentication id and
#   password.
proc ::autoproxy::defAuthProc {{user {}} {passwd {}} {realm {}}} {
    if {[string length $realm] > 0} {
        set title "Realm: $realm"
    } else {
        set title {}
    }

    # If you are using BWidgets then the following will do:
    #
    #    package require BWidget
    #    return [PasswdDlg .defAuthDlg -parent {} -transient 0 \
    #         -title $title -logintext $user -passwdtext $passwd]
    #
    # if you just have Tk and no BWidgets --

    set dlg [toplevel .autoproxy_defAuthProc -class Dialog]
    wm title $dlg $title
    wm withdraw $dlg
    label $dlg.ll -text Login -underline 0 -anchor w
    entry $dlg.le -textvariable [namespace current]::${dlg}:l
    label $dlg.pl -text Password -underline 0 -anchor w
    entry $dlg.pe -show * -textvariable [namespace current]::${dlg}:p
    button $dlg.ok -text OK -default active -width -11 \
        -command [list set [namespace current]::${dlg}:ok 1]
    grid $dlg.ll $dlg.le -sticky news
    grid $dlg.pl $dlg.pe -sticky news
    grid $dlg.ok - -sticky e
    grid columnconfigure $dlg 1 -weight 1
    bind $dlg <Return> [list $dlg.ok invoke]
    bind $dlg <Alt-l> [list focus $dlg.le]
    bind $dlg <Alt-p> [list focus $dlg.pe]
    variable ${dlg}:l $user; variable ${dlg}:p $passwd
    variable ${dlg}:ok 0
    wm deiconify $dlg; focus $dlg.pe; update idletasks
    set old [::grab current]; grab $dlg
    tkwait variable [namespace current]::${dlg}:ok
    grab release $dlg ; if {[llength $old] > 0} {::grab $old}
    set r [list [set ${dlg}:l] [set ${dlg}:p]]
    unset ${dlg}:l; unset ${dlg}:p; unset ${dlg}:ok
    destroy $dlg
    return $r
}

# -------------------------------------------------------------------------

# Description:
#  Implement support for the Basic authentication scheme (RFC 1945,2617).
# Options:
#  -user userid  - pass in the user ID (May require Windows NT domain
#                  as DOMAIN\\username)
#  -password pwd - pass in the user's password.
#  -realm realm  - pass in the http realm.
#
proc ::autoproxy::configure:basic {arglist} {
    variable options
    array set opts {user {} passwd {} realm {}}
    foreach {opt value} $arglist {
        switch -glob -- $opt {
            -u* { set opts(user) $value}
            -p* { set opts(passwd) $value}
            -r* { set opts(realm) $value}
            --  { break }
            default {
                return -code error "invalid option \"$opt\": must be one of\
                     -username or -password or -realm"
            }
        }
    }

    # If nothing was provided, try calling the authProc
    if {$options(authProc) != {} \
            && ($opts(user) == {} || $opts(passwd) == {})} {
        set r [$options(authProc) $opts(user) $opts(passwd) $opts(realm)]
        set opts(user) [lindex $r 0]
        set opts(passwd) [lindex $r 1]
    }

    if {$opts(user) eq ""} {
        set options(basic) ""
    } else {
        # Store the encoded string to avoid re-encoding all the time.
        set options(basic) [list "Proxy-Authorization" \
                                [concat "Basic" \
                                     [base64::encode $opts(user):$opts(passwd)]]]
    }
    return
}

# -------------------------------------------------------------------------
# Description:
#  An http package proxy filter. This attempts to work out if a request
#  should go via the configured proxy using a glob comparison against the
#  no_proxy list items. A typical no_proxy list might be
#   [list localhost *.my.domain.com 127.0.0.1]
#
#  If we are going to use the proxy - then insert the proxy authorization
#  header.
#
proc ::autoproxy::filter {host} {
    variable options

    if {$options(proxy_host) == {}} {
        return {}
    }

    foreach domain $options(no_proxy) {
        if {[string match $domain $host]} {
            return {}
        }
    }

    # Add authorisation header to the request (by Anders Ramdahl)
    catch {
        upvar state State
        if {$options(basic) != {}} {
            set State(-headers) [concat $options(basic) $State(-headers)]
        }
    }
    return [list $options(proxy_host) $options(proxy_port)]
}

# -------------------------------------------------------------------------
# autoproxy::tls_connect --
#
#	Create a connection to a remote machine through a proxy
#	if necessary. This is used by the tls_socket command for
#	use with the http package but can also be used more generally
#	provided your proxy will permit CONNECT attempts to ports
#	other than port 443 (many will not).
#	This command defers to 'tunnel_connect' to link to the target
#	host and then upgrades the link to SSL/TLS
#
proc ::autoproxy::tls_connect {args} {
    variable options
    set peersubject [lindex $args end-1]
    if {[string length $options(proxy_host)] > 0} {
        set s [eval [linsert $args 0 tunnel_connect]]
        fconfigure $s -blocking 1 -buffering none -translation binary
        if {[string equal "-async" [lindex $args end-2]]} {
            if {$options(tls_package) eq "twapi"} {
                set s [eval [linsert [lrange $args 0 end-3] 0 ::twapi::starttls $s -peersubject $peersubject]]
            } else {
                eval [linsert [lrange $args 0 end-3] 0 ::tls::import $s]
            }
        } else {
            if {$options(tls_package) eq "twapi"} {
                set s [eval [linsert [lrange $args 0 end-2] 0 ::twapi::starttls $s -peersubject $peersubject]]
            } else {
                eval [linsert [lrange $args 0 end-2] 0 ::tls::import $s]
            }
        }
    } else {
        if {$options(tls_package) eq "twapi"} {
            set s [eval [linsert $args 0 ::twapi::tls_socket]]
        } else {
            set s [eval [linsert $args 0 ::tls::socket]]
        }
    }
    return $s
}

# autoproxy::tunnel_connect --
#
#	Create a connection to a remote machine through a proxy
#	if necessary. This is used by the tls_socket command for
#	use with the http package but can also be used more generally
#	provided your proxy will permit CONNECT attempts to ports
#	other than port 443 (many will not).
#	Note: this command just opens the socket through the proxy to
#	the target machine -- no SSL/TLS negotiation is done yet.
#
proc ::autoproxy::tunnel_connect {args} {
    variable options
    variable uid
    set code ok

    # args = ... host port
    # and the host/port is the actual endpoint we want to talk to,
    # regardless of any proxying. See our caller tls_connect for
    # ensuring this by peeking into the http package internals.

    # To handle proxying properly we have to run through 'filter'
    # (again), to ensure that proxy exceptions are correctly taken
    # into account.

    set proxy [filter [lindex $args end-1]]

    if {[llength $proxy]} {
        foreach {proxy_host proxy_port} $proxy break

        set token [namespace current]::[incr uid]
        upvar #0 $token state
        set state(endpoint) [lrange $args end-1 end]
        set state(state) connect
        set state(data) ""
        set state(useragent) [http::config -useragent]
        set state(sock) [::socket $proxy_host $proxy_port]
        fileevent $state(sock) writable [namespace code [list tunnel_write $token]]
        vwait [set token](state)

        if {[string length $state(error)] > 0} {
            set result $state(error)
            close $state(sock)
            unset state
            set code error
        } elseif {[info exists state(code)] &&
                  (($state(code) >= 300) ||
                   ($state(code) < 200))} {
            set result [lindex $state(headers) 0]
            regexp {HTTP/\d.\d\s+\d+\s+(.*)} $result -> result
            close $state(sock)
            set code error
        } else {
            set result $state(sock)
        }
        unset state
    } else {
        set result [eval [linsert $args 0 ::socket]]
    }
    return -code $code $result
}

proc ::autoproxy::tunnel_write {token} {
    upvar #0 $token state
    variable options
    fileevent $state(sock) writable {}
    if {[catch {set state(error) [fconfigure $state(sock) -error]} err]} {
        set state(error) $err
    }
    if {[string length $state(error)] > 0} {
        set state(state) error
        return
    }
    fconfigure $state(sock) -blocking 0 -buffering line -translation crlf
    foreach {host port} $state(endpoint) break
    puts $state(sock) "CONNECT $host:$port HTTP/1.1"
    puts $state(sock) "Host: $host"
    if {[string length $state(useragent)] > 0} {
        puts $state(sock) "User-Agent: $state(useragent)"
    }
    puts $state(sock) "Proxy-Connection: keep-alive"
    puts $state(sock) "Connection: keep-alive"
    if {[string length $options(basic)] > 0} {
        puts $state(sock) [join $options(basic) ": "]
    }
    puts $state(sock) ""

    fileevent $state(sock) readable [namespace code [list tunnel_read $token]]
    return
}

proc ::autoproxy::tunnel_read {token} {
    upvar #0 $token state
    set len [gets $state(sock) line]
    if {[eof $state(sock)]} {
        fileevent $state(sock) readable {}
        set state(state) eof
    } elseif {$len == 0} {
        set state(code) [lindex [split [lindex $state(headers) 0] { }] 1]
        fileevent $state(sock) readable {}
        set state(state) ok
    } else {
        lappend state(headers) $line
    }
}

# autoproxy::tls_socket --
#
#	This can be used to handle TLS connections independently of
#	proxy presence. It can only be used with the Tcl http package
#	and to use it you must do:
#	   http::register https 443 ::autoproxy::tls_socket
#	After that you can use the http::geturl command to access
#	secure web pages and any proxy details will be handled for you.
#
proc ::autoproxy::tls_socket {args} {
    variable options

    # Look into the http package for the actual target. If a proxy is in use then
    # The function appends the proxy host and port and not the target.

    upvar host uhost port uport
    set args [lrange $args 0 end-2]
    lappend args $uhost $uport

    set s [eval [linsert $args 0 tls_connect]]

    # record the tls connection status in the http state array.
    upvar state state

    if {$options(tls_package) eq "twapi"} {
        # With twapi::tls_socket, state may not be available on
        # an async connect until negotiation is completed.
        set state(tls_status) ""
        set security_context [fconfigure $s -context]
        if {$security_context ne ""} {
            set cert [twapi::sspi_remote_cert $security_context]
            set cert_info [twapi::cert_info $cert]
            twapi::cert_release $cert
            dict set state(tls_status) issuer [dict get $cert_info -issuer]
            dict set state(tls_status) subject [dict get $cert_info -subject]
            dict set state(tls_status) notBefore [dict get $cert_info -start]
            dict set state(tls_status) notAfter [dict get $cert_info -end]
            # Note: binary encode hex was not available in older Tcl, use twapi::hex
            dict set state(tls_status) serial [twapi::hex [dict get $cert_info -serialnumber]]
            # TBD - dict set state(tls_status) cipher
            # TBD - dict set state(tls_status) sbits
        }
    } else {
        tls::handshake $s
        set state(tls_status) [tls::status $s]
    }

    return $s
}

# -------------------------------------------------------------------------

package provide autoproxy 1.7

# -------------------------------------------------------------------------
#
# Local variables:
#   mode: tcl
#   indent-tabs-mode: nil
# End:
tackle.vfs/lib/tar/pkgIndex.tcl                                                                     100664  1751    1751    234         14144020733 21433   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        if {![package vsatisfies [package provide Tcl] 8.4]} {
    # PRAGMA: returnok
    return
}
package ifneeded tar 0.11 [list source [file join $dir tar.tcl]]
                                                                                                                                                                                                                                                                                                                                                                    tackle.vfs/lib/tar/tar.tcl                                                                          100664  1751    1751    40550       14144020733 20515   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # tar.tcl --
#
#       Creating, extracting, and listing posix tar archives
#
# Copyright (c) 2004    Aaron Faupell <afaupell@users.sourceforge.net>
# Copyright (c) 2013    Andreas Kupries <andreas_kupries@users.sourceforge.net>
#                       (GNU tar @LongLink support).
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# RCS: @(#) $Id: tar.tcl,v 1.17 2012/09/11 17:22:24 andreas_kupries Exp $

package require Tcl 8.4
package provide tar 0.11

namespace eval ::tar {}

proc ::tar::parseOpts {acc opts} {
    array set flags $acc
    foreach {x y} $acc {upvar $x $x}
    
    set len [llength $opts]
    set i 0
    while {$i < $len} {
        set name [string trimleft [lindex $opts $i] -]
        if {![info exists flags($name)]} {
	    return -errorcode {TAR INVALID OPTION} \
		-code error "unknown option \"$name\""
	}
        if {$flags($name) == 1} {
            set $name [lindex $opts [expr {$i + 1}]]
            incr i $flags($name)
        } elseif {$flags($name) > 1} {
            set $name [lrange $opts [expr {$i + 1}] [expr {$i + $flags($name)}]]
            incr i $flags($name)
        } else {
            set $name 1
        }
        incr i
    }
}

proc ::tar::pad {size} {
    set pad [expr {512 - ($size % 512)}]
    if {$pad == 512} {return 0}
    return $pad
}

proc ::tar::seekorskip {ch off wh} {
    if {[tell $ch] < 0} {
	if {$wh!="current"} {
	    return -code error -errorcode [list TAR INVALID WHENCE $wh] \
		"WHENCE=$wh not supported on non-seekable channel $ch"
	}
	skip $ch $off
	return
    }
    seek $ch $off $wh
    return
}

proc ::tar::skip {ch skipover} {
    while {$skipover > 0} {
	set requested $skipover

	# Limit individual skips to 64K, as a compromise between speed
	# of skipping (Number of read requests), and memory usage
	# (Note how skipped block is read into memory!). While the
	# read data is immediately discarded it still generates memory
	# allocation traffic, gets copied, etc. Trying to skip the
	# block in one go without the limit may cause us to run out of
	# (virtual) memory, or just induce swapping, for nothing.

	if {$requested > 65536} {
	    set requested 65536
	}

	set skipped [string length [read $ch $requested]]

	# Stop in short read into the end of the file.
	if {!$skipped && [eof $ch]} break

	# Keep track of how much is (not) skipped yet.
	incr skipover -$skipped
    }
    return
}

proc ::tar::readHeader {data} {
    binary scan $data a100a8a8a8a12a12a8a1a100a6a2a32a32a8a8a155 \
                      name mode uid gid size mtime cksum type \
                      linkname magic version uname gname devmajor devminor prefix

    foreach x {name type linkname} {
        set $x [string trim [set $x] "\x00"]
    }
    foreach x {uid gid size mtime cksum} {
        set $x [format %d 0[string trim [set $x] " \x00"]]
    }
    set mode [string trim $mode " \x00"]

    if {$magic == "ustar "} {
        # gnu tar
        # not fully supported
        foreach x {uname gname prefix} {
            set $x [string trim [set $x] "\x00"]
        }
        foreach x {devmajor devminor} {
            set $x [format %d 0[string trim [set $x] " \x00"]]
        }
    } elseif {$magic == "ustar\x00"} {
        # posix tar
        foreach x {uname gname prefix} {
            set $x [string trim [set $x] "\x00"]
        }
        foreach x {devmajor devminor} {
            set $x [format %d 0[string trim [set $x] " \x00"]]
        }
    } else {
        # old style tar
        foreach x {uname gname devmajor devminor prefix} { set $x {} }
        if {$type == ""} {
            if {[string match */ $name]} {
                set type 5
            } else {
                set type 0
            }
        }
    }

    return [list name $name mode $mode uid $uid gid $gid size $size mtime $mtime \
                 cksum $cksum type $type linkname $linkname magic $magic \
                 version $version uname $uname gname $gname devmajor $devmajor \
                 devminor $devminor prefix $prefix]
}

proc ::tar::contents {file args} {
    set chan 0
    parseOpts {chan 0} $args
    if {$chan} {
	set fh $file
    } else {
	set fh [::open $file]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    set ret {}
    while {![eof $fh]} {
        array set header [readHeader [read $fh 512]]
	HandleLongLink $fh header
        if {$header(name) == ""} break
	if {$header(prefix) != ""} {append header(prefix) /}
        lappend ret $header(prefix)$header(name)
        seekorskip $fh [expr {$header(size) + [pad $header(size)]}] current
    }
    if {!$chan} {
	close $fh
    }
    return $ret
}

proc ::tar::stat {tar {file {}} args} {
    set chan 0
    parseOpts {chan 0} $args
    if {$chan} {
	set fh $tar
    } else {
	set fh [::open $tar]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    set ret {}
    while {![eof $fh]} {
        array set header [readHeader [read $fh 512]]
	HandleLongLink $fh header
        if {$header(name) == ""} break
	if {$header(prefix) != ""} {append header(prefix) /}
        seekorskip $fh [expr {$header(size) + [pad $header(size)]}] current
        if {$file != "" && "$header(prefix)$header(name)" != $file} {continue}
        set header(type) [string map {0 file 5 directory 3 characterSpecial 4 blockSpecial 6 fifo 2 link} $header(type)]
        set header(mode) [string range $header(mode) 2 end]
        lappend ret $header(prefix)$header(name) [list mode $header(mode) uid $header(uid) gid $header(gid) \
                    size $header(size) mtime $header(mtime) type $header(type) linkname $header(linkname) \
                    uname $header(uname) gname $header(gname) devmajor $header(devmajor) devminor $header(devminor)]
    }
    if {!$chan} {
	close $fh
    }
    return $ret
}

proc ::tar::get {tar file args} {
    set chan 0
    parseOpts {chan 0} $args
    if {$chan} {
	set fh $tar
    } else {
	set fh [::open $tar]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    while {![eof $fh]} {
	set data [read $fh 512]
        array set header [readHeader $data]
	HandleLongLink $fh header
        if {$header(name) eq ""} break
	if {$header(prefix) ne ""} {append header(prefix) /}
        set name [string trimleft $header(prefix)$header(name) /]
        if {$name eq $file} {
            set file [read $fh $header(size)]
            if {!$chan} {
		close $fh
	    }
            return $file
        }
        seekorskip $fh [expr {$header(size) + [pad $header(size)]}] current
    }
    if {!$chan} {
	close $fh
    }
    return -code error -errorcode {TAR MISSING FILE} \
	"Tar \"$tar\": File \"$file\" not found"
}

proc ::tar::untar {tar args} {
    set nooverwrite 0
    set data 0
    set nomtime 0
    set noperms 0
    set chan 0
    parseOpts {dir 1 file 1 glob 1 nooverwrite 0 nomtime 0 noperms 0 chan 0} $args
    if {![info exists dir]} {set dir [pwd]}
    set pattern *
    if {[info exists file]} {
        set pattern [string map {* \\* ? \\? \\ \\\\ \[ \\\[ \] \\\]} $file]
    } elseif {[info exists glob]} {
        set pattern $glob
    }

    set ret {}
    if {$chan} {
	set fh $tar
    } else {
	set fh [::open $tar]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    while {![eof $fh]} {
        array set header [readHeader [read $fh 512]]
	HandleLongLink $fh header
        if {$header(name) == ""} break
	if {$header(prefix) != ""} {append header(prefix) /}
        set name [string trimleft $header(prefix)$header(name) /]
        if {![string match $pattern $name] || ($nooverwrite && [file exists $name])} {
            seekorskip $fh [expr {$header(size) + [pad $header(size)]}] current
            continue
        }

        set name [file join $dir $name]
        if {![file isdirectory [file dirname $name]]} {
            file mkdir [file dirname $name]
            lappend ret [file dirname $name] {}
        }
        if {[string match {[0346]} $header(type)]} {
            if {[catch {::open $name w+} new]} {
                # sometimes if we dont have write permission we can still delete
                catch {file delete -force $name}
                set new [::open $name w+]
            }
            fconfigure $new -encoding binary -translation lf -eofchar {}
            fcopy $fh $new -size $header(size)
            close $new
            lappend ret $name $header(size)
        } elseif {$header(type) == 5} {
            file mkdir $name
            lappend ret $name {}
        } elseif {[string match {[12]} $header(type)] && $::tcl_platform(platform) == "unix"} {
            catch {file delete $name}
            if {![catch {file link [string map {1 -hard 2 -symbolic} $header(type)] $name $header(linkname)}]} {
                lappend ret $name {}
            }
        }
        seekorskip $fh [pad $header(size)] current
        if {![file exists $name]} continue

        if {$::tcl_platform(platform) == "unix"} {
            if {!$noperms} {
                catch {file attributes $name -permissions 0[string range $header(mode) 2 end]}
            }
            catch {file attributes $name -owner $header(uid) -group $header(gid)}
            catch {file attributes $name -owner $header(uname) -group $header(gname)}
        }
        if {!$nomtime} {
            file mtime $name $header(mtime)
        }
    }
    if {!$chan} {
	close $fh
    }
    return $ret
}

## 
 # ::tar::statFile
 # 
 # Returns stat info about a filesystem object, in the form of an info 
 # dictionary like that returned by ::tar::readHeader.
 # 
 # The mode, uid, gid, mtime, and type entries are always present. 
 # The size and linkname entries are present if relevant for this type 
 # of object. The uname and gname entries are present if the OS supports 
 # them. No devmajor or devminor entry is present.
 ##

proc ::tar::statFile {name followlinks} {
    if {$followlinks} {
        file stat $name stat
    } else {
        file lstat $name stat
    }
    
    set ret {}
    
    if {$::tcl_platform(platform) == "unix"} {
        lappend ret mode 1[file attributes $name -permissions]
        lappend ret uname [file attributes $name -owner]
        lappend ret gname [file attributes $name -group]
        if {$stat(type) == "link"} {
            lappend ret linkname [file link $name]
        }
    } else {
        lappend ret mode [lindex {100644 100755} [expr {$stat(type) == "directory"}]]
    }
    
    lappend ret  uid $stat(uid)  gid $stat(gid)  mtime $stat(mtime) \
      type $stat(type)
    
    if {$stat(type) == "file"} {lappend ret size $stat(size)}
    
    return $ret
}

## 
 # ::tar::formatHeader
 # 
 # Opposite operation to ::tar::readHeader; takes a file name and info 
 # dictionary as arguments, returns a corresponding (POSIX-tar) header.
 # 
 # The following dictionary entries must be present:
 #   mode
 #   type
 # 
 # The following dictionary entries are used if present, otherwise 
 # the indicated default is used:
 #   uid       0
 #   gid       0
 #   size      0
 #   mtime     [clock seconds]
 #   linkname  {}
 #   uname     {}
 #   gname     {}
 #   
 # All other dictionary entries, including devmajor and devminor, are 
 # presently ignored.
 ##

proc ::tar::formatHeader {name info} {
    array set A {
        linkname ""
        uname ""
        gname ""
        size 0
        gid  0
        uid  0
    }
    set A(mtime) [clock seconds]
    array set A $info
    array set A {devmajor "" devminor ""}

    set type [string map {file 0 directory 5 characterSpecial 3 \
      blockSpecial 4 fifo 6 link 2 socket A} $A(type)]
    
    set osize  [format %o $A(size)]
    set ogid   [format %o $A(gid)]
    set ouid   [format %o $A(uid)]
    set omtime [format %o $A(mtime)]
    
    set name [string trimleft $name /]
    if {[string length $name] > 255} {
        return -code error -errorcode {TAR BAD PATH LENGTH} \
	    "path name over 255 chars"
    } elseif {[string length $name] > 100} {
	set common [string range $name end-99 154]
	if {[set splitpoint [string first / $common]] == -1} {
	    return -code error -errorcode {TAR BAD PATH UNSPLITTABLE} \
		"path name cannot be split into prefix and name"
	}
	set prefix [string range $name 0 end-100][string range $common 0 $splitpoint-1]
	set name   [string range $common $splitpoint+1 end][string range $name 155 end]
    } else {
        set prefix ""
    }

    set header [binary format a100A8A8A8A12A12A8a1a100A6a2a32a32a8a8a155a12 \
                              $name $A(mode)\x00 $ouid\x00 $ogid\x00\
                              $osize\x00 $omtime\x00 {} $type \
                              $A(linkname) ustar\x00 00 $A(uname) $A(gname)\
                              $A(devmajor) $A(devminor) $prefix {}]

    binary scan $header c* tmp
    set cksum 0
    foreach x $tmp {incr cksum $x}

    return [string replace $header 148 155 [binary format A8 [format %o $cksum]\x00]]
}


proc ::tar::recurseDirs {files followlinks} {
    foreach x $files {
        if {[file isdirectory $x] && ([file type $x] != "link" || $followlinks)} {
            if {[set more [glob -dir $x -nocomplain *]] != ""} {
                eval lappend files [recurseDirs $more $followlinks]
            } else {
                lappend files $x
            }
        }
    }
    return $files
}

proc ::tar::writefile {in out followlinks name} {
     puts -nonewline $out [formatHeader $name [statFile $in $followlinks]]
     set size 0
     if {[file type $in] == "file" || ($followlinks && [file type $in] == "link")} {
         set in [::open $in]
         fconfigure $in -encoding binary -translation lf -eofchar {}
         set size [fcopy $in $out]
         close $in
     }
     puts -nonewline $out [string repeat \x00 [pad $size]]
}

proc ::tar::create {tar files args} {
    set dereference 0
    set chan 0
    parseOpts {dereference 0 chan 0} $args

    if {$chan} {
	set fh $tar
    } else {
	set fh [::open $tar w+]
	fconfigure $fh -encoding binary -translation lf -eofchar {}
    }
    foreach x [recurseDirs $files $dereference] {
        writefile $x $fh $dereference $x
    }
    puts -nonewline $fh [string repeat \x00 1024]

    if {!$chan} {
	close $fh
    }
    return $tar
}

proc ::tar::add {tar files args} {
    set dereference 0
    set prefix ""
    set quick 0
    parseOpts {dereference 0 prefix 1 quick 0} $args
    
    set fh [::open $tar r+]
    fconfigure $fh -encoding binary -translation lf -eofchar {}
    
    if {$quick} then {
        seek $fh -1024 end
    } else {
        set data [read $fh 512]
        while {[regexp {[^\0]} $data]} {
            array set header [readHeader $data]
            seek $fh [expr {$header(size) + [pad $header(size)]}] current
            set data [read $fh 512]
        }
        seek $fh -512 current
    }

    foreach x [recurseDirs $files $dereference] {
        writefile $x $fh $dereference $prefix$x
    }
    puts -nonewline $fh [string repeat \x00 1024]

    close $fh
    return $tar
}

proc ::tar::remove {tar files} {
    set n 0
    while {[file exists $tar$n.tmp]} {incr n}
    set tfh [::open $tar$n.tmp w]
    set fh [::open $tar r]

    fconfigure $fh  -encoding binary -translation lf -eofchar {}
    fconfigure $tfh -encoding binary -translation lf -eofchar {}

    while {![eof $fh]} {
        array set header [readHeader [read $fh 512]]
        if {$header(name) == ""} {
            puts -nonewline $tfh [string repeat \x00 1024]
            break
        }
	if {$header(prefix) != ""} {append header(prefix) /}
        set name $header(prefix)$header(name)
        set len [expr {$header(size) + [pad $header(size)]}]
        if {[lsearch $files $name] > -1} {
            seek $fh $len current
        } else {
            seek $fh -512 current
            fcopy $fh $tfh -size [expr {$len + 512}]
        }
    }

    close $fh
    close $tfh

    file rename -force $tar$n.tmp $tar
}

proc ::tar::HandleLongLink {fh hv} {
    upvar 1 $hv header thelongname thelongname

    # @LongName Part I.
    if {$header(type) == "L"} {
	# Size == Length of name. Read it, and pad to full 512
	# size.  After that is a regular header for the actual
	# file, where we have to insert the name. This is handled
	# by the next iteration and the part II below.
	set thelongname [string trimright [read $fh $header(size)] \000]
	seekorskip $fh [pad $header(size)] current
	return -code continue
    }
    # Not supported yet: type 'K' for LongLink (long symbolic links).

    # @LongName, part II, get data from previous entry, if defined.
    if {[info exists thelongname]} {
	set header(name) $thelongname
	# Prevent leakage to further entries.
	unset thelongname
    }

    return
}
                                                                                                                                                        tackle.vfs/lib/tcltls1.7.20/pkgIndex.tcl                                                            100664  1751    1751    725         14144020733 22625   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        if {[package vsatisfies [package present Tcl] 8.5]} {
	package ifneeded tls 1.7.20 [list apply {{dir} {
		if {{shared} eq "static"} {
			load {} Tls
		} else {
			load [file join $dir tcltls.so] Tls
		}

		set tlsTclInitScript [file join $dir tls.tcl]
		if {[file exists $tlsTclInitScript]} {
			source $tlsTclInitScript
		}
	}} $dir]
} elseif {[package vsatisfies [package present Tcl] 8.4]} {
	package ifneeded tls 1.7.20 [list load [file join $dir tcltls.so] Tls]
}
                                           tackle.vfs/lib/tcltls1.7.20/tcltls.so                                                               100664  1751    1751    156570      14144020733 22312   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        ELF          >    7      @                 @ 8 	 @                                 X'      X'                    0       0       0      Z      Z                                        ;      ;                   p      p      p             	                                                              8      8      8      $       $              Ptd                     d      d             Qtd                                                  Rtd   p      p      p                                  GNU @AY;Mt@w                                                                              S                                          S                                          b                     H                                          {                                          &                                          \                                          _                     [                                                                                      z                                                                                     >                     :                     z                                                                                                                                @                                                                 3                                                                                                           {                     .                                          ,                                            D                                          F   "                                                             u                                          ^                     B                                                                                    ?                                                                                                                              Y                                                               1                     t                                          J                     8                     H                                                                                    U                                                               U                      t                     2                                                                                     (                     	                     +                                                                                     P                                          :                     6                                                                                                                                                   k                                          f                                           n                     "                     `                                                                                    o                                                                                                                                                                        L                                                                                                                                w                                          X                                              pm      \       __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize __stack_chk_fail SSL_get_certificate SSL_get_current_cipher SSL_CIPHER_get_bits SSL_CIPHER_get_name SSL_get_peer_certificate X509_free SSL_get_ex_data SSL_state_string_long SSL_alert_desc_string_long SSL_get_ex_data_X509_STORE_CTX_idx X509_STORE_CTX_get_ex_data X509_STORE_CTX_get_current_cert X509_STORE_CTX_get_error_depth X509_STORE_CTX_get_error X509_verify_cert_error_string strncpy strlen ERR_get_error ERR_reason_error_string SSL_CTX_free TLSv1_2_method SSL_CTX_new SSL_new SSL_get_cipher_list SSL_free TLS_method TLSv1_method TLSv1_1_method SSL_get_ciphers OPENSSL_sk_num OPENSSL_sk_value SSL_CIPHER_description EVP_PKEY_new RSA_generate_key EVP_PKEY_assign EVP_PKEY_free BIO_s_file BIO_new BIO_ctrl PEM_write_bio_PrivateKey BIO_free_all X509_new X509_set_version X509_get_serialNumber ASN1_INTEGER_set X509_getm_notBefore X509_gmtime_adj X509_getm_notAfter X509_set_pubkey X509_get_subject_name X509_NAME_add_entry_by_txt X509_set_subject_name EVP_md5 X509_sign PEM_write_bio_X509 DH_new BN_bin2bn DH_set0_pqg DH_free BN_free __sprintf_chk SSL_ctrl SSL_set_ex_data SSL_set_verify SSL_CTX_set_info_callback BIO_f_ssl SSL_set_accept_state SSL_set_bio SSL_set_connect_state SSL_CTX_set_ex_data SSL_CTX_set_options SSL_CTX_ctrl SSL_CTX_set_cipher_list SSL_CTX_set_default_passwd_cb SSL_CTX_set_default_passwd_cb_userdata BIO_new_file PEM_read_bio_DHparams BIO_free SSL_CTX_use_certificate_file SSL_CTX_use_PrivateKey_file SSL_CTX_check_private_key SSL_CTX_load_verify_locations SSL_load_client_CA_file SSL_CTX_set_client_CA_list SSL_CTX_set_default_verify_paths strcmp X509_get_default_cert_file Tls_Init memcpy calloc OPENSSL_init_ssl OPENSSL_init_crypto BIO_set_init BIO_set_data BIO_clear_flags BIO_get_data BIO_get_shutdown BIO_set_shutdown BIO_test_flags BIO_set_flags BIO_get_init BIO_meth_new BIO_meth_set_write BIO_meth_set_read BIO_meth_set_puts BIO_meth_set_ctrl BIO_meth_set_create BIO_meth_set_destroy SSL_accept SSL_get_error SSL_connect SSL_is_init_finished ERR_clear_error BIO_write BIO_read BIO_ctrl_pending BIO_s_mem X509_NAME_print_ex X509_get_issuer_name i2a_ASN1_INTEGER __strcpy_chk EVP_sha1 X509_digest libssl.so.1.1 libcrypto.so.1.1 libc.so.6 GLIBC_2.14 GLIBC_2.4 GLIBC_2.3.4 GLIBC_2.2.5 OPENSSL_1_1_0 /usr/lib:/usr/lib/x86_64-linux-gnu                                                                                                                                             P           ii        ti	        ui	                    m                    m         p             8      x             `8                                       $                   (                   ,                   0                   4                   8                   <                   @                   D                   H                   L                           @             G      H             M      P             S      X             Y      `             a      h             i                   :                                   "                    +                    /                                                    (                    0                    8                    @                    H                    P                    X         	           `         
           h                    p                    x                                                                                                                                                                                                                                                                                                                                                                                                       !                    #                     $           (         %           0         &           8         '           @         (           H         )           P         *           X         ,           `         -           h         .           p         0           x         1                    2                    3                    4                    5                    6                    7                    8                    9                    :                    ;                    <                    =                    >                    ?                    @                    A                     B                    C                    D                    E                     F           (         G           0         H           8         I           @         J           H         K           P         L           X         M           `         N           h         O           p         P           x         Q                    R                    S                    T                    U                    V                    W                    X                    Y                    Z                    [                    \                    ]                    ^                    _                    `                    a                     b                    c                    d                    e                     f           (         g           0         h           8         i           @         j           H         k           P         l           X         m           `         n           h         o           p         p           x         q                    r                    s                    t                    u                    v                    w                    x                    y                    z                    {                    |                    }                    ~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       HH  HtH     5  %  @ %  h    %  h   %  h   %  h   %  h   %  h   %  h   %  h   p%  h   `%  h	   P%  h
   @%  h   0%  h    %z  h   %r  h    %j  h   %b  h   %Z  h   %R  h   %J  h   %B  h   %:  h   %2  h   %*  h   p%"  h   `%  h   P%  h   @%
  h   0%  h    %  h   %  h    %  h   %  h    %  h!   %  h"   %  h#   %  h$   %  h%   %  h&   %  h'   p%  h(   `%  h)   P%  h*   @%  h+   0%  h,    %z  h-   %r  h.    %j  h/   %b  h0   %Z  h1   %R  h2   %J  h3   %B  h4   %:  h5   %2  h6   %*  h7   p%"  h8   `%  h9   P%  h:   @%
  h;   0%  h<    %  h=   %  h>    %  h?   %  h@   %  hA   %  hB   %  hC   %  hD   %  hE   %  hF   %  hG   p%  hH   `%  hI   P%  hJ   @%  hK   0%  hL    %z  hM   %r  hN    %j  hO   %b  hP   %Z  hQ   %R  hR   %J  hS   %B  hT   %:  hU   %2  hV   %*  hW   p%"  hX   `%  hY   P%  hZ   @%
  h[   0%  h\    %  h]   %  h^    %  h_   %  h`   %  ha   %  hb   %  hc   %  hd   %  he   %  hf   %  hg   p%  hh   `%  hi   P%  hj   @%  hk   0%  hl    %z  hm   %r  hn    %j  ho   %b  hp   %Z  hq   %R  hr   %J  hs   %B  ht   %:  hu   %2  hv   %*  hw   p%"  hx   `%  hy   P%  hz   @%  f        H=  H  H9tH  Ht	        H=i  H5b  H)HH?HHHtH  HtfD      =5   u+UH=r   HtH=~  Yd  ]     w    UH=DW  HSHH  dH%(   HD$1H  HHHh  HD$dH3%(   u	H1[]f.     AWAVAUIATUHSHL%  dH%(   HD$1I$   uAHy
     H=V  H uI$1I}X  H[@ I$HxV  L   HP     H\$dH3%(   6  H[]A\A]A^A_@ 1HyX  HI$HHT$  HH  I$p  II$L   I)=  I9I$t8H@  L  E1HU  HHH5U  1   L L  Hx@I7  HH3  HH  II$H=U  Hp    LHHI$I~@Hp  L  `1HVALHHI~@=H%HHty   H=.U  I$ taHp  H=V    LHHI$I~@L  Hp  HHALHHI$LHh  1D     fD  CIHuI$11  ID  HHUG  LIZAWAVIAUA1ATUSH8T$dH%(   HD$(1Hx(H  L%	  HI$   L+T  LvV  HA  I$LD$H=T  LL$Lp    HH{ HAI$H;H  Lp  H$  H$HH{ HHALL$I$LLp    H{ HHAI$LD$LLp    H{ HHAAuA @  r  I$LL  Lp  pHAH{ HHAI$H{ X  I$HX  I$   HE H{ 8	  E PU    I$H  HD$(dH3%(   /  I$H{ H  H8[]A\A]A^A_LR  A ^LCR  A @  u)L9R  A   uA    LR  H#R  LDL R  ALR  AL	R  AALQ  HQ  LD     I$H   fD  |$HI$Lp    H{ HHA@ HD$(dH3%(   uH8[]A\A]A^A_ff.     AWE1AVAUATUHSH8|$dH%(   HD$(1HHI1LIHH"HA7L$[  H{(Hf  H-  HE    H=P  IHE Hp  HL$  LH{ HL$HHE H;Hp  H  HL$HT$  HT$HLH{ HL$HHE DHp  HL$  HL$H{ LHHE H{ LLp  B  LH{ HAHE |$Lp    H{ LHAMHE HP  LDLp  L  LH{ HAHE H{ X  HE HX  HE K   A$H{ L8	  H{ HE txp  D$    HE A$JA$L   HE Hc  HE H{   D$HL$(dH3%(      H8[]A\A]A^A_    @  Ht$$IHE LX  HHE rT$$fH{ HT$L@  HH{ HE -D  HcH{(IHC8   ED$KAWAVIAUATAUSHH-  Hy0dH%(   HD$1Ly HE H  H   H{ IHE X  HE HX  HE LLAE    8	  uAE PAU HU    H  HE H{   HE L  LIcHH*HHL$dH3%(      H[]A\A]A^A_    HE H{ p  AE PAU HE L   D  HE H  HE H{   fD     H5M  L(	  6L   HE H  HE H{   ff.      AUAHATUHSHHR  dH%(   HD$1D$    HAtAHK     HP     HL$dH3%(   q  H[]A\A]     HyL  1X  H1HAHHtbHp  IHL   I2  I9HtJH@  L  E1H\K  HHH5dK  1   VD     GfD  L  Ht$   HI:3     x!HHh    HH1fAD$uhHMd$`H  H|$(  MtA<$ uHHp  IL11LH5K  HA@     f.     |$u1aff.     fAWAVAUATUSH   H$ H   H$ HHHO  dH%(   H$8   1AD$,    HHI   HHqE1   HT$0LJ  HRH  	  AXZEu]A   Dl$(A   HL  DHcH>H@  ,HH1H1H|$.fD  A   H$8   dH3%(     HH   D[]A\A]A^A_fD  HI  L   HP  A   HIvHT$,H  8HA   H@  {H1HH1`fHHD$H|$ tH|$HH$H11  t$,I  D$(    5f     HLp    LHHAD$(pt$(H<$HHuH<$
H|$HLHh  @ HHD$3H1H5~H  H1A   @  \fD  H1H5VH  H1E@  7f     kHHD$f     KHHD$H<$Ll$0MID$(    HD$9fD  HLLp  LL$  LL$LHHAD$(H|$t$(9H|$    LH=LI &     2H!%t  DHrHD@ HL)ID HIf     P 3I)@ LHHuff.     @ AWAVAUATIUHSH   H.  dH%(   HD$x1H"  HAHqE1HT$dLG     HRH  	  AYAZA  DD$\E  AED$h    LD$lm    It$HT$dHA@  A^  HI|$
  I|$ HD$H
  HD$A  HIt$(HL$pHHT$`x  A  D$`d  l  HE  Dt$LL|$lHD$@HD$8HD$0HD$(HD$ HD$H$HD$hI7    HD$pLHJt(H@     AD;d$`  HT$pIcL,    H<H
     H=2E  H t   HH=E  L .  HD$pLHJt(A@  x    A   HD$xdH3%(   A  H   D[]A\A]A^A_f     HD  L   HP  A   HF  L   HAP  D  HD  HD$@HD$8HD$0HD$(HD$ HD$H$IH^  |$d11     LH   HH1H5D  P  Lf.     Cu(x u"HD$pJ|(A
  H$A     Su(xTu"x uHD$pJ|(A
  HD$
L  x   HD$pJ|(A
  HD$ fHHL$   l   HIHLE1j E111LLQ^_IH     HLc|$hLHLnLf1HLc|$lLMiQ HLmLLLzHAAj HL$  HH5B  IHL$ ALA  H5rB  $    pHL$0ALA  H5mB  $    DHL$8ALA  H5B  $    HL$@ALA  H5A  $    HL$HALA  H5A  $    HL$PALA  H5_A  $    LLYLLHZY  gHHL$   l   HHLHHL*LD  H1H5@  HP  fD  OuMx uGHD$pJ|(A
  HD$(fDt$L?fD  H1H5B  HP  ~OusxUumx ugHD$pJ|(A
  HD$0HH1H5B  P  LM0LPL8H1HH5:@  P  Cu'xNu!x uHD$pJ|(A
  HD$8KH   H=?   u HD$pJ|(A
  HD$@(1H5?  HAP  AUAHATUHSHH  dH%(   HD$1HAt9H>>     HP     H\$dH3%(      H[]A\A]HyL  
  H1HAHHtdHp  IHL   I$  I9HtLH@  L  E1H=  HHH5=  1   `       OfD  LH  /f     AUATUHdH%(   HD$1.IHtJ1   H=(  1   H=  HmIHt=Ht81HHLpt$HD$dH3%(   u1HL]A\A]    LE1H5L-&fD  HHcdH%(   HD$1H  HH  Lt#HD$dH3%(   u3H	  LH HD$dH3%(   uH	  LH HdH%(   HD$1HD$dH3%(   uH  H Hp	  H\ff.     AWAVAUATUSH   H$ H   H$ HH-  LE dH%(   H$   1HH Ht> I`  MX  A@  1HAIH{(HE Lk`Hb     H=<  IHE Lp    LH{ HAHE H;Lp  L    HAH{ LHAHE LLp    LH{ HAHE H{ X  HE HX  HE A$   H{ L8	  tHE H{ p  A$PA$HU ~jH  HE H{   H$   dH3%(      H   []A\A]A^A_f.     H1H5?;  A0       L   HU H;I  MLH;  I       1HE H{ L   P  HE H{ p  GD  SHHHdH%(   HD$1HtHt  H   HC    H{PHtHCP    H{@HtHC@    H{HHtHCH    H{(HtP~THC(    H{0HtP~HC0    HD$dH3%(   u1H[H  H    fD  H  H    UHHdH%(   HD$1HD$dH3%(   uHh  HH H@0H]fAWAVAUIATIUSH(  H-.  dH%(   H$  1D$x    D$|    HE $       $      $      $      $      $       $        HyL  1X  L1HAHHU  HE p  LU HD$X    HD$8HD$P    HD$(    HD$    HD$    HD$     HD$@    HD$0      HD$H    A   L5^8  HD$    Ic1I<AX  8-I^  H   LLU  udAD9  E1H8  LH7  H58  A@     H$  dH3%(   7  H(  []A\A]A^A_       LH=7   u>AD9  E1H7  LH7  H57  A@          
   LH=7     AD9  E1H57  LHR7  H5,7  A@     !f     Ic1I<AX  LU HD$AD9D$   Et$   EAA\$|D$   E1AEtAD$   EtAD$   EtAD$   EtA$   tA H\$Ht;     HEHD$H\$0Ht;     HEHD$0HT$ Ht:     HEHD$ H\$Ht;     HEHD$HT$Ht:     HEHD$H\$(Ht;     HEHD$(h   AR(HxHH     IH1H)hHH4  Ml$ AD$   H\$@Et$8ID$`Ht"HE Ht$tHX  t$ttI\$(H\$HHt"HE Ht$tHX  L$ttI\$0Ht$PH  HE LH$     HHt_HE p  HD$8IHE L   Hs  H9HE 6  LH@    E1H 3  LHH5(3  1L    fD  HZ4  L   LP     ffD     LH=t4   u^AD9  E1H!4  LHH4  H54  A@     D  Ic1I<AX  LU HD$fH4  	   LH tsH3  
   LH    AD9   Ic1I<AX  LU HD$(    Ic1I<AX  LU HD$[fAD9~7IcIHD$@?fD  Ic1I<AX  LU HD$ fE1H 3  H53  LA@      LU     H3  	   LH .  AD9~Ic1I<AX  LU HD$0H|$8L$`  H$@    H@HHD$@HD$@L$   LLD$ID$HHE   HE L$  LLL$  HE H  HE L  HHE LH\$8H2  H  HE LHH2  LI  HE HLLD$H2  L  HE HLLL$H2  L  HE HLH2  Hq2    HE HLHx2  H`2    HE H    M   LHLI$HHHE H$   H2  L  HE LH$`  I4$H1    HE LH$@  I4$H1    HE LH$  I4$H1    I|$HuID$@HH  HD$XHt(1H7   Hu$     I|$@L18I|$@HDI|$HH51LI  ID$XOH'ID$PD$x   AL$I|$@It$XI|$@HIL$@I|$P1m   HE I<$HP       LH1D  HD$H    HD$       H=/  L   AD9c  E1HN/  LH/  H5E/  A@     :I|$@-ID$ HD$HE  A)  D  AY    A  A  1HyHD$@H E1H\$@HT$H1LD$PHoT HLD$PHL1   H*   HD$ HtHHiH\$@H5HHLjH\$(H  HE L$`  L  HE LHH|$H  H5e\  HHH  111HD$ gH|$ H
HE L  H  H|$@H1   HXH\$H  HE L  HE LHH|$H  H|$@   HV  HT$0HD$H|$HHHELHHD$0HE   H|$@   HqLHE     H|$@2  HE LH$@    HE H  Ht$HtHE H|$HH  HD$Ht$H$  HE H|$HL  HT$H|$@H   HE Ht$LH|$H  HHHt
H|$@HE L  HE H  A   HHD$@H]L|$@1  {   L1  L|   Lc
   H=,  L uVAD98  E1H+  LH+  H5+  A@     xHM 1H5#/  L1@  H+  	   LH    AD9H$   IcLI4A  tLU Ic1I<AX  LU HD$PHM H|$H11H5)  @  #HE H@  HV1H55.  LH1L   HM H1H52+  1@  IcIHD$H\H*  	   LH    AD9H$   sH=DHD%      	D%   	D %    	gHD$@HAA HL$`  HHT$H|$@1 H|$@H|$@LH5)  LT$hLD$`5LD$`LT$h`  AD9L  HT$xH|$@   HHE L  HM 1H5+  H|$H1@  H|$@HE L  HE H@  H0H|$HE1HT$IHt'  H5+  1H|$@HM H|$H1H5+  @  H|$@m  Lt$H11HE LP  HE H@  HLHT$0E1IH&  H5+  1H|$@
*HM 1H5*  LH5#(  LT$hLD$`LD$`LT$hu5AD9jE1Hs'  LH'  H5j'  A@     _LH5'  LT$hLD$`NLD$`LT$hu5AD9   HT$|Ic1I<AX  LU HD$XLH5}'  LT$hLD$`LD$`LT$h   AD9~eH$   E1H&  LH'  H5&  A@     E1H~&  LH '  H5u&  A@     jE1HR&  LH&  H5I&  A@     >LH5&  LT$hLD$`-LD$`LT$huAD9~JH$   LH5&  LT$hLD$`LD$`LT$hunAD9~9H$   E1H%  LH:&  H5%  A@     E1H%  LH&  H5w%  A@     lLH5%  LT$hLD$`[LD$`LT$huAD9~JH$   
LH5%  LT$hLD$`LD$`LT$hunAD9~9H$   E1H$  LHv%  H5$  A@     E1H$  LHR%  H5$  A@     H&  j LL/%  PH#  1Hi$  H5#%  A@  A]   A^ZfAUATUSH   H$ H   H$ H	  )  H5+(  A   dH%(   H$)  1IHL1H5$  HS  HtzHwx  w  H   H=w  	        w     11Hw  0tSHH=qw  	  H1HH5T'  1@  H$)  dH3%(   T  H)  D[]A\A]@ 1   1   117  HH=v  	  HE11HHH5$    HE11H	H5#  H  HE11H
H5#  H  HE11HH5#  H  HE11HH5#  H  HE11HMH5#  H  HE11HH5#  H  HtHLH  H1H}#  HH5z#  PA@ HdH%(   HD$1HD$dH3%(   u	Hof.     U1HHdH%(   HD$11HSHHD$dH3%(   uH   ]VfD  ATIUHSHdH%(   HD$11H  XHH~w7HN  HcH>   HL$dH3%(      H[]A\1HD  1   t~1   HD fh1HH(u  1H5  H h  HH?HxH u  H    HaHHRDH   =1H2Ht  H   HD  AVAAUATIUHSHdH%(   HD$11H  M   HXt  ILDLH`  LAH   AH  	   HAEtKEFHh   E1(     Hu<HD$dH3%(   uSHD[]A\A]A^@ Et+AuAtD  
   HE1 	   H@ AVAAUATIUHSHdH%(   HD$11H  HAs  LDIHLh  LAH   AH  
   HAEtLEGHh   E1(     Hu=HD$dH3%(   uTHD[]A\A]A^D  Et+AuAtD  	   Hf     	   Hff.     ATIHUHHdH%(   HD$1wHL$dH3%(   uHHL]A\nff.      ATE1UHdH%(   HD$1HtHA   uHD$dH3%(   u,HD]A\H1HNH!f.     AUAATUHHdH%(   HD$1H=p   tcH   H=p  HIH`DLe   LHD$dH3%(      HL]A\A]    H5I    H5XHH.p  H="p  H5VH=p  H5HH=o  H5H=o  H52MH=o  H5oHE1@ HdH%(   HD$1GDGHD$dH3%(   u1Hh     U11   SH   HdH%(   HD$1HG    HPDH{P
   D11-IEEHD$dH3%(   uHo  H;H H   H[]ff.     UHHdH%(   HD$1H8o  H5HH 0  HD$dH3%(   uH1]h     HLYn  dH%(   HD$1MtHD$dH3%(      LHHn     H P(Hx0IHn  HH@(    H       )   1HHH  I@   I H I@H5  I@HZ  I@ H  I@8Hd  I@@H  I@HHI@XHs  I@h.eD  AVIAUATUSHdH%(   HD$1GAAm  H tB  DH}@AAD$vAD$   E4  H}@u~H}P11   H}@IoAE~H}@tA   A	     AtyA   AHD$dH3%(   G  HD[]A\A]A^f     H}P   ;AuHl  H   A   H      Ah   M AfEu0ef.     A    G@ A   A1H7l  AH   AH#HHM Ag   utHk  H   AhQAg   Euh   Aff.     fATAUHSHHdH%(   HD$1HtHnk  H   HE    ]1t#HL$dH3%(   u?H[]A\f.     Ht$   HD$    y	|$DDD_ff.     @ AVAUATUSHHdH%(   HD$1    DgA   IAH   H   EuFH}P11   9      HD$dH3%(   0  HD[]A\A]A^fKH}PDL\H}@AN   HVC  HcH>f;htA    Ay    cHEuTAuztvHi  AH   3f     H}@DAHcHHg   EA    EIfD  EA   Aff.     fAVAUATE1USHdH%(   HD$1    Gt)HD$dH3%(   "  HD[]A\A]A^D  IAH1HH   H}PLDVH}@A   =t   H}@DA~HcfHH[g   OuJHEuu6AuYtUHh  H   fD  ;hA     E1    A    AfD  H#wdH%(   HD$1@u.HD$dH3%(   u5Hwg  H?H H  H@ HD$dH3%(   u1H@ ATIU@   SHdH%(   HD$1Hg  H H  THHD$dH3%(   uHLH[]A\:f.     AVAUATUSHdH%(   HD$1Gt*HD$dH3%(     H[]A\A]A^f     A@   HHC    L-\f  HDcIE    HLp@IE   DHAH{HtIE   HC    AbIE H;  ~kIE H   H5   HC/f     L%e  HI$   HLh@I$  1HAC        H{P'Hu     AWAVAUIATIUH@   SHdH%(   HD$1L54e  IILH     HHtDHIL  HHD$dH3%(   uIHLLHH[]A\A]A^A_fD  1MHT$dH3%(   uH[]A\A]A^A_@ USHdH%(   HD$1H=  	&  HHN
 0<	*  HH9uFPF  FLFHHv=     FDFE@FDFF@FDF	F@F
E1X	w^k@	   HcHcH=+c  |ZH5  H<  HEHl     PHZ  R   APLH<  1ASARH0Hb  H\$dH3%(   u%H[]D  H<  DCgzf.     AWAVAUATUSL$  H   H$ L9uH   Hb  dH%(   H$  1HHI11  D$x $   IpHH  LIA  .1LHL11
   LL=  H$   AOHHD$        LH11H    L1LH11
   LhL=  H$   AOHHD$       LH11H     LLH=11
   LDLL$  =  NH$@  HHD$       LH11H@   LLL|$ts1Ld$(A@ LL~:AHI11
   L`H?  D)9O    =    NuA 11   LLd$(%L=LL$`  L$  Hp8    LHL"Hp8    LHHT$01LHHT$(;HT$(HL$QLD$DH=9  D  HH@@47A@qI9uHH=i9  Lp    LHHAHH|$P(   Lp    LHHAHH=%9  Lp    LHHAHH|$ Lp    LHHAHH=8  Lp    LHHAHH|$Lp    LHHAHH=8  Lp    LHHAHLLp    LHHAHH=V8  Lp    LHHAHLLp    LHHAHH=	  Lp    LHHAHH|$Lp    LHHAHH=	  Lp    LHHAHH|$Hp    LHHH$  dH3%(   umH  L[]A\A]A^A_    H$   $    HD$ H$   HD$H$@  HD$H$  $    $@   HD$f01	@ AUATUHSHH_dH%(   HD$1H$    H   ;   IA1HIH56  SHS  Et_A<$@t4L@1f     0H	u   E1   LHH56  SH   H$Hb\  HRHtiH
HW\  HJHRHP\  HQ\  H|$dH3<%(      H[]A\A]f.     H5  HE    HE 1f     H[      H[      H[      D  @:8u-   @ H@8uA4u0	)E1   LHH55  S1>  HH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   OpenSSL 1.1.1c  28 May 2019 -local ?-local? channel ": not a TLS channel bad channel " sbits (NONE) accept alert connect unknown read write loop exit start done info verify tls::password handshake failed:  protocol ?verbose? protocol protocol not supported subcommand ?args? days serial Email Unknown parameter Error generating private key C ST O OU CN Error signing certificate SSL SSL channel "%s": error: %s error channel ?options? -cadir  option no argument given for  -cafile -certfile -cipher -command -dhparams -keyfile -model -password -require -request -server -servername -ssl2 -ssl3 -tls1 -tls1.1 -tls1.2 -tls1.3 ": must be  bad  no valid protocol selected -eofchar -encoding -translation -blocking binary true 8.4 tls::ciphers tls::handshake tls::import tls::unimport tls::status tls::version tls::misc 1.7.20 tls req    Hp@keysize keyfile certfile ?info? Information list must have even number of arguments     Error generating certificate request    -cadir, -cafile, -certfile, -cipher, -command, -dhparams, -keyfile, -model, -password, -require, -request, -server, -servername, -ssl2, -ssl3, -tls1, -tls1.1, -tls1.2, or tls1.3       Could not find DH parameters file       Could not read DH parameters from file  unable to set certificate file  unable to set public key file   private key does not match the certificate public key   couldn't construct ssl session:         setting TLS host name extension failed  could not initialize SSL library        #
# Copyright (C) 1997-2000 Matt Newman <matt@novadigm.com> 
#
namespace eval tls {
    variable logcmd tclLog
    variable debug 0
 
    # Default flags passed to tls::import
    variable defaults {}

    # Maps UID to Server Socket
    variable srvmap
    variable srvuid 0

    # Over-ride this if you are using a different socket command
    variable socketCmd
    if {![info exists socketCmd]} {
        set socketCmd [info command ::socket]
    }

    # This is the possible arguments to tls::socket and tls::init
    # The format of this is a list of lists
    ## Each inner list contains the following elements
    ### Server (matched against "string match" for 0/1)
    ### Option name
    ### Variable to add the option to:
    #### sopts: [socket] option
    #### iopts: [tls::import] option
    ### How many arguments the following the option to consume
    variable socketOptionRules {
        {0 -async sopts 0}
        {* -myaddr sopts 1}
        {0 -myport sopts 1}
        {* -type sopts 1}
        {* -cadir iopts 1}
        {* -cafile iopts 1}
        {* -certfile iopts 1}
        {* -cipher iopts 1}
        {* -command iopts 1}
        {* -dhparams iopts 1}
        {* -keyfile iopts 1}
        {* -password iopts 1}
        {* -request iopts 1}
        {* -require iopts 1}
        {* -autoservername discardOpts 1}
        {* -servername iopts 1}
        {* -ssl2 iopts 1}
        {* -ssl3 iopts 1}
        {* -tls1 iopts 1}
        {* -tls1.1 iopts 1}
        {* -tls1.2 iopts 1}
        {* -tls1.3 iopts 1}
    }

    # tls::socket and tls::init options as a humane readable string
    variable socketOptionsNoServer
    variable socketOptionsServer

    # Internal [switch] body to validate options
    variable socketOptionsSwitchBody
}

proc tls::_initsocketoptions {} {
    variable socketOptionRules
    variable socketOptionsNoServer
    variable socketOptionsServer
    variable socketOptionsSwitchBody

    # Do not re-run if we have already been initialized
    if {[info exists socketOptionsSwitchBody]} {
        return
    }

    # Create several structures from our list of options
    ## 1. options: a text representation of the valid options for the current
    ##             server type
    ## 2. argSwitchBody: Switch body for processing arguments
    set options(0) [list]
    set options(1) [list]
    set argSwitchBody [list]
    foreach optionRule $socketOptionRules {
        set ruleServer [lindex $optionRule 0]
        set ruleOption [lindex $optionRule 1]
        set ruleVarToUpdate [lindex $optionRule 2]
        set ruleVarArgsToConsume [lindex $optionRule 3]

        foreach server [list 0 1] {
            if {![string match $ruleServer $server]} {
                continue
            }

            lappend options($server) $ruleOption
        }

        switch -- $ruleVarArgsToConsume {
            0 {
                set argToExecute {
                    lappend @VAR@ $arg
                    set argsArray($arg) true
                } 
            }
            1 {
                set argToExecute {
                    incr idx
                    if {$idx >= [llength $args]} {
                        return -code error "\"$arg\" option must be followed by value"
                    }
                    set argValue [lindex $args $idx]
                    lappend @VAR@ $arg $argValue
                    set argsArray($arg) $argValue
                }
            }
            default {
                return -code error "Internal argument construction error"
            }
        }

        lappend argSwitchBody $ruleServer,$ruleOption [string map [list @VAR@ $ruleVarToUpdate] $argToExecute]
    }

    # Add in the final options
    lappend argSwitchBody {*,-*} {return -code error "bad option \"$arg\": must be one of $options"}
    lappend argSwitchBody default break

    # Set the final variables
    set socketOptionsNoServer   [join $options(0) {, }]
    set socketOptionsServer     [join $options(1) {, }]
    set socketOptionsSwitchBody $argSwitchBody
}

proc tls::initlib {dir dll} {
    # Package index cd's into the package directory for loading.
    # Irrelevant to unixoids, but for Windows this enables the OS to find
    # the dependent DLL's in the CWD, where they may be.
    set cwd [pwd]
    catch {cd $dir}
    if {[string equal $::tcl_platform(platform) "windows"] &&
	![string equal [lindex [file system $dir] 0] "native"]} {
	# If it is a wrapped executable running on windows, the openssl
	# dlls must be copied out of the virtual filesystem to the disk
	# where Windows will find them when resolving the dependency in
	# the tls dll. We choose to make them siblings of the executable.
	package require starkit
	set dst [file nativename [file dirname $starkit::topdir]]
	foreach sdll [glob -nocomplain -directory $dir -tails *eay32.dll] {
	    catch {file delete -force            $dst/$sdll}
	    catch {file copy   -force $dir/$sdll $dst/$sdll}
	}
    }
    set res [catch {uplevel #0 [list load [file join [pwd] $dll]]} err]
    catch {cd $cwd}
    if {$res} {
	namespace eval [namespace parent] {namespace delete tls}
	return -code $res $err
    }
    rename tls::initlib {}
}


#
# Backwards compatibility, also used to set the default
# context options
#
proc tls::init {args} {
    variable defaults
    variable socketOptionsNoServer
    variable socketOptionsServer
    variable socketOptionsSwitchBody

    tls::_initsocketoptions

    # Technically a third option should be used here: Options that are valid
    # only a both servers and non-servers
    set server -1
    set options $socketOptionsServer

    # Validate arguments passed
    set initialArgs $args
    set argc [llength $args]

    array set argsArray [list]
    for {set idx 0} {$idx < $argc} {incr idx} {
	set arg [lindex $args $idx]
	switch -glob -- $server,$arg $socketOptionsSwitchBody
    }

    set defaults $initialArgs
}
#
# Helper function - behaves exactly as the native socket command.
#
proc tls::socket {args} {
    variable socketCmd
    variable defaults
    variable socketOptionsNoServer
    variable socketOptionsServer
    variable socketOptionsSwitchBody

    tls::_initsocketoptions

    set idx [lsearch $args -server]
    if {$idx != -1} {
	set server 1
	set callback [lindex $args [expr {$idx+1}]]
	set args [lreplace $args $idx [expr {$idx+1}]]

	set usage "wrong # args: should be \"tls::socket -server command ?options? port\""
        set options $socketOptionsServer
    } else {
	set server 0

	set usage "wrong # args: should be \"tls::socket ?options? host port\""
        set options $socketOptionsNoServer
    }

    # Combine defaults with current options
    set args [concat $defaults $args]

    set argc [llength $args]
    set sopts {}
    set iopts [list -server $server]

    array set argsArray [list]
    for {set idx 0} {$idx < $argc} {incr idx} {
	set arg [lindex $args $idx]
	switch -glob -- $server,$arg $socketOptionsSwitchBody
    }

    if {$server} {
	if {($idx + 1) != $argc} {
	    return -code error $usage
	}
	set uid [incr ::tls::srvuid]

	set port [lindex $args [expr {$argc-1}]]
	lappend sopts $port
	#set sopts [linsert $sopts 0 -server $callback]
	set sopts [linsert $sopts 0 -server [list tls::_accept $iopts $callback]]
	#set sopts [linsert $sopts 0 -server [list tls::_accept $uid $callback]]
    } else {
	if {($idx + 2) != $argc} {
	    return -code error $usage
	}

	set host [lindex $args [expr {$argc-2}]]
	set port [lindex $args [expr {$argc-1}]]

        # If an "-autoservername" option is found, honor it
        if {[info exists argsArray(-autoservername)] && $argsArray(-autoservername)} {
            if {![info exists argsArray(-servername)]} {
                set argsArray(-servername) $host
                lappend iopts -servername $host
            }
        }

	lappend sopts $host $port
    }
    #
    # Create TCP/IP socket
    #
    set chan [eval $socketCmd $sopts]
    if {!$server && [catch {
	#
	# Push SSL layer onto socket
	#
	eval [list tls::import] $chan $iopts
    } err]} {
	set info ${::errorInfo}
	catch {close $chan}
	return -code error -errorinfo $info $err
    }
    return $chan
}

# tls::_accept --
#
#   This is the actual accept that TLS sockets use, which then calls
#   the callback registered by tls::socket.
#
# Arguments:
#   iopts	tls::import opts
#   callback	server callback to invoke
#   chan	socket channel to accept/deny
#   ipaddr	calling IP address
#   port	calling port
#
# Results:
#   Returns an error if the callback throws one.
#
proc tls::_accept { iopts callback chan ipaddr port } {
    log 2 [list tls::_accept $iopts $callback $chan $ipaddr $port]

    set chan [eval [list tls::import $chan] $iopts]

    lappend callback $chan $ipaddr $port
    if {[catch {
	uplevel #0 $callback
    } err]} {
	log 1 "tls::_accept error: ${::errorInfo}"
	close $chan
	error $err $::errorInfo $::errorCode
    } else {
	log 2 "tls::_accept - called \"$callback\" succeeded"
    }
}
#
# Sample callback for hooking: -
#
# error
# verify
# info
#
proc tls::callback {option args} {
    variable debug

    #log 2 [concat $option $args]

    switch -- $option {
	"error"	{
	    foreach {chan msg} $args break

	    log 0 "TLS/$chan: error: $msg"
	}
	"verify"	{
	    # poor man's lassign
	    foreach {chan depth cert rc err} $args break

	    array set c $cert

	    if {$rc != "1"} {
		log 1 "TLS/$chan: verify/$depth: Bad Cert: $err (rc = $rc)"
	    } else {
		log 2 "TLS/$chan: verify/$depth: $c(subject)"
	    }
	    if {$debug > 0} {
		return 1;	# FORCE OK
	    } else {
		return $rc
	    }
	}
	"info"	{
	    # poor man's lassign
	    foreach {chan major minor state msg} $args break

	    if {$msg != ""} {
		append state ": $msg"
	    }
	    # For tracing
	    upvar #0 tls::$chan cb
	    set cb($major) $minor

	    log 2 "TLS/$chan: $major/$minor: $state"
	}
	default	{
	    return -code error "bad option \"$option\":\
		    must be one of error, info, or verify"
	}
    }
}

proc tls::xhandshake {chan} {
    upvar #0 tls::$chan cb

    if {[info exists cb(handshake)] && \
	$cb(handshake) == "done"} {
	return 1
    }
    while {1} {
	vwait tls::${chan}(handshake)
	if {![info exists cb(handshake)]} {
	    return 0
	}
	if {$cb(handshake) == "done"} {
	    return 1
	}
    }
}

proc tls::password {} {
    log 0 "TLS/Password: did you forget to set your passwd!"
    # Return the worlds best kept secret password.
    return "secret"
}

proc tls::log {level msg} {
    variable debug
    variable logcmd

    if {$level > $debug || $logcmd == ""} {
	return
    }
    set cmd $logcmd
    lappend cmd $msg
    uplevel #0 $cmd
}

 tcl l4lX(ppL GMT Bad time value %s %2d %02d:%02d:%02d %d%s 0123456789ABCDEF sha1_hash subject issuer notBefore notAfter Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec interpreter uses an incompatible stubs mechanism Tcl    ;d  +   o  Xw  (x  x  {8  ~    h8  Xt    (\  X        8d  8      HP  p    8  X  xP  |  X      x(  L  h  8    $	  (h	  	  	  h
  8h
  
                 zR x  $      n   FJw ?;*3$"       D   u           (   \   `vf    EPD0C
CAA H      v   FBB E(A0D8FP
8A0A(B BBBE d      Hy   FBE G(A0A8Dp
8A0A(B BBBC
8A0A(B BBBA  H   <   |    FEB B(A0D8DpF
8A0A(B BBBHH     ~   FBE B(D0A8DP
8A0A(B BBBH 8     (   FHA D(D@Z
(A ABBI `     !   FBB B(A0A8G L@IA~A\AQAAA
8D0A(B BBBG   t     FBB B(D0D8Gg_OB
8D0A(B BBBJH]AyNCA  8     '   FHA D(D@R
(A ABBA 0   4      FBA D0{
 DBBH     h  D}    H K
E^
B        D    H u
B  T     K   FBB B(A0A8G L@I@
8A0A(B BBBK              EG 
AB     $  N    EG z
AB  \   H  ^   FBB E(D0A8G
8A0A(B BBBH?K`G @     \   FBA A(G L@LS
(D ABBE     6    H d
E            Z    EI @
FA 0   0  LK   FDD F0e
 AABA @   d  h   FEB D(D0D@
0D(A BBBE @     D   FEB D(D0D@
0D(A BBBF (      R    FGG0i
IBE  (     Tv    FDD0{
DBA  4   D  -   FEA G0m
 DBBH        |  H    H z
A  (         EJL0p
AAB       HX    EG C
CA          H w
A  @     hS   FEB A(A0D@
0D(A BBBJ 0   H      FDD D0O
 AABK @   |      FBB A(A0G@
0D(A BBBC @     j   FBB D(A0D@t
0D(A BBBF        l    H B
FV
A   0   (  f    FDH D0}
 IABB  @   \  @X   FBB A(A0D@n
0A(A BBBJ  `     \    FBB E(D0I8DPb
8M0A(B BBBH\
8A0A(B BBBA @   	     AAD0
8L@HHGPOXB`I0[
AAF   X   H	     FBB B(A0A8HQG5
8D0A(B BBBH        	         8   	     BBA D(D@
(A ABBK                                                                                                                                                                                                                                                                                                                                                                                                                8      `8             $      (      ,      0      4      8      <      @      D      H      L                                                     0                          p                           x                    o    `                                
       .	                                                                                 `             p      	              o          o           o          o                                                                                                                                                                                 60      F0      V0      f0      v0      0      0      0      0      0      0      0      0      1      1      &1      61      F1      V1      f1      v1      1      1      1      1      1      1      1      1      2      2      &2      62      F2      V2      f2      v2      2      2      2      2      2      2      2      2      3      3      &3      63      F3      V3      f3      v3      3      3      3      3      3      3      3      3      4      4      &4      64      F4      V4      f4      v4      4      4      4      4      4      4      4      4      5      5      &5      65      F5      V5      f5      v5      5      5      5      5      5      5      5      5      6      6      &6      66      F6      V6      f6      v6      6      6      6      6      6      6      6      6      7      7      &7      67      F7      V7      f7      v7      7      7      7      7      7      7                                                                                    QXilG+aO .5}*nuezwYz>~mejTR_cN
#)V@vA& 0W7nH%3Ryua}6AJGj67u_gpB}C(f=anIpMm2[`_]4~cT~	0 9;e7
ra}b$Th{<Hb:ZziT[G      M      S      Y      a      i                      :              97d040f1fa4159db3b0d06badf0c4d81744077.debug    \ .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .data.rel.ro .dynamic .got.plt .data .bss .gnu_debuglink                                                                              8      8      $                                 o       `      `      $                             (                                                   0                         .	                             8   o                                              E   o                                               T             `      `      p                           ^      B                                             h              0       0                                    c              0       0                                  n             7      7                                   w             7      7      R                             }                                                                                  0                                                      d                                                      	                                          p      p                                                x      x                                                            `                                                                                   r                                                                                                                                                                                                                                                           4                                                                                                                                                                                                                                tackle.vfs/lib/http1.0/pkgIndex.tcl                                                                 100664  1751    1751    1337        14144020733 22070   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # Tcl package index file, version 1.0
# This file is generated by the "pkg_mkIndex" command
# and sourced either when an application starts up or
# by a "package unknown" script.  It invokes the
# "package ifneeded" command to set up package-related
# information so that packages will be loaded automatically
# in response to "package require" commands.  When this
# script is sourced, the variable $dir must contain the
# full path name of this file's directory.

package ifneeded http 1.0 [list tclPkgSetup $dir http 1.0 {{http.tcl source {httpCopyDone httpCopyStart httpEof httpEvent httpFinish httpMapReply httpProxyRequired http_code http_config http_data http_formatQuery http_get http_reset http_size http_status http_wait}}}]
                                                                                                                                                                                                                                                                                                 tackle.vfs/lib/http1.0/http.tcl                                                                     100664  1751    1751    22731       14144020733 21317   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # http.tcl
# Client-side HTTP for GET, POST, and HEAD commands.
# These routines can be used in untrusted code that uses the Safesock
# security policy.
# These procedures use a callback interface to avoid using vwait,
# which is not defined in the safe base.
#
# See the http.n man page for documentation

package provide http 1.0

array set http {
    -accept */*
    -proxyhost {}
    -proxyport {}
    -useragent {Tcl http client package 1.0}
    -proxyfilter httpProxyRequired
}
proc http_config {args} {
    global http
    set options [lsort [array names http -*]]
    set usage [join $options ", "]
    if {[llength $args] == 0} {
	set result {}
	foreach name $options {
	    lappend result $name $http($name)
	}
	return $result
    }
    regsub -all -- - $options {} options
    set pat ^-([join $options |])$
    if {[llength $args] == 1} {
	set flag [lindex $args 0]
	if {[regexp -- $pat $flag]} {
	    return $http($flag)
	} else {
	    return -code error "Unknown option $flag, must be: $usage"
	}
    } else {
	foreach {flag value} $args {
	    if {[regexp -- $pat $flag]} {
		set http($flag) $value
	    } else {
		return -code error "Unknown option $flag, must be: $usage"
	    }
	}
    }
}

 proc httpFinish { token {errormsg ""} } {
    upvar #0 $token state
    global errorInfo errorCode
    if {[string length $errormsg] != 0} {
	set state(error) [list $errormsg $errorInfo $errorCode]
	set state(status) error
    }
    catch {close $state(sock)}
    catch {after cancel $state(after)}
    if {[info exists state(-command)]} {
	if {[catch {eval $state(-command) {$token}} err]} {
	    if {[string length $errormsg] == 0} {
		set state(error) [list $err $errorInfo $errorCode]
		set state(status) error
	    }
	}
	unset state(-command)
    }
}
proc http_reset { token {why reset} } {
    upvar #0 $token state
    set state(status) $why
    catch {fileevent $state(sock) readable {}}
    httpFinish $token
    if {[info exists state(error)]} {
	set errorlist $state(error)
	unset state(error)
	eval error $errorlist
    }
}
proc http_get { url args } {
    global http
    if {![info exists http(uid)]} {
	set http(uid) 0
    }
    set token http#[incr http(uid)]
    upvar #0 $token state
    http_reset $token
    array set state {
	-blocksize 	8192
	-validate 	0
	-headers 	{}
	-timeout 	0
	state		header
	meta		{}
	currentsize	0
	totalsize	0
        type            text/html
        body            {}
	status		""
    }
    set options {-blocksize -channel -command -handler -headers \
		-progress -query -validate -timeout}
    set usage [join $options ", "]
    regsub -all -- - $options {} options
    set pat ^-([join $options |])$
    foreach {flag value} $args {
	if {[regexp $pat $flag]} {
	    # Validate numbers
	    if {[info exists state($flag)] && \
		    [regexp {^[0-9]+$} $state($flag)] && \
		    ![regexp {^[0-9]+$} $value]} {
		return -code error "Bad value for $flag ($value), must be integer"
	    }
	    set state($flag) $value
	} else {
	    return -code error "Unknown option $flag, can be: $usage"
	}
    }
    if {! [regexp -nocase {^(http://)?([^/:]+)(:([0-9]+))?(/.*)?$} $url \
	    x proto host y port srvurl]} {
	error "Unsupported URL: $url"
    }
    if {[string length $port] == 0} {
	set port 80
    }
    if {[string length $srvurl] == 0} {
	set srvurl /
    }
    if {[string length $proto] == 0} {
	set url http://$url
    }
    set state(url) $url
    if {![catch {$http(-proxyfilter) $host} proxy]} {
	set phost [lindex $proxy 0]
	set pport [lindex $proxy 1]
    }
    if {$state(-timeout) > 0} {
	set state(after) [after $state(-timeout) [list http_reset $token timeout]]
    }
    if {[info exists phost] && [string length $phost]} {
	set srvurl $url
	set s [socket $phost $pport]
    } else {
	set s [socket $host $port]
    }
    set state(sock) $s

    # Send data in cr-lf format, but accept any line terminators

    fconfigure $s -translation {auto crlf} -buffersize $state(-blocksize)

    # The following is disallowed in safe interpreters, but the socket
    # is already in non-blocking mode in that case.

    catch {fconfigure $s -blocking off}
    set len 0
    set how GET
    if {[info exists state(-query)]} {
	set len [string length $state(-query)]
	if {$len > 0} {
	    set how POST
	}
    } elseif {$state(-validate)} {
	set how HEAD
    }
    puts $s "$how $srvurl HTTP/1.0"
    puts $s "Accept: $http(-accept)"
    puts $s "Host: $host"
    puts $s "User-Agent: $http(-useragent)"
    foreach {key value} $state(-headers) {
	regsub -all \[\n\r\]  $value {} value
	set key [string trim $key]
	if {[string length $key]} {
	    puts $s "$key: $value"
	}
    }
    if {$len > 0} {
	puts $s "Content-Length: $len"
	puts $s "Content-Type: application/x-www-form-urlencoded"
	puts $s ""
	fconfigure $s -translation {auto binary}
	puts -nonewline $s $state(-query)
    } else {
	puts $s ""
    }
    flush $s
    fileevent $s readable [list httpEvent $token]
    if {! [info exists state(-command)]} {
	http_wait $token
    }
    return $token
}
proc http_data {token} {
    upvar #0 $token state
    return $state(body)
}
proc http_status {token} {
    upvar #0 $token state
    return $state(status)
}
proc http_code {token} {
    upvar #0 $token state
    return $state(http)
}
proc http_size {token} {
    upvar #0 $token state
    return $state(currentsize)
}

 proc httpEvent {token} {
    upvar #0 $token state
    set s $state(sock)

     if {[eof $s]} {
	httpEof $token
	return
    }
    if {$state(state) == "header"} {
	set n [gets $s line]
	if {$n == 0} {
	    set state(state) body
	    if {![regexp -nocase ^text $state(type)]} {
		# Turn off conversions for non-text data
		fconfigure $s -translation binary
		if {[info exists state(-channel)]} {
		    fconfigure $state(-channel) -translation binary
		}
	    }
	    if {[info exists state(-channel)] &&
		    ![info exists state(-handler)]} {
		# Initiate a sequence of background fcopies
		fileevent $s readable {}
		httpCopyStart $s $token
	    }
	} elseif {$n > 0} {
	    if {[regexp -nocase {^content-type:(.+)$} $line x type]} {
		set state(type) [string trim $type]
	    }
	    if {[regexp -nocase {^content-length:(.+)$} $line x length]} {
		set state(totalsize) [string trim $length]
	    }
	    if {[regexp -nocase {^([^:]+):(.+)$} $line x key value]} {
		lappend state(meta) $key $value
	    } elseif {[regexp ^HTTP $line]} {
		set state(http) $line
	    }
	}
    } else {
	if {[catch {
	    if {[info exists state(-handler)]} {
		set n [eval $state(-handler) {$s $token}]
	    } else {
		set block [read $s $state(-blocksize)]
		set n [string length $block]
		if {$n >= 0} {
		    append state(body) $block
		}
	    }
	    if {$n >= 0} {
		incr state(currentsize) $n
	    }
	} err]} {
	    httpFinish $token $err
	} else {
	    if {[info exists state(-progress)]} {
		eval $state(-progress) {$token $state(totalsize) $state(currentsize)}
	    }
	}
    }
}
 proc httpCopyStart {s token} {
    upvar #0 $token state
    if {[catch {
	fcopy $s $state(-channel) -size $state(-blocksize) -command \
	    [list httpCopyDone $token]
    } err]} {
	httpFinish $token $err
    }
}
 proc httpCopyDone {token count {error {}}} {
    upvar #0 $token state
    set s $state(sock)
    incr state(currentsize) $count
    if {[info exists state(-progress)]} {
	eval $state(-progress) {$token $state(totalsize) $state(currentsize)}
    }
    if {([string length $error] != 0)} {
	httpFinish $token $error
    } elseif {[eof $s]} {
	httpEof $token
    } else {
	httpCopyStart $s $token
    }
}
 proc httpEof {token} {
    upvar #0 $token state
    if {$state(state) == "header"} {
	# Premature eof
	set state(status) eof
    } else {
	set state(status) ok
    }
    set state(state) eof
    httpFinish $token
}
proc http_wait {token} {
    upvar #0 $token state
    if {![info exists state(status)] || [string length $state(status)] == 0} {
	vwait $token\(status)
    }
    if {[info exists state(error)]} {
	set errorlist $state(error)
	unset state(error)
	eval error $errorlist
    }
    return $state(status)
}

# Call http_formatQuery with an even number of arguments, where the first is
# a name, the second is a value, the third is another name, and so on.

proc http_formatQuery {args} {
    set result ""
    set sep ""
    foreach i $args {
	append result  $sep [httpMapReply $i]
	if {$sep != "="} {
	    set sep =
	} else {
	    set sep &
	}
    }
    return $result
}

# do x-www-urlencoded character mapping
# The spec says: "non-alphanumeric characters are replaced by '%HH'"
# 1 leave alphanumerics characters alone
# 2 Convert every other character to an array lookup
# 3 Escape constructs that are "special" to the tcl parser
# 4 "subst" the result, doing all the array substitutions

 proc httpMapReply {string} {
    global httpFormMap
    set alphanumeric	a-zA-Z0-9
    if {![info exists httpFormMap]} {

	for {set i 1} {$i <= 256} {incr i} {
	    set c [format %c $i]
	    if {![string match \[$alphanumeric\] $c]} {
		set httpFormMap($c) %[format %.2x $i]
	    }
	}
	# These are handled specially
	array set httpFormMap {
	    " " +   \n %0d%0a
	}
    }
    regsub -all \[^$alphanumeric\] $string {$httpFormMap(&)} string
    regsub -all \n $string {\\n} string
    regsub -all \t $string {\\t} string
    regsub -all {[][{})\\]\)} $string {\\&} string
    return [subst $string]
}

# Default proxy filter.
 proc httpProxyRequired {host} {
    global http
    if {[info exists http(-proxyhost)] && [string length $http(-proxyhost)]} {
	if {![info exists http(-proxyport)] || ![string length $http(-proxyport)]} {
	    set http(-proxyport) 8080
	}
	return [list $http(-proxyhost) $http(-proxyport)]
    } else {
	return {}
    }
}
                                       tackle.vfs/lib/json/json_write.tcl                                                                  100664  1751    1751    12256       14144020733 22277   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # json_write.tcl --
#
#	Commands for the generation of JSON (Java Script Object Notation).
#
# Copyright (c) 2009-2011 Andreas Kupries <andreas_kupries@sourceforge.net>
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# RCS: @(#) $Id: json_write.tcl,v 1.2 2011/08/24 20:09:44 andreas_kupries Exp $

# ### ### ### ######### ######### #########
## Requisites

package require Tcl 8.5

namespace eval ::json::write {
    namespace export \
	string array object indented aligned

    namespace ensemble create
}

# ### ### ### ######### ######### #########
## API.

proc ::json::write::indented {{bool {}}} {
    variable indented

    if {[llength [info level 0]] > 2} {
	return -code error {wrong # args: should be "json::write indented ?bool?"}
    } elseif {[llength [info level 0]] == 2} {
	if {![::string is boolean -strict $bool]} {
	    return -code error "Expected boolean, got \"$bool\""
	}
	set indented $bool
	if {!$indented} {
	    variable aligned 0
	}
    }

    return $indented
}

proc ::json::write::aligned {{bool {}}} {
    variable aligned

    if {[llength [info level 0]] > 2} {
	return -code error {wrong # args: should be "json::write aligned ?bool?"}
    } elseif {[llength [info level 0]] == 2} {
	if {![::string is boolean -strict $bool]} {
	    return -code error "Expected boolean, got \"$bool\""
	}
	set aligned $bool
	if {$aligned} {
	    variable indented 1
	}
    }

    return $aligned
}

proc ::json::write::string {s} {
    variable quotes
    return "\"[::string map $quotes $s]\""
}

proc ::json::write::array {args} {
    # always compact form.
    return "\[[join $args ,]\]"
}

proc ::json::write::object {args} {
    # The dict in args maps string keys to json-formatted data. I.e.
    # we have to quote the keys, but not the values, as the latter are
    # already in the proper format.

    variable aligned
    variable indented

    if {[llength $args] %2 == 1} {
	return -code error {wrong # args, expected an even number of arguments}
    }

    set dict {}
    foreach {k v} $args {
	lappend dict [string $k] $v
    }

    if {$aligned} {
	set max [MaxKeyLength $dict]
    }

    if {$indented} {
	set content {}
	foreach {k v} $dict {
	    if {$aligned} {
		set k [AlignLeft $max $k]
	    }
	    if {[::string match *\n* $v]} {
		# multi-line value
		lappend content "    $k : [Indent $v {    } 1]"
	    } else {
		# single line value.
		lappend content "    $k : $v"
	    }
	}
	if {[llength $content]} {
	    return "\{\n[join $content ,\n]\n\}"
	} else {
	    return "\{\}"
	}
    } else {
	# ultra compact form.
	set tmp {}
	foreach {k v} $dict {
	    lappend tmp "$k:$v"
	}
	return "\{[join $tmp ,]\}"
    }
}

# ### ### ### ######### ######### #########
## Internals.

proc ::json::write::Indent {text prefix skip} {
    set pfx ""
    set result {}
    foreach line [split $text \n] {
	if {!$skip} { set pfx $prefix } else { incr skip -1 }
	lappend result ${pfx}$line
    }
    return [join $result \n]
}

proc ::json::write::MaxKeyLength {dict} {
    # Find the max length of the keys in the dictionary.

    set lengths 0 ; # This will be the max if the dict is empty, and
		    # prevents the mathfunc from throwing errors for
		    # that case.

    foreach str [dict keys $dict] {
	lappend lengths [::string length $str]
    }

    return [tcl::mathfunc::max {*}$lengths]
}

proc ::json::write::AlignLeft {fieldlen str} {
    return [format %-${fieldlen}s $str]
    #return $str[::string repeat { } [expr {$fieldlen - [::string length $str]}]]
}

# ### ### ### ######### ######### #########

namespace eval ::json::write {
    # Configuration of the layout to write.

    # indented = boolean. objects are indented.
    # aligned  = boolean. object keys are aligned vertically.

    # aligned  => indented.

    # Combinations of the format specific entries
    # I A |
    # - - + ---------------------
    # 0 0 | Ultracompact (no whitespace, single line)
    # 1 0 | Indented
    # 0 1 | Not possible, per the implications above.
    # 1 1 | Indented + vertically aligned keys
    # - - + ---------------------

    variable indented 1
    variable aligned  1

    variable quotes \
	[list "\"" "\\\"" \\ \\\\ \b \\b \f \\f \n \\n \r \\r \t \\t \
	     \x00 \\u0000 \x01 \\u0001 \x02 \\u0002 \x03 \\u0003 \
	     \x04 \\u0004 \x05 \\u0005 \x06 \\u0006 \x07 \\u0007 \
	     \x0b \\u000b \x0e \\u000e \x0f \\u000f \x10 \\u0010 \
	     \x11 \\u0011 \x12 \\u0012 \x13 \\u0013 \x14 \\u0014 \
	     \x15 \\u0015 \x16 \\u0016 \x17 \\u0017 \x18 \\u0018 \
	     \x19 \\u0019 \x1a \\u001a \x1b \\u001b \x1c \\u001c \
	     \x1d \\u001d \x1e \\u001e \x1f \\u001f \x7f \\u007f \
	     \x80 \\u0080 \x81 \\u0081 \x82 \\u0082 \x83 \\u0083 \
	     \x84 \\u0084 \x85 \\u0085 \x86 \\u0086 \x87 \\u0087 \
	     \x88 \\u0088 \x89 \\u0089 \x8a \\u008a \x8b \\u008b \
	     \x8c \\u008c \x8d \\u008d \x8e \\u008e \x8f \\u008f \
	     \x90 \\u0090 \x91 \\u0091 \x92 \\u0092 \x93 \\u0093 \
	     \x94 \\u0094 \x95 \\u0095 \x96 \\u0096 \x97 \\u0097 \
	     \x98 \\u0098 \x99 \\u0099 \x9a \\u009a \x9b \\u009b \
	     \x9c \\u009c \x9d \\u009d \x9e \\u009e \x9f \\u009f ]
}

# ### ### ### ######### ######### #########
## Ready

package provide json::write 1.0.3
return
                                                                                                                                                                                                                                                                                                                                                  tackle.vfs/lib/json/pkgIndex.tcl                                                                    100664  1751    1751    471         14144020733 21621   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # Tcl package index file, version 1.1

if {![package vsatisfies [package provide Tcl] 8.4]} {return}
package ifneeded json 1.3.4 [list source [file join $dir json.tcl]]

if {![package vsatisfies [package provide Tcl] 8.5]} {return}
package ifneeded json::write 1.0.3 [list source [file join $dir json_write.tcl]]
                                                                                                                                                                                                       tackle.vfs/lib/json/json.tcl                                                                        100664  1751    1751    16435       14144020733 21070   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # json.tcl --
#
#	JSON parser for Tcl. Management code, Tcl/C detection and selection.
#
# Copyright (c) 2013 by Andreas Kupries

# @mdgen EXCLUDE: jsonc.tcl

package require Tcl 8.4
namespace eval ::json {}

# ### ### ### ######### ######### #########
## Management of json implementations.

# ::json::LoadAccelerator --
#
#	Loads a named implementation, if possible.
#
# Arguments:
#	key	Name of the implementation to load.
#
# Results:
#	A boolean flag. True if the implementation
#	was successfully loaded; and False otherwise.

proc ::json::LoadAccelerator {key} {
    variable accel
    set r 0
    switch -exact -- $key {
	critcl {
	    # Critcl implementation of json requires Tcl 8.4.
	    if {![package vsatisfies [package provide Tcl] 8.4]} {return 0}
	    if {[catch {package require tcllibc}]} {return 0}
	    # Check for the jsonc 1.1.1 API we are fixing later.
	    set r [llength [info commands ::json::many_json2dict_critcl]]
	}
	tcl {
	    variable selfdir
	    source [file join $selfdir json_tcl.tcl]
	    set r 1
	}
        default {
            return -code error "invalid accelerator/impl. package $key:\
                must be one of [join [KnownImplementations] {, }]"
        }
    }
    set accel($key) $r
    return $r
}

# ::json::SwitchTo --
#
#	Activates a loaded named implementation.
#
# Arguments:
#	key	Name of the implementation to activate.
#
# Results:
#	None.

proc ::json::SwitchTo {key} {
    variable accel
    variable loaded
    variable apicmds

    if {[string equal $key $loaded]} {
	# No change, nothing to do.
	return
    } elseif {![string equal $key ""]} {
	# Validate the target implementation of the switch.

	if {![info exists accel($key)]} {
	    return -code error "Unable to activate unknown implementation \"$key\""
	} elseif {![info exists accel($key)] || !$accel($key)} {
	    return -code error "Unable to activate missing implementation \"$key\""
	}
    }

    # Deactivate the previous implementation, if there was any.

    if {![string equal $loaded ""]} {
	foreach c $apicmds {
	    rename ::json::${c} ::json::${c}_$loaded
	}
    }

    # Activate the new implementation, if there is any.

    if {![string equal $key ""]} {
	foreach c $apicmds {
	    rename ::json::${c}_$key ::json::${c}
	}
    }

    # Remember the active implementation, for deactivation by future
    # switches.

    set loaded $key
    return
}

# ::json::Implementations --
#
#	Determines which implementations are
#	present, i.e. loaded.
#
# Arguments:
#	None.
#
# Results:
#	A list of implementation keys.

proc ::json::Implementations {} {
    variable accel
    set res {}
    foreach n [array names accel] {
	if {!$accel($n)} continue
	lappend res $n
    }
    return $res
}

# ::json::KnownImplementations --
#
#	Determines which implementations are known
#	as possible implementations.
#
# Arguments:
#	None.
#
# Results:
#	A list of implementation keys. In the order
#	of preference, most prefered first.

proc ::json::KnownImplementations {} {
    return {critcl tcl}
}

proc ::json::Names {} {
    return {
	critcl {tcllibc based}
	tcl    {pure Tcl}
    }
}

# ### ### ### ######### ######### #########
## Initialization: Data structures.

namespace eval ::json {
    variable  selfdir [file dirname [info script]]
    variable  accel
    array set accel   {tcl 0 critcl 0}
    variable  loaded  {}

    variable apicmds {
	json2dict
	many-json2dict
    }
}

# ### ### ### ######### ######### #########
## Wrapper fix for the jsonc package to match APIs.

proc ::json::many-json2dict_critcl {args} {
    eval [linsert $args 0 ::json::many_json2dict_critcl]
}

# ### ### ### ######### ######### #########
## Initialization: Choose an implementation,
## most prefered first. Loads only one of the
## possible implementations. And activates it.

namespace eval ::json {
    variable e
    foreach e [KnownImplementations] {
	if {[LoadAccelerator $e]} {
	    SwitchTo $e
	    break
	}
    }
    unset e
}

# ### ### ### ######### ######### #########
## Tcl implementation of validation, shared for Tcl and C implementation.
##
## The regexp based validation is consistently faster than json-c.
## Suspected reasons: Tcl REs are mainly in C as well, and json-c has
## overhead in constructing its own data structures. While irrelevant
## to validation json-c still builds them, it has no mode doing pure
## syntax checking.

namespace eval ::json {
    # Regular expression for tokenizing a JSON text (cf. http://json.org/)

    # tokens consisting of a single character
    variable singleCharTokens { "{" "}" ":" "\\[" "\\]" "," }
    variable singleCharTokenRE "\[[join $singleCharTokens {}]\]"

    # quoted string tokens
    variable escapableREs { "[\\\"\\\\/bfnrt]" "u[[:xdigit:]]{4}" "." }
    variable escapedCharRE "\\\\(?:[join $escapableREs |])"
    variable unescapedCharRE {[^\\\"]}
    variable stringRE "\"(?:$escapedCharRE|$unescapedCharRE)*\""

    # as above, for validation
    variable escapableREsv { "[\\\"\\\\/bfnrt]" "u[[:xdigit:]]{4}" }
    variable escapedCharREv "\\\\(?:[join $escapableREsv |])"
    variable stringREv "\"(?:$escapedCharREv|$unescapedCharRE)*\""

    # (unquoted) words
    variable wordTokens { "true" "false" "null" }
    variable wordTokenRE [join $wordTokens "|"]

    # number tokens
    # negative lookahead (?!0)[[:digit:]]+ might be more elegant, but
    # would slow down tokenizing by a factor of up to 3!
    variable positiveRE {[1-9][[:digit:]]*}
    variable cardinalRE "-?(?:$positiveRE|0)"
    variable fractionRE {[.][[:digit:]]+}
    variable exponentialRE {[eE][+-]?[[:digit:]]+}
    variable numberREa "${cardinalRE}(?:$fractionRE)?(?:$exponentialRE)?"
    variable numberREb "${fractionRE}(?:$exponentialRE)?"
    variable numberREc "${cardinalRE}\[.\](?:$exponentialRE)?"
    variable numberRE  "$numberREa|$numberREb|$numberREc"
    variable numberRE  "$numberREa|$numberREb|$numberREc"

    # JSON token, and validation
    variable tokenRE "$singleCharTokenRE|$stringRE|$wordTokenRE|$numberRE"
    variable tokenREv "$singleCharTokenRE|$stringREv|$wordTokenRE|$numberRE"

    # 0..n white space characters
    set whiteSpaceRE {[[:space:]]*}

    # Regular expression for validating a JSON text
    variable validJsonRE "^(?:${whiteSpaceRE}(?:$tokenREv))*${whiteSpaceRE}$"
}


# Validate JSON text
# @param jsonText JSON text
# @return 1 iff $jsonText conforms to the JSON grammar
#           (@see http://json.org/)
proc ::json::validate {jsonText} {
    variable validJsonRE

    return [regexp -- $validJsonRE $jsonText]
}

# ### ### ### ######### ######### #########
## These three procedures shared between Tcl and Critcl implementations.
## See also package "json::write".

proc ::json::dict2json {dictVal} {
    # XXX: Currently this API isn't symmetrical, as to create proper
    # XXX: JSON text requires type knowledge of the input data
    set json ""
    set prefix ""

    foreach {key val} $dictVal {
	# key must always be a string, val may be a number, string or
	# bare word (true|false|null)
	if {0 && ![string is double -strict $val]
	    && ![regexp {^(?:true|false|null)$} $val]} {
	    set val "\"$val\""
	}
    	append json "$prefix\"$key\": $val" \n
	set prefix ,
    }

    return "\{${json}\}"
}

proc ::json::list2json {listVal} {
    return "\[[join $listVal ,]\]"
}

proc ::json::string2json {str} {
    return "\"$str\""
}

# ### ### ### ######### ######### #########
## Ready

package provide json 1.3.4
                                                                                                                                                                                                                                   tackle.vfs/lib/json/jsonc.tcl                                                                       100664  1751    1751    10215       14144020733 21221   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # jsonc.tcl --
#
#       Implementation of a JSON parser in C.
#	Binding to a yacc/bison parser by Mikhail.
#
# Copyright (c) 2013,2015 - critcl wrapper - Andreas Kupries <andreas_kupries@users.sourceforge.net>
# Copyright (c) 2013      - C binding      - mi+tcl.tk-2013@aldan.algebra.com

package require critcl
# @sak notprovided jsonc
package provide jsonc 1.1.2
package require Tcl 8.4

#critcl::cheaders -g
#critcl::debug memory symbols
critcl::cheaders -Ic c/*.h
critcl::csources c/*.c

# # ## ### Import base declarations, forwards ### ## # #

critcl::ccode {
    #include <json_y.h>
}

# # ## ### Main Conversion ### ## # #

namespace eval ::json {
    critcl::ccommand json2dict_critcl {dummy I objc objv} {
	struct context context = { NULL };

	if (objc != 2) {
	    Tcl_WrongNumArgs(I, 1, objv, "json");
	    return TCL_ERROR;
	}

	context.text   = Tcl_GetStringFromObj(objv[1], &context.remaining);
	context.I      = I;
	context.has_error = 0;
	context.result = TCL_ERROR;

	jsonparse (&context);
	return context.result;
    }

    # Issue with critcl 2 used here. Cannot use '-', incomplete distinction of C and Tcl names.
    # The json.tcl file making use of this code has a wrapper fixing the issue.
    critcl::ccommand many_json2dict_critcl {dummy I objc objv} {
	struct context context = { NULL };

	int                      max;
	int                      found;

	Tcl_Obj* result = Tcl_NewListObj (0, NULL);

	if ((objc < 2) || (objc > 3)) {
	    Tcl_WrongNumArgs(I, 1, objv, "jsonText ?max?");
	    return TCL_ERROR;
	}

	if (objc == 3) {
	    if (Tcl_GetIntFromObj(I, objv[2], &max) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (max <= 0) {
		Tcl_AppendResult (I, "Bad limit ",
				  Tcl_GetString (objv[2]),
				  " of json entities to extract.",
				  NULL);
		Tcl_SetErrorCode (I, "JSON", "BAD-LIMIT", NULL);
		return TCL_ERROR;
	    }

	} else {
	    max = -1;
	}

	context.text   = Tcl_GetStringFromObj(objv[1], &context.remaining);
	context.I      = I;
	context.has_error = 0;
	found  = 0;

	/* Iterate over the input until
	 * - we have gotten all requested values.
	 * - we have run out of input
	 * - we have run into an error
	 */

	while ((max < 0) || max) {
	    context.result = TCL_ERROR;
	    jsonparse (&context);

	    /* parse error, abort */
	    if (context.result != TCL_OK) {
		Tcl_DecrRefCount (result);
		return TCL_ERROR;
	    }

	    /* Proper value extracted, extend result */
	    found ++;
	    Tcl_ListObjAppendElement(I, result,
				     Tcl_GetObjResult (I));

	    /* Count down on the number of still missing
	     * values, if not asking for all (-1)
	     */
	    if (max > 0) max --;

	    /* Jump over trailing whitespace for proper end-detection */
	    jsonskip (&context);

	    /* Abort if we have consumed all input */
	    if (!context.remaining) break;

	    /* Clear scratch pad before continuing */
	    context.obj = NULL;
	}

	/* While all parses were ok we reached end of
	 * input without getting all requested values,
	 * this is an error
	 */
	if (max > 0) {
	    char buf [30];
	    sprintf (buf, "%d", found);
            Tcl_ResetResult (I);
	    Tcl_AppendResult (I, "Bad limit ",
			      Tcl_GetString (objv[2]),
			      " of json entities to extract, found only ",
			      buf,
			      ".",
			      NULL);
	    Tcl_SetErrorCode (I, "JSON", "BAD-LIMIT", "TOO", "LARGE", NULL);
	    Tcl_DecrRefCount (result);
	    return TCL_ERROR;
	}

	/* We are good and done */
	Tcl_SetObjResult(I, result);
	return TCL_OK;
    }

    if 0 {critcl::ccommand validate_critcl {dummy I objc objv} {
	struct context context = { NULL };

	if (objc != 2) {
	    Tcl_WrongNumArgs(I, 1, objv, "jsonText");
	    return TCL_ERROR;
	}

	context.text   = Tcl_GetStringFromObj(objv[1], &context.remaining);
	context.I      = I;
	context.result = TCL_ERROR;

	/* Iterate over the input until we have run
	 * out of text, or encountered an error. We
	 * use only the lexer here, and told it to not
	* create superfluous token values.
	 */

	while (context.remaining) {
	    if (jsonlex (&context) == -1) {
		Tcl_SetObjResult(I, Tcl_NewBooleanObj (0));
		return TCL_OK;
	    }
	}

	/* We are good and done */
	Tcl_SetObjResult(I, Tcl_NewBooleanObj (1));
	return TCL_OK;
    }}
}
                                                                                                                                                                                                                                                                                                                                                                                   tackle.vfs/lib/json/json_tcl.tcl                                                                    100664  1751    1751    21105       14144020733 21720   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        #
#   JSON parser for Tcl.
#
#   See http://www.json.org/ && http://www.ietf.org/rfc/rfc4627.txt
#
#   Total rework of the code published with version number 1.0 by
#   Thomas Maeder, Glue Software Engineering AG
#
#   $Id: json.tcl,v 1.7 2011/11/10 21:05:58 andreas_kupries Exp $
#

if {![package vsatisfies [package provide Tcl] 8.5]} {
    package require dict
}

# Parse JSON text into a dict
# @param jsonText JSON text
# @return dict (or list) containing the object represented by $jsonText
proc ::json::json2dict_tcl {jsonText} {
    variable tokenRE

    set tokens [regexp -all -inline -- $tokenRE $jsonText]
    set nrTokens [llength $tokens]
    set tokenCursor 0

    #puts I:($jsonText)
    #puts T:\t[join $tokens \nT:\t]
    return [parseValue $tokens $nrTokens tokenCursor]
}

# Parse multiple JSON entities in a string into a list of dictionaries
# @param jsonText JSON text to parse
# @param max      Max number of entities to extract.
# @return list of (dict (or list) containing the objects) represented by $jsonText
proc ::json::many-json2dict_tcl {jsonText {max -1}} {
    variable tokenRE

    if {$max == 0} {
	return -code error -errorCode {JSON BAD-LIMIT ZERO} \
	    "Bad limit 0 of json entities to extract."
    }

    set tokens [regexp -all -inline -- $tokenRE $jsonText]
    set nrTokens [llength $tokens]
    set tokenCursor 0

    set result {}
    set found 0
    set n $max
    while {$n != 0} {
	if {$tokenCursor >= $nrTokens} break
	lappend result [parseValue $tokens $nrTokens tokenCursor]
	incr found
	if {$n > 0} {incr n -1}
    }

    if {$n > 0} {
	return -code error -errorCode {JSON BAD-LIMIT TOO LARGE} \
	    "Bad limit $max of json entities to extract, found only $found."
    }

    return $result
}

# Throw an exception signaling an unexpected token
proc ::json::unexpected {tokenCursor token expected} {
    return -code error -errorcode [list JSON UNEXPECTED $tokenCursor $expected] \
	"unexpected token \"$token\" at position $tokenCursor; expecting $expected"
}

# Get rid of the quotes surrounding a string token and substitute the
# real characters for escape sequences within it
# @param token
# @return unquoted unescaped value of the string contained in $token
proc ::json::unquoteUnescapeString {tokenCursor token} {
    variable stringREv
    set unquoted [string range $token 1 end-1]

    if {![regexp $stringREv $token]} {
	unexpected $tokenCursor $token STRING
    }

    set res [subst -nocommands -novariables $unquoted]
    return $res
}

# Parse an object member
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @param objectDictName name (in caller's context) of dict
#                       representing the JSON object of which to
#                       parse the next member
proc ::json::parseObjectMember {tokens nrTokens tokenCursorName objectDictName} {
    upvar $tokenCursorName tokenCursor
    upvar $objectDictName objectDict

    set token [lindex $tokens $tokenCursor]
    set tc $tokenCursor
    incr tokenCursor

    set leadingChar [string index $token 0]
    if {$leadingChar eq "\""} {
        set memberName [unquoteUnescapeString $tc $token]

        if {$tokenCursor == $nrTokens} {
            unexpected $tokenCursor "END" "\":\""
        } else {
            set token [lindex $tokens $tokenCursor]
            incr tokenCursor

            if {$token eq ":"} {
                set memberValue [parseValue $tokens $nrTokens tokenCursor]
                dict set objectDict $memberName $memberValue
            } else {
                unexpected $tokenCursor $token "\":\""
            }
        }
    } else {
        unexpected $tokenCursor $token "STRING"
    }
}

# Parse the members of an object
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @param objectDictName name (in caller's context) of dict
#                       representing the JSON object of which to
#                       parse the next member
proc ::json::parseObjectMembers {tokens nrTokens tokenCursorName objectDictName} {
    upvar $tokenCursorName tokenCursor
    upvar $objectDictName objectDict

    while true {
        parseObjectMember $tokens $nrTokens tokenCursor objectDict

        set token [lindex $tokens $tokenCursor]
        incr tokenCursor

        switch -exact $token {
            "," {
                # continue
            }
            "\}" {
                break
            }
            default {
                unexpected $tokenCursor $token "\",\"|\"\}\""
            }
        }
    }
}

# Parse an object
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @return parsed object (Tcl dict)
proc ::json::parseObject {tokens nrTokens tokenCursorName} {
    upvar $tokenCursorName tokenCursor

    if {$tokenCursor == $nrTokens} {
        unexpected $tokenCursor "END" "OBJECT"
    } else {
        set result [dict create]

        set token [lindex $tokens $tokenCursor]

        if {$token eq "\}"} {
            # empty object
            incr tokenCursor
        } else {
            parseObjectMembers $tokens $nrTokens tokenCursor result
        }

        return $result
    }
}

# Parse the elements of an array
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @param resultName name (in caller's context) of the list
#                   representing the JSON array
proc ::json::parseArrayElements {tokens nrTokens tokenCursorName resultName} {
    upvar $tokenCursorName tokenCursor
    upvar $resultName result

    while true {
        lappend result [parseValue $tokens $nrTokens tokenCursor]

        if {$tokenCursor == $nrTokens} {
            unexpected $tokenCursor "END" "\",\"|\"\]\""
        } else {
            set token [lindex $tokens $tokenCursor]
            incr tokenCursor

            switch -exact $token {
                "," {
                    # continue
                }
                "\]" {
                    break
                }
                default {
                    unexpected $tokenCursor $token "\",\"|\"\]\""
                }
            }
        }
    }
}

# Parse an array
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @return parsed array (Tcl list)
proc ::json::parseArray {tokens nrTokens tokenCursorName} {
    upvar $tokenCursorName tokenCursor

    if {$tokenCursor == $nrTokens} {
        unexpected $tokenCursor "END" "ARRAY"
    } else {
        set result {}

        set token [lindex $tokens $tokenCursor]

        set leadingChar [string index $token 0]
        if {$leadingChar eq "\]"} {
            # empty array
            incr tokenCursor
        } else {
            parseArrayElements $tokens $nrTokens tokenCursor result
        }

        return $result
    }
}

# Parse a value
# @param tokens list of tokens
# @param nrTokens length of $tokens
# @param tokenCursorName name (in caller's context) of variable
#                        holding current position in $tokens
# @return parsed value (dict, list, string, number)
proc ::json::parseValue {tokens nrTokens tokenCursorName} {
    upvar $tokenCursorName tokenCursor

    if {$tokenCursor == $nrTokens} {
        unexpected $tokenCursor "END" "VALUE"
    } else {
        set token [lindex $tokens $tokenCursor]
	set tc $tokenCursor
        incr tokenCursor

        set leadingChar [string index $token 0]
        switch -exact -- $leadingChar {
            "\{" {
                return [parseObject $tokens $nrTokens tokenCursor]
            }
            "\[" {
                return [parseArray $tokens $nrTokens tokenCursor]
            }
            "\"" {
                # quoted string
                return [unquoteUnescapeString $tc $token]
            }
            "t" -
            "f" -
            "n" {
                # bare word: true, false, null (return as is)
                return $token
            }
            default {
                # number?
                if {[string is double -strict $token]} {
                    return $token
                } else {
                    unexpected $tokenCursor $token "VALUE"
                }
            }
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                           tackle.vfs/lib/uri/pkgIndex.tcl                                                                     100664  1751    1751    356         14144020733 21451   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        if {![package vsatisfies [package provide Tcl] 8.2]} {
    # FRINK: nocheck
    return
}
package ifneeded uri      1.2.7 [list source [file join $dir uri.tcl]]
package ifneeded uri::urn 1.0.3 [list source [file join $dir urn-scheme.tcl]]
                                                                                                                                                                                                                                                                                  tackle.vfs/lib/uri/urn-scheme.tcl                                                                   100664  1751    1751    11273       14144020733 22006   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # urn-scheme.tcl - Copyright (C) 2001 Pat Thoyts <patthoyts@users.sf.net>
#
# extend the uri package to deal with URN (RFC 2141)
# see http://www.normos.org/ietf/rfc/rfc2141.txt
#
# Released under the tcllib license.
#
# $Id: urn-scheme.tcl,v 1.11 2005/09/28 04:51:24 andreas_kupries Exp $
# -------------------------------------------------------------------------

package require uri      1.1.2

namespace eval ::uri {}
namespace eval ::uri::urn {}

# -------------------------------------------------------------------------

# Description:
#   Called by uri::split with a url to split into its parts.
#
proc ::uri::SplitUrn {uri} {
    #@c Split the given uri into then URN component parts
    #@a uri: the URI to split without it's scheme part.
    #@r List of the component parts suitable for 'array set'

    upvar \#0 [namespace current]::urn::URNpart pattern
    array set parts {nid {} nss {}}
    if {[regexp -- ^$pattern $uri -> parts(nid) parts(nss)]} {
        return [array get parts]
    } else {
        error "invalid urn syntax: \"$uri\" could not be parsed"
    }
}


# -------------------------------------------------------------------------

proc ::uri::JoinUrn args {
    #@c Join the parts of a URN scheme URI
    #@a list of nid value nss value
    #@r a valid string representation for your URI
    variable urn::NIDpart

    array set parts [list nid {} nss {}]
    array set parts $args
    if {! [regexp -- ^$NIDpart$ $parts(nid)]} {
        error "invalid urn: nid is invalid"
    }
    set url "urn:$parts(nid):[urn::quote $parts(nss)]"
    return $url
}

# -------------------------------------------------------------------------

# Quote the disallowed characters according to the RFC for URN scheme.
# ref: RFC2141 sec2.2
proc ::uri::urn::quote {url} {
    variable trans
    
    set ndx 0
    set result ""
    while {[regexp -indices -- "\[^$trans\]" $url r]} {
        set ndx [lindex $r 0]

        set ch [string index $url $ndx]
        if {$ch eq "\0"} {
            error "invalid character: character $chr is not allowed"
        }

        # Decode into UTF-8 bytes.
        set rep {}
        foreach ch [split [encoding convertto utf-8 $ch] {}] {
            scan $ch %c chr
            append rep %[format %.2X $chr]
        }
        
        incr ndx -1
        append result [string range $url 0 $ndx] $rep
        incr ndx 2
        set url [string range $url $ndx end]
    }
    append result $url
    return $result
}

# -------------------------------------------------------------------------
# Perform the reverse of urn::quote.

if { [package vcompare [package provide Tcl] 8.3] < 0 } {
    # Before Tcl 8.3 we do not have 'regexp -start'. We simulate it by
    # using 'string range' and adjusting the match results.

    proc ::uri::urn::unquote {url} {
        set result ""
        set start 0
        while {[regexp -indices {%[0-9a-fA-F]{2}} [string range $url $start end] match]} {
            foreach {first last} $match break
            incr first $start ; # Make the indices relative to the true string.
            incr last  $start ; # I.e. undo the effect of the 'string range' on match results.
            append result [string range $url $start [expr {$first - 1}]]
            append result [format %c 0x[string range $url [incr first] $last]]
            set start [incr last]
        }
        append result [string range $url $start end]
        # Recode the array of utf-8 bytes to the proper internal rep.
        return [encoding convertfrom utf-8 $result]
    }
} else {
    proc ::uri::urn::unquote {url} {
        set result ""
        set start 0
        while {[regexp -start $start -indices {%[0-9a-fA-F]{2}} $url match]} {
            foreach {first last} $match break
            append result [string range $url $start [expr {$first - 1}]]
            append result [format %c 0x[string range $url [incr first] $last]]
            set start [incr last]
        }
        append result [string range $url $start end]
        # Recode the array of utf-8 bytes to the proper internal rep.
        return [encoding convertfrom utf-8 $result]
    }
}

# -------------------------------------------------------------------------

::uri::register {urn URN} {
	variable NIDpart {[a-zA-Z0-9][a-zA-Z0-9-]{0,31}}
        variable esc {%[0-9a-fA-F]{2}}
        variable trans {a-zA-Z0-9$_.+!*'(,):=@;-}
        variable NSSpart "($esc|\[$trans\])+"
        variable URNpart "($NIDpart):($NSSpart)"
        variable schemepart $URNpart
	variable url "urn:$NIDpart:$NSSpart"
}

# -------------------------------------------------------------------------

package provide uri::urn 1.0.3

# -------------------------------------------------------------------------
# Local Variables:
#   indent-tabs-mode: nil
# End:
                                                                                                                                                                                                                                                                                                                                     tackle.vfs/lib/uri/uri.tcl                                                                          100664  1751    1751    122675      14144020733 20570   0                                                                                                    ustar 00nathanielalcock                 nathanielalcock                                                                                                                                                                                                        # uri.tcl --
#
#	URI parsing and fetch
#
# Copyright (c) 2000 Zveno Pty Ltd
# Copyright (c) 2006 Pierre DAVID <Pierre.David@crc.u-strasbg.fr>
# Copyright (c) 2006 Andreas Kupries <andreas_kupries@users.sourceforge.net>
# Copyright (c) 2017 Keith Nash <kjnash@users.sourceforge.net>
# Steve Ball, http://www.zveno.com/
# Derived from urls.tcl by Andreas Kupries
#
# CVS: $Id: uri.tcl,v 1.36 2011/03/23 04:39:54 andreas_kupries Exp $

package require Tcl 8.2

namespace eval ::uri {

    namespace export split join
    namespace export resolve isrelative
    namespace export geturl
    namespace export canonicalize
    namespace export register
    namespace export setQuirkOption

    variable file:counter 0

    variable Quirks
    set Quirks(NoInitialSlash)      1
    set Quirks(NoExtraKeys)         0
    set Quirks(HostAsDriveLetter)   0
    set Quirks(RemoveDoubleSlashes) 1
    # Defaults for v1.2.7: {1 0 0 1}

    # --------------------------------------------------------------------------
    # These variables are used by uri::register and are a repository of
    # scheme-related pattern information that may be accessed by external code.
    # None is used by the other commands of this package.
    # --------------------------------------------------------------------------
    variable schemes       {}
    variable schemePattern ""
    variable url           ""
    variable url2part
    array set url2part     {}

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # basic regular expressions used in URL syntax.

    namespace eval basic {
	# ----------------------------------------------------------------------
	# These variables are used to construct the variables used by commands.
	# ----------------------------------------------------------------------
	variable	digit		{[0-9]}
	variable	hex		{[0-9A-Fa-f]}
	variable	alphaDigit	{[A-Za-z0-9]}
	variable	alphaDigitMinus	{[A-Za-z0-9-]}
	variable	escape		"%${hex}${hex}"
	variable	digits		"${digit}+"

	variable	toplabel	\
		"(${alphaDigit}${alphaDigitMinus}*${alphaDigit}\\.?|${alphaDigit}\\.?)"
	variable	domainlabel	\
		"(${alphaDigit}${alphaDigitMinus}*${alphaDigit}|${alphaDigit})"

	variable	hostname	\
		"((${domainlabel}\\.)*${toplabel})"
	variable	hostnumber4	\
		"(?:${digits}\\.${digits}\\.${digits}\\.${digits})"
	variable	hostnumber6	{(?:\[[^]]*\])}
	variable	hostnumber	"(${hostnumber4}|${hostnumber6})"

	variable	usrCharN	{[a-zA-Z0-9$_.+!*'(,);?&=-]}
	variable	usrChar		"(${usrCharN}|${escape})"

	# ----------------------------------------------------------------------
	# >>> THESE VARIABLES ARE THE ONLY ONES USED BY COMMANDS <<<
	# ----------------------------------------------------------------------

	variable	hostspec	"${hostname}|${hostnumber}"
	variable	port		"${digit}*"
	variable	user		"${usrChar}*"
	variable	password	$user

	# ----------------------------------------------------------------------
	# This variable (and escape, hostname, hostnumber, port, user, password
	# from above) are used to construct the variables in the block below.
	# ----------------------------------------------------------------------

	variable	xCharN		{[a-zA-Z0-9$_.+!*'(,);/?:@&=-]}

	# ----------------------------------------------------------------------
	# These variables (and "escape") are used in the patterns defined in the
	# calls to uri::register at the end of the file.  They are not used by
	# any commands.
	# ----------------------------------------------------------------------

	variable	xChar		"(${xCharN}|${escape})"
	variable	host		"(${hostname}|${hostnumber})"
	variable	hostOrPort	"${host}(:${port})?"
	variable	login		"(${user}(:${password})?@)?${hostOrPort}"
	variable	alpha		{[a-zA-Z]}

	# ----------------------------------------------------------------------
	# These variables are not used by anything in this file.
	# ----------------------------------------------------------------------

	variable	loAlpha		{[a-z]}
	variable	hiAlpha		{[A-Z]}
	variable	safe		{[$_.+-]}
	variable	extra		{[!*'(,)]}
	# danger in next pattern, order important for []
	variable	national	{[][|\}\{\^~`]}
	variable	punctuation	{[<>#%"]}	;#" fake emacs hilit
	variable	reserved	{[;/?:@&=]}

	# next is <national | punctuation>
	variable	unsafe		{[][<>"#%\{\}|\\^~`]} ;#" emacs hilit

	#	unreserved	= alpha | digit | safe | extra
	#	xchar		= unreserved | reserved | escape

	variable	unreserved	{[a-zA-Z0-9$_.+!*'(,)-]}
	variable	uChar		"(${unreserved}|${escape})"

    } ;# basic {}
}

# ::uri::setQuirkOption
#
#	Accessor command for quirk options; uses "set" semantics.
#
#	Quirk options allow deviations from RFC 3986, and are fully documented
#	in the man page uri(n).
#
#	Currently defined quirk options are:
#	    NoInitialSlash
#	    NoExtraKeys
#	    RemoveDoubleSlashes
#	    HostAsDriveLetter
#
# Arguments:
#	key	name of a quirk option
#       value	(optional, boolean) new value
#
# Results:
#	The value of the quirk option.

proc ::uri::setQuirkOption {key args} {
    variable Quirks

    if {![info exists Quirks($key)]} {
	return -code error {unknown key}
    }

    set lenny [llength $args]
    if {$lenny == 0} {
	return $Quirks($key)
    } elseif {$lenny == 1} {
	set value [lindex $args 0]
	if {![string is boolean -strict $value]} {
	    return -code error {boolean value required}
	}
	set Quirks($key) [expr {$value && $value}]
	return $value
    } else {
        return -code error {wrong # args: should be "::uri::setQuirkOption\
		key ?newBooleanValue?"}
    }
}


# ::uri::register --
#
#	Register a scheme (and aliases) in the package. The command
#	creates a namespace below "::uri" with the same name as the
#	scheme and executes the script declaring the pattern variables
#	for this scheme in the new namespace. At last it updates the
#	uri variables keeping track of overall scheme information.
#
#	The script has to declare at least the variable "schemepart",
#	the pattern for an url of the registered scheme after the
#	scheme declaration. Not declaring this variable is an error.
#
#	Registration provides a number of pattern variables for use by external
#	code.  It is unconnected to the commands provided by the uri package.
#	See the warnings near the end of this file where uri::register is
#	called.
#
# Arguments:
#	schemeList	Name of the scheme to register, plus aliases
#       script		Script declaring the scheme patterns
#
# Results:
#	None.

proc ::uri::register {schemeList script} {
    variable schemes
    variable schemePattern
    variable url
    variable url2part

    # Check scheme and its aliases for existence.
    foreach scheme $schemeList {
	if {[lsearch -exact $schemes $scheme] >= 0} {
	    return -code error \
		    "trying to register scheme (\"$scheme\") which is already known"
	}
    }

    # Get the main scheme
    set scheme  [lindex $schemeList 0]

    if {[catch {namespace eval $scheme $script} msg]} {
	catch {namespace delete $scheme}
	return -code error \
	    "error while evaluating scheme script: $msg"
    }

    if {![info exists ${scheme}::schemepart]} {
	namespace delete $scheme
	return -code error \
	    "Variable \"schemepart\" is missing."
    }

    # Now we can extend the variables which keep track of the registered schemes.

    eval [linsert $schemeList 0 lappend schemes]
    set schemePattern	"([::join $schemes |]):"

    foreach s $schemeList {
	# FRINK: nocheck
	set url2part($s) "${s}:[set ${scheme}::schemepart]"
	# FRINK: nocheck
	append url "(${s}:[set ${scheme}::schemepart])|"
    }
    set url [string trimright $url |]
    return
}

# ::uri::split --
#
#	Splits the given <a url> into its constituents.
#
# Arguments:
#	url	the URL to split
#
# Results:
#	Tcl list containing constituents, suitable for 'array set'.

proc ::uri::split {url {defaultscheme http}} {

    set url [string trim $url]
    set scheme {}

    # RFC 3986 Sec 3.1: scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    regexp -- {^([A-Za-z][A-Za-z0-9+.-]*):} $url dummy scheme

    if {$scheme == {}} {
	set scheme $defaultscheme
	switch -- $scheme {
	    http - https - ftp {
		# x/y     -> //x/y    PREPEND //
		# /x/y    -> ///x/y   PREPEND //
		# //x/y   -> //x/y
		# ///x/y  -> ///x/y
		# ////x/y -> ////x/y
		if {[string range $url 0 1] != "//"} {
		    set url //$url
		}
	    }
	}
    }

    # ease maintenance: dynamic dispatch, able to handle all schemes
    # added in future!

    if {[::info procs Split[string totitle $scheme]] == {}} {
	error "unknown scheme '$scheme' in '$url'"
    }

    regsub -- "^${scheme}:" $url {} url

    # Pass url without scheme: to the per-scheme handler.
    set       parts(scheme) [string tolower $scheme]
    array set parts [Split[string totitle $scheme] $url]

    # Does not decode encoded characters.

    return [array get parts]
}

proc ::uri::SplitFtp {url} {
    # @c Splits the given ftp-<a url> into its constituents.
    # @a url: The url to split, without! scheme specification.
    # @r List containing the constituents, suitable for 'array set'.

    # general syntax:
    # //<user>:<password>@<host>:<port>/<cwd1>/.../<cwdN>/<name>;type=<typecode>
    #
    # additional rules:
    #
    # <user>:<password> are optional, detectable by presence of @.
    # <password> is optional too.
    #
    # "//" [ <user> [":" <password> ] "@"] <host> [":" <port>] "/"
    #	<cwd1> "/" ..."/" <cwdN> "/" <name> [";type=" <typecode>]

    upvar \#0 [namespace current]::ftp::typepart ftptype

    array set parts {user {} pwd {} host {} port {} path {} type {} scheme ftp}

    # slash off possible type specification

    if {[regexp -indices -- "${ftptype}$" $url dummy ftype]} {

	set from	[lindex $ftype 0]
	set to		[lindex $ftype 1]

	set parts(type)	[string range   $url $from $to]

	set from	[lindex $dummy 0]
	set url		[string replace $url $from end]
    }

    # Handle user, password, host and port

    if {[string match "//*" $url]} {
	set url [string range $url 2 end]

	array set parts [GetUPHP url]
	# (also removes UPHP from url)
    }

    set parts(path) $url
    AddQuirk3986 parts

    return [array get parts]
}

proc ::uri::JoinFtp args {
    set uphp [eval [linsert $args 0 ComposeUPHP {}]]

    array set components {
	pbare 0 path {} type {}
    }
    array set components $args

    set type {}
    if {[string length $components(type)]} {
	set type \;type=$components(type)
    }

    RemoveQuirk3986 components

    # Botches to accept certain invalid arguments instead of raising an error.

    set PathFirst [string index $components(path) 0]
    if {($PathFirst != {}) && ($PathFirst != {/})} {
	# The path is invalid: if it is not empty it must begin with "/".
	# This botch allows the command nevertheless to return a valid URI.
	set components(path) "/$components(path)"
    }

    if {($components(path) == {}) && ($components(type) != "")} {
	set components(path) "/"
	# FTP requires a non-empty path if $type is non-empty.
	# RFC 1738 Sec. 5, 
	# This botch enforces that.
    }

    return ftp://${uphp}$components(path)$type
}

proc ::uri::SplitHttps {url} {
    return [SplitHttpInner https $url]
}

proc ::uri::SplitHttp {url} {
    return [SplitHttpInner http $url]
}

proc ::uri::SplitHttpInner {scheme url} {
    # @c Splits the given http-<a url> into its constituents.
    # @a url: The url to split, without! scheme specification.
    # @r List containing the constituents, suitable for 'array set'.

    # general syntax:
    # //<host>:<port>/<path>?<searchpart>
    #
    #   where <host> and <port> are as described in Section 3.1. If :<port>
    #   is omitted, the port defaults to 80.  No user name or password is
    #   allowed.  <path> is an HTTP selector, and <searchpart> is a query
    #   string. The <path> is optional, as is the <searchpart> and its
    #   preceding "?". If neither <path> nor <searchpart> is present, the "/"
    #   may also be omitted.
    #
    #   Within the <path> and <searchpart> components, "/", ";", "?" are
    #   reserved.  The "/" character may be used within HTTP to designate a
    #   hierarchical structure.
    #
    # path == <cwd1> "/" ..."/" <cwdN> "/" <name> ["#" <fragment>]

    array set parts {host {} port {} path {} query {} fragment {}}
    array set parts [list scheme $scheme]

    set fragmentPattern "#(.*)\$"

    # slash off possible fragment.

    # NOTE: This must be done before the query, because a fragment can
    # follow a query, and slashing off the query first will take the
    # fragment with it. Bug #3235340.

    if {[regexp -indices -- $fragmentPattern $url match fragment]} {
	set from [lindex $fragment 0]
	set to   [lindex $fragment 1]

	set parts(fragment) [string range $url $from $to]

	set url [string replace $url [lindex $match 0] end]
    }

    # slash off possible query. the 'search' regexp, while official,
    # is not good enough. We have apparently lots of urls in the wild
    # which contain unquoted urls with queries in a query. The RE
    # finds the embedded query, not the actual one. Using string first
    # now instead of a RE

    if {[set pos [string first ? $url]] >= 0} {
	incr pos
	set parts(query) [string range   $url $pos end]
	incr pos -1
	set url          [string replace $url $pos end]
    }

    if {[string match "//*" $url]} {
	set url [string range $url 2 end]

	array set parts [GetUPHP url]
	# (also removes UPHP from url)
    }

    set parts(path) $url
    AddQuirk3986 parts

    return [array get parts]
}

proc ::uri::JoinHttp {args} {
    return [eval [linsert $args 0 ::uri::JoinHttpInner http 80]]
}

proc ::uri::JoinHttps {args} {
    return [eval [linsert $args 0 ::uri::JoinHttpInner https 443]]
}

proc ::uri::JoinHttpInner {scheme defport args} {
    set uphp [eval [linsert $args 0 ComposeUPHP $defport]]

    array set components {pbare 0 path {} query {} fragment {}}
    array set components $args

    set query {}
    if {[string length $components(query)]} {
	set query ?$components(query)
    }

    if { $components(fragment) != "" } {
	set components(fragment) "#$components(fragment)"
    } else {
	set components(fragment) ""
    }

    RemoveQuirk3986 components

    # Botch to accept certain invalid arguments instead of raising an error.

    set PathFirst [string index $components(path) 0]
    if {($PathFirst != {}) && ($PathFirst != {/})} {
	# The path is invalid: if it is not empty it must begin with "/".
	# This botch allows the command nevertheless to return a valid URI.
	set components(path) "/$components(path)"
    }

    return $scheme://$uphp$components(path)$query$components(fragment)
}

proc ::uri::SplitFile {url} {
    # @c Splits the given file-<a url> into its constituents.
    # @a url: The url to split, without! scheme specification.
    # @r List containing the constituents, suitable for 'array set'.
    variable Quirks

    upvar #0 [namespace current]::basic::hostspec	hostspec

    if {[string match "//*" $url]} {
	set url [string range $url 2 end]

	set hostPattern "^($hostspec)"

	if {    $Quirks(HostAsDriveLetter)
	     && ($::tcl_platform(platform) == "windows")
	} {
	    # Catch drive letter
	    append hostPattern :?
	} else {
	    # Proceed as usual
	}

	if {[regexp -indices -- $hostPattern $url match host]} {
	    set fh	[lindex $host 0]
	    set th	[lindex $host 1]

	    set parts(host)	[string range $url $fh $th]

	    set  matchEnd   [lindex $match 1]
	    incr matchEnd

	    set url	[string range $url $matchEnd end]
	}
    }

    # This always begins with "/" if $url is a valid absolute file:// URL.
    set parts(path) $url

    return [array get parts]
}

proc ::uri::JoinFile args {
    variable Quirks
    array set components {
	host {} port {} path {}
    }
    array set components $args

    if {    $Quirks(HostAsDriveLetter)
	 && ($::tcl_platform(platform) == "windows")
    } {
	# This misfeature is kept for compatibility with legacy code.
	if {[string length $components(host)]} {
	    return file://$components(host):$components(path)
	} else {
	    return file://$components(path)
	}
    } else {
        # Botch to accept certain invalid arguments instead of raising an error.
	if {[string index $components(path) 0] != "/"} {
	    # The path argument is invalid: it must begin with "/" (an empty
	    # path is not allowed for the scheme "file", RFC 1738 Sec. 5).
	    # This botch allows the command nevertheless to return a valid URI.
	    set components(path) "/$components(path)"
	} else {
	}

	return file://$components(host)$components(path)
    }
}

proc ::uri::SplitMailto {url} {
    # @c Splits the given mailto-<a url> into its constituents.
    # @a url: The url to split, without! scheme specification.
    # @r List containing the constituents, suitable for 'array set'.

    if {[string match "*@*" $url]} {
	set url [::split $url @]
	return [list user [lindex $url 0] host [lindex $url 1]]
    } else {
	return [list user $url]
    }
}

proc ::uri::JoinMailto args {
    array set components {
	user {} host {}
    }
    array set components $args

    return mailto:$components(user)@$components(host)
}

proc ::uri::SplitNews {url} {
    if { [string first @ $url] >= 0 } {
	return [list message-id $url]
    } else {
	return [list newsgroup-name $url]
    }
}

proc ::uri::JoinNews args {
    array set components {
	message-id {} newsgroup-name {}
    }
    array set components $args
    return news:$components(message-id)$components(newsgroup-name)
}

proc ::uri::SplitLdaps {url} {
    ::uri::SplitLdap $url
}

proc ::uri::SplitLdap {url} {
    # @c Splits the given Ldap-<a url> into its constituents.
    # @a url: The url to split, without! scheme specification.
    # @r List containing the constituents, suitable for 'array set'.

    # general syntax:
    # //<host>:<port>/<dn>?<attrs>?<scope>?<filter>?<extensions>
    #
    #   where <host> and <port> are as described in Section 5 of RFC 1738.
    #   No user name or password is allowed.
    #   If omitted, the port defaults to 389 for ldap, 636 for ldaps
    #   <dn> is the base DN for the search
    #   <attrs> is a comma separated list of attributes description
    #   <scope> is either "base", "one" or "sub".
    #   <filter> is a RFC 2254 filter specification
    #   <extensions> are documented in RFC 2255
    #

    array set parts {host {} port {} dn {} attrs {} scope {} filter {} extensions {}}

    #          host        port           dn          attrs       scope               filter     extns
    set re {//((?:[^:?/]+)|(?:\[[^\]]*\]))(?::([0-9]+))?(?:/([^?]+)(?:\?([^?]*)(?:\?(base|one|sub)?(?:\?([^?]*)(?:\?(.*))?)?)?)?)?}

    if {! [regexp $re $url match parts(host) parts(port) \
		parts(dn) parts(attrs) parts(scope) parts(filter) \
		parts(extensions)]} then {
	return -code error "unable to match URL \"$url\""
    }

    set parts(attrs) [::split $parts(attrs) ","]

    return [array get parts]
}

proc ::uri::JoinLdap {args} {
    return [eval [linsert $args 0 ::uri::JoinLdapInner ldap 389]]
}

proc ::uri::JoinLdaps {args} {
    return [eval [linsert $args 0 ::uri::JoinLdapInner ldaps 636]]
}

proc ::uri::JoinLdapInner {scheme defport args} {
    array set components {host {} port {} dn {} attrs {} scope {} filter {} extensions {}}
    set       components(port) $defport
    array set components $args

    set port {}
    if {[string length $components(port)] && $components(port) != $defport} {
	set port :$components(port)
    }

    set url "$scheme://$components(host)$port"

    set components(attrs) [::join $components(attrs) ","]

    set s ""
    foreach c {dn attrs scope filter extensions} {
	if {[string equal $c "dn"]} then {
	    append s "/"
	} else {
	    append s "?"
	}
	if {! [string equal $components($c) ""]} then {
	    append url "${s}$components($c)"
	    set s ""
	}
    }

    return $url
}

proc ::uri::ComposeUPHP {defport args} {
    # user:pwd@host:port

    array set components {
	user {} pwd {} host {} port {}
    }
    set       components(port) $defport
    array set components $args

    set userPwd {}
    if {[string length $components(user)] || [string length $components(pwd)]} {
	set userPwd $components(user)[expr {[string length $components(pwd)] ? ":$components(pwd)" : {}}]@
    }

    set port {}
    if {[string length $components(port)] && $components(port) != $defport} {
	set port :$components(port)
    }

    return ${userPwd}$components(host)${port}
}

proc ::uri::GetUPHP {urlvar} {
    # @c Parse user, password host and port out of the url stored in
    # @c variable <a urlvar>.
    # @d Side effect: The extracted information is removed from the given url.
    # @r List containing the extracted information in a format suitable for
    # @r 'array set'.
    # @a urlvar: Name of the variable containing the url to parse.

    upvar \#0 [namespace current]::basic::user		user
    upvar \#0 [namespace current]::basic::password	password
    upvar \#0 [namespace current]::basic::hostspec	hostspec
    upvar \#0 [namespace current]::basic::port		port

    upvar $urlvar url
    set url_save $url

    array set parts {user {} pwd {} host {} port {}}

    # syntax
    # "//" [ <user> [":" <password> ] "@"] <host> [":" <port>] "/"
    # "//" already cut off by caller

    set upPattern "^(${user})(:(${password}))?@"

    if {[regexp -indices -- $upPattern $url match theUser c d thePassword]} {
	set fu	[lindex $theUser 0]
	set tu	[lindex $theUser 1]

	set fp	[lindex $thePassword 0]
	set tp	[lindex $thePassword 1]

	set parts(user)	[string range $url $fu $tu]
	set parts(pwd)	[string range $url $fp $tp]

	set  matchEnd   [lindex $match 1]
	incr matchEnd

	set url	[string range $url $matchEnd end]
    }

    set hpPattern "^($hostspec)(:($port))?"

    if {[regexp -indices -- $hpPattern $url match theHost c d e f g h thePort]} {
	set fh	[lindex $theHost 0]
	set th	[lindex $theHost 1]

	set fp	[lindex $thePort 0]
	set tp	[lindex $thePort 1]

	set parts(host)	[string range $url $fh $th]
	set parts(port)	[string range $url $fp $tp]

	set  matchEnd   [lindex $match 1]
	incr matchEnd

	set url	[string range $url $matchEnd end]
    }
    
    if {(![string match /* $url]) && ($url ne {})} {
	error [list {invalid url} $url $url_save]
    }

    return [array get parts]
}

# ::uri::resolve --
#
#	Resolve an arbitrary URL, given a base URL
#
# This code depends on the ability of uri::split to process relative URIs.
# N.B. http(s): and ftp: path does not begin with "/" and may be empty.
# The file: path (unix or win) always begins "/", even if a host is specified.
#
# RFC 3986 Sec. 5.2 defines how URI relative resolution should proceed.
# This command is a "strict parser" in the sense of Sec. 5.2.2: it does not
# allow a relative URI such as "http:foo/bar.html".  See also the last example
# in Sec. 5.4.2 and uri-rfc2396.test test uri-rfc2396-11.19.
#
# Arguments:
#	base	base URL (absolute)
#	url	arbitrary URL
#
# Results:
#	Returns a URL

proc ::uri::resolve {base url} {
    if {[isrelative $url]} {
	set canon 1
	array set baseparts [split $base]

	switch -- $baseparts(scheme) {
	    http -
	    https -
	    ftp -
	    file {
		set changed 0
		array set relparts [split $baseparts(scheme):$url]
		if {[array names relparts path] != {path}} {
		    set relparts(path) {}
		}
		if { [string match /* $url] } {
		    set baseparts(path)  $relparts(path)
		    if {    [info exists baseparts(pbare)]
		         && [info exists relparts(pbare)]
		    } {
			# This test and action are sufficient to make
			# uri::resolve work for all schemes and quirk options.
			set baseparts(pbare) $relparts(pbare)
		    }
		    catch {
			if {$relparts(host) != ""} {
			    # RFC 3986 section 4.2 and 5.2.2.
			    # url has no scheme, but has authority
			    # ("UPHP" or User,Password,Host,Port). Use that
			    # authority. Do not transfer credentials or port
			    # number from the base authority.
			    set baseparts(host) $relparts(host)
			    set baseparts(user) {}
			    set baseparts(pwd)  {}
			    set baseparts(port) {}
			    set baseparts(user) $relparts(user)
			    set baseparts(pwd)  $relparts(pwd)
			    set baseparts(port) $relparts(port)
			}
		    }
		    set changed 1
		} elseif {    [string match */ $baseparts(path)]
			   && ([string length $relparts(path)] > 0)
		} {
		    set baseparts(path) "$baseparts(path)$relparts(path)"
		    set changed 1
		} elseif { [string length $relparts(path)] > 0 } {
		    set path [lreplace [::split $baseparts(path) /] end end]
		    set baseparts(path) "[::join $path /]/$relparts(path)"
		    set changed 1
		} else {
		    # Do not overwrite baseparts(path).  In this case,
		    # RFC 3986 Sec. 5.2.2 does not demand canonicalization.
		    # FIXME check whether the RFC assumes the base URI is
		    # already canonical.
		    set canon 0
		}
	    }
	    default {
		return -code error "unable to resolve relative URL \"$url\""
	    }
	}

	# query and fragment are defined for http, https; not for file, ftp
	# Fragment is useful in HTML documents that are accessed by file or ftp,
	# but this is not supported by the RFCs.
	switch -- $baseparts(scheme) {
	    http -
	    https {
		if {[array names relparts query] != {query}} {
		    set relparts(query) {}
		}
		if {[array names relparts fragment] != {fragment}} {
		    set relparts(fragment) {}
		}

		if {$changed || ($relparts(query) != {})} {
		    set baseparts(query) $relparts(query)
		    set changed 1
		} else {
		    # Keep base query.
		    # FIXME error if url has empty query "?".
		    # FIXME (in split/join) empty query "?".
		}

		# RFC 3986 section 5.2.2 requires that the base fragment
		# is always discarded.
		set baseparts(fragment) $relparts(fragment)
		# FIXME error if url has empty fragment "#".
		# FIXME (in split/join) empty fragment "#".
	    }
	    ftp -
	    file -
	    default {
	    }
	}

	set url [eval [linsert [array get baseparts] 0 join]]
	if {$canon} {
	    # RFC 3986 section 5.2.2 requires us to canonicalize the path.
	    set url [canonicalize $url]
	} else {
	}
	return $url
    } else {
	# RFC 3986 section 5.2.2 requires us to canonicalize the path.
	set url [canonicalize $url]
	return $url
    }
}

# ::uri::isrelative --
#
#	Determines whether a URL is absolute or relative
#
# Arguments:
#	url	URL to check
#
# Results:
#	Returns 1 if the URL is relative, 0 otherwise

proc ::uri::isrelative url {
    return [expr {![regexp -- {^[A-Za-z][A-Za-z0-9+.-]*:} $url]}]
}

# ::uri::geturl --
#
#	Fetch the data from an arbitrary URL.
#
#	This package provides a handler for the file:
#	scheme, since this conflicts with the file command.
#
# Arguments:
#	url	address of data resource
#	args	configuration options
#
# Results:
#	Depends on scheme

proc ::uri::geturl {url args} {
    array set urlparts [split $url]

    switch -- $urlparts(scheme) {
	file {
	    return [eval [linsert $args 0 file_geturl $url]]
	}
	default {
	    # Load a geturl package for the scheme first and only if
	    # that fails the scheme package itself. This prevents
	    # cyclic dependencies between packages.
	    if {[catch {package require $urlparts(scheme)::geturl}]} {
		package require $urlparts(scheme)
	    }
	    return [eval [linsert $args 0 $urlparts(scheme)::geturl $url]]
	}
    }
}

# ::uri::file_geturl --
#
#	geturl implementation for file: scheme
#
# TODO:
#	This is an initial, basic implementation.
#	Eventually want to support all options for geturl.
#
# Arguments:
#	url	URL to fetch
#	args	configuration options
#
# Results:
#	Returns data from file

proc ::uri::file_geturl {url args} {
    variable file:counter

    set var [namespace current]::file[incr file:counter]
    upvar #0 $var state
    array set state {data {}}

    array set parts [split $url]

    set ch [open $parts(path)]
    # Could determine text/binary from file extension,
    # except on Macintosh
    # fconfigure $ch -translation binary
    set state(data) [read $ch]
    close $ch

    return $var
}

# ::uri::join --
#
#	Format a URL
#
# Arguments:
#	args	components, key-value format
#
# Results:
#	A URL

proc ::uri::join args {
    array set components $args

    return [eval [linsert $args 0 Join[string totitle $components(scheme)]]]
}

# ::uri::canonicalize --
#
#	Canonicalize a URL
#
# Acknowledgements:
#	Andreas Kupries <andreas_kupries@users.sourceforge.net>
#	Keith Nash <kjnash@users.sourceforge.net>
#
# Arguments:
#	uri	URI (which contains a path component)
#
# Results:
#	The URI with the filename path in its canonical form.
#	This is not full URI "normalization" which may require further
#	processing.

proc ::uri::canonicalize uri {
    # Make uri canonical with respect to dots (path changing commands)
    #
    # Remove single dots (.)  => pwd not changing
    # Remove double dots (..) => gobble previous segment of path
    #
    # Fixes for this command:
    #
    # * Ignore any url which cannot be split into components by this
    #   module. Just assume that such urls do not have a path to
    #   canonicalize.
    #
    # * Ignore any url which could be split into components, but does
    #   not have a path component.
    #
    # In the text above 'ignore' means
    # 'return the url unchanged to the caller'.

    if {[catch {array set u [::uri::split $uri]}]} {
	return $uri
    }
    if {![info exists u(path)]} {
	return $uri
    }

    # RemoveDotSegments works perfectly well on paths without a leading "/", but
    # removing and re-adding the quirks ensures RFC 3986 conformance in a few
    # corner cases.
    RemoveQuirk3986 u
    set u(path) [RemoveDotSegments $u(path)]
    AddQuirk3986 u

    set uri [eval [linsert [array get u] 0 ::uri::join]]

    return $uri
}


# ::uri::RemoveDotSegments --
#
#	Remove any segments "." and ".." from a URI path.
#	Optionally remove empty segments {}.
#
#	Intended to implement the "remove_dot_segments" routine
#	defined in RFC 3986 Sec. 5.2.4.
#
# Acknowledgements:
#	Andreas Kupries <andreas_kupries@users.sourceforge.net>
#	Keith Nash <kjnash@users.sourceforge.net>
#
# Arguments:
#	path	path component of a URI
#
# Results:
#	The URI path in its canonical form.

proc ::uri::RemoveDotSegments path {
    variable Quirks

    set oldList [::split $path /]

    if {[lindex $oldList 0] == {}} {
	set lead 1
    } else {
	set lead 0
    }

    set end [llength $oldList]
    incr end -1

    # i - index of element seg in oldList
    # j - index of last element written to newList
    set i 0
    set j -1
    set newList {}
    foreach seg $oldList {
	if {    $Quirks(RemoveDoubleSlashes)
	     && ($seg == {}) && ($i != 0) && ($i != $end)
	} {
	    # Throw away this empty segment.
	    # This merges adjacent "/".
	    # If the first or last segment is empty, it is handled at "else".
	    # Other empty segments are also handled at "else" if this quirk has
	    # not been requested.
	} elseif {($seg == {.}) && ($i == $end)} {
	    # Replace "." with {} to keep a trailing "/" in path.
	    lappend newList {}
	    incr j
	} elseif {$seg == {.}} {
	    # Throw away this "." segment.
	} elseif {($seg == {..}) && ($j > $lead - 1) && ($i == $end)} {
	    # Remove the element previously added to newList, and
	    # replace it with {} to keep a trailing "/" in path.
	    set newList [lreplace $newList $j $j {}]
	} elseif {($seg == {..}) && ($j > $lead - 1)} {
	    # Remove the element previously added to newList.
	    set newList [lreplace $newList $j $j]
	    incr j -1
	} elseif {($seg == {..}) && ($i == $end)} {
	    # Can't go any deeper in newList, but this path needs a
	    # leading "/".
	    lappend newList {}
	    incr j
	} elseif {$seg == {..}} {
	    # Can't go any deeper in newList.
	} else {
	    # A "normal" path segment!
	    lappend newList $seg
	    incr j
	}

	incr i
    }

    return [::join $newList /]
}


# ::uri::RemoveQuirk3986
#
#	Work on an array produced by uri::split. Read the path and pbare
#	elements, and convert the path element to RFC 3986 compliance from
#	NoInitialSlash and NoExtraKeys quirks modes IF the caller has requested
#	these quirks AND they are used by the array's scheme.
#
#	Full RFC 3986 compliance is not possible if the caller has set both the
#	quirks NoInitialSlash and NoExtraKeys.  This mode is offered for
#	backward compatibility.  See documentation uri(n).
#
# Arguments:
#	arrName	    Name of array in the caller's stack frame that holds the
#		    results of uri::split.
# Results:
#	No return value.  The array is modified as a side effect.

proc ::uri::RemoveQuirk3986 {arrName} {
    variable Quirks
    upvar 1 $arrName u

    if {    $Quirks(NoInitialSlash)
	 && ([lsearch {http https ftp} $u(scheme)] != -1)
    } {
        if {$Quirks(NoExtraKeys)} {
	    array set u {pbare 0}
	} else {
	    # Keep existing value of u(pbare).
	}

	set PathFirst [string index $u(path) 0]
	if {($PathFirst != {}) && ($PathFirst != {/})} {
	    # If the quirk is set and used, then the leading "/" of the path has
	    # been stripped.  Put it back.
	    set u(path) "/$u(path)"
	} elseif {($PathFirst != {}) && ($PathFirst == {/})} {
	    # In principle we should prepend "/" to u(path) here too, but this
	    # leads to perverse results, e.g. uri::join with path "/" becomes
	    # path "//".
	} elseif {($PathFirst == {}) && (!$u(pbare))} {
	    # This is how {} and / are distinguished for the value of the
	    # 3986-defined path, when the quirk is set and used, i.e. when the
	    # leading "/" of the path has been stripped.
	    set u(path) "/"
	} else {
	    # Leave u(path) unchanged.
	}
    }

    if {$Quirks(NoInitialSlash) && (!$Quirks(NoExtraKeys))} {
	# pbare is required
    } else {
	array unset u pbare
    }

    return
}

# ::uri::AddQuirk3986
#
#	Work on an array produced by uri::split. Read the path element, and
#	convert the path and pbare elements from RFC 3986 compliance to
#	NoInitialSlash and NoExtraKeys quirks modes IF the caller has requested
#	these quirks AND they are used by the array's scheme.
#
# Arguments:
#	arrName	    Name of array in the caller's stack frame that holds the
#		    results of uri::split.
# Results:
#	No return value.  The array is modified as a side effect.

proc ::uri::AddQuirk3986 arrName {
    variable Quirks
    upvar 1 $arrName u

    array unset u pbare

    if {    $Quirks(NoInitialSlash)
	 && ([lsearch {http https ftp} $u(scheme)] != -1)
    } {
	if {$Quirks(NoExtraKeys)} {
	    # u(pbare) is refused
	} elseif {($u(path) == {})} {
	    set u(pbare) 1
	} else {
	    set u(pbare) 0
	}
	# In principle we should remove only the first "/", not all
	# of them, but it in this quirk regime it is cleaner to keep the
	# rule that the path never begins with "/".
	set u(path) [string trimleft $u(path) /]
    } else {
    }

    return
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# regular expressions covering various url schemes

# Currently known URL schemes:
#
# (RFC 1738)
# ------------------------------------------------
# scheme	basic syntax of scheme specific part
# ------------------------------------------------
# ftp		//<user>:<password>@<host>:<port>/<cwd1>/.../<cwdN>/<name>;type=<typecode>
#    		//<user>:<password>@<host>:<port>/fpath;type=<typecode>
#
# http		//<host>:<port>/<hpath>?<searchpart>
#
# gopher	//<host>:<port>/<gophertype><selector>
#				<gophertype><selector>%09<search>
#		<gophertype><selector>%09<search>%09<gopher+_string>
#
# mailto	<rfc822-addr-spec>
# news		<newsgroup-name>
#		<message-id>
# nntp		//<host>:<port>/<newsgroup-name>/<article-number>
# telnet	//<user>:<password>@<host>:<port>/
# wais		//<host>:<port>/<database>
#		//<host>:<port>/<database>?<search>
#		//<host>:<port>/<database>/<wtype>/<wpath>
# file		//<host>/<fpath>
# prospero	//<host>:<port>/<hsoname>;<field>=<value>
# ------------------------------------------------
#
# (RFC 2111)
# ------------------------------------------------
# scheme	basic syntax of scheme specific part
# ------------------------------------------------
# mid	message-id
#		message-id/content-id
# cid	content-id
# ------------------------------------------------
#
# (RFC 2255)
# ------------------------------------------------
# scheme	basic syntax of scheme specific part
# ------------------------------------------------
# ldap		//<host>:<port>/<dn>?<attrs>?<scope>?<filter>?<extensions>
# ------------------------------------------------


# ------------------------------------------------------------------------------
#     IMPORTANT WARNINGS
# ------------------------------------------------------------------------------
# (1) THE PATTERNS DEFINED BELOW (with one exception) ARE NOT USED FOR PARSING
#     URLs BY ANY OF THIS PACKAGE'S COMMANDS.
# (2) THAT EXCEPTION IS THE VARIABLE ::uri::ftp::typepart
# (3) AS LONG AS THAT VARIABLE IS ASSIGNED THE CORRECT VALUE, ALL THE
#     uri::register CALLS CAN BE DELETED WITHOUT AFFECTING THE uri::* COMMANDS.
# (2) REGISTRATION OF A SCHEME DOES NOT IMPLEMENT COMMANDS FOR THAT SCHEME.
# (3) REGISTRATION OF A SCHEME IS NOT NECESSARY TO IMPLEMENT COMMANDS FOR THAT
#     SCHEME.
#     Instead:
# (4) THE PATTERNS ARE FOR REFERENCE, AND CAN BE ACCESSED VIA THESE NAMESPACE
#     VARIABLES, OR IN SOME CASES VIA VARIABLES MAINTAINED BY uri::register.
# (5) THE VARIABLES schemepart AND url ARE MENTIONED IN THE DOCUMENTATION.
# (6) UNDOCUMENTED VARIABLES MIGHT BE ACCESSED BY THIRD-PARTY CODE.
# (7) THEREFORE EVERYTHING IS RETAINED FOR BACKWARD COMPATIBILITY.
# ------------------------------------------------------------------------------

# FTP
uri::register ftp {
    # Please read the warnings above.
    variable escape [set [namespace parent [namespace current]]::basic::escape]
    variable login  [set [namespace parent [namespace current]]::basic::login]

    variable	charN	{[a-zA-Z0-9$_.+!*'(,)?:@&=-]}
    variable	char	"(${charN}|${escape})"
    variable	segment	"${char}*"
    variable	path	"${segment}(/${segment})*"

    variable	type		{[AaDdIi]}
    variable	typepart	";type=(${type})"
    # Used elsewhere: typepart

    variable	schemepart	\
		    "//${login}(/${path}(${typepart})?)?"

    variable	url		"ftp:${schemepart}"
}

# FILE
uri::register file {
    # Please read the warnings above.
    variable	host [set [namespace parent [namespace current]]::basic::host]
    variable	path [set [namespace parent [namespace current]]::ftp::path]

    variable	schemepart	"//(${host}|localhost)?/${path}"
    variable	url		"file:${schemepart}"
}

# HTTP
uri::register {http https} {
    # Please read the warnings above.
    variable	escape \
        [set [namespace parent [namespace current]]::basic::escape]
    variable	hostOrPort	\
        [set [namespace parent [namespace current]]::basic::hostOrPort]

    variable	charN		{[a-zA-Z0-9$_.+!*'(,);:@&=-]}
    variable	char		"($charN|${escape})"
    variable	segment		"${char}*"

    variable	path		"${segment}(/${segment})*"
    variable	search		$segment
    variable	schemepart	\
	    "//${hostOrPort}(/${path}(\\?${search})?)?"

    variable	url		"http:${schemepart}"
}

# GOPHER
uri::register gopher {
    # Please read the warnings above.
    variable	xChar \
        [set [namespace parent [namespace current]]::basic::xChar]
    variable	hostOrPort \
        [set [namespace parent [namespace current]]::basic::hostOrPort]
    variable	search \
        [set [namespace parent [namespace current]]::http::search]

    variable	type		$xChar
    variable	selector	"$xChar*"
    variable	string		$selector
    variable	schemepart	\
	    "//${hostOrPort}(/(${type}(${selector}(%09${search}(%09${string})?)?)?)?)?"
    variable	url		"gopher:${schemepart}"
}

# MAILTO
uri::register mailto {
    # Please read the warnings above.
    variable xChar [set [namespace parent [namespace current]]::basic::xChar]
    variable host  [set [namespace parent [namespace current]]::basic::host]

    variable schemepart	"$xChar+(@${host})?"
    variable url	"mailto:${schemepart}"
}

# NEWS
uri::register news {
    # Please read the warnings above.
    variable escape [set [namespace parent [namespace current]]::basic::escape]
    variable alpha  [set [namespace parent [namespace current]]::basic::alpha]
    variable host   [set [namespace parent [namespace current]]::basic::host]

    variable	aCharN		{[a-zA-Z0-9$_.+!*'(,);/?:&=-]}
    variable	aChar		"($aCharN|${escape})"
    variable	gChar		{[a-zA-Z0-9$_.+-]}
    variable	newsgroup-name	"${alpha}${gChar}*"
    variable	message-id	"${aChar}+@${host}"
    variable	schemepart	"\\*|${newsgroup-name}|${message-id}"
    variable	url		"news:${schemepart}"
}

# WAIS
uri::register wais {
    # Please read the warnings above.
    variable	uChar \
        [set [namespace parent [namespace current]]::basic::xChar]
    variable	hostOrPort \
        [set [namespace parent [namespace current]]::basic::hostOrPort]
    variable	search \
        [set [namespace parent [namespace current]]::http::search]

    variable	db		"${uChar}*"
    variable	type		"${uChar}*"
    variable	path		"${uChar}*"

    variable	database	"//${hostOrPort}/${db}"
    variable	index		"//${hostOrPort}/${db}\\?${search}"
    variable	doc		"//${hostOrPort}/${db}/${type}/${path}"

    #variable	schemepart	"${doc}|${index}|${database}"

    variable	schemepart \
	    "//${hostOrPort}/${db}((\\?${search})|(/${type}/${path}))?"

    variable	url		"wais:${schemepart}"
}

# PROSPERO
uri::register prospero {
    # Please read the warnings above.
    variable	escape \
        [set [namespace parent [namespace current]]::basic::escape]
    variable	hostOrPort \
        [set [namespace parent [namespace current]]::basic::hostOrPort]
    variable	path \
        [set [namespace parent [namespace current]]::ftp::path]

    variable	charN		{[a-zA-Z0-9$_.+!*'(,)?:@&-]}
    variable	char		"(${charN}|$escape)"

    variable	fieldname	"${char}*"
    variable	fieldvalue	"${char}*"
    variable	fieldspec	";${fieldname}=${fieldvalue}"

    variable	schemepart	"//${hostOrPort}/${path}(${fieldspec})*"
    variable	url		"prospero:$schemepart"
}

# LDAP
uri::register {ldap ldaps} {
    # Please read the warnings above.
    variable	hostOrPort \
        [set [namespace parent [namespace current]]::basic::hostOrPort]

    # very crude parsing
    variable	dn		{[^?]*}
    variable	attrs		{[^?]*}
    variable	scope		"base|one|sub"
    variable	filter		{[^?]*}
    # extensions are not handled yet

    variable	schemepart	"//${hostOrPort}(/${dn}(\?${attrs}(\?(${scope})(\?${filter})?)?)?)?"
    variable	url		"ldap:$schemepart"
}

package provide uri 1.2.7
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   