#!/usr/bin/env tclsh
# $Id: tcldoc_scanner.fcl,v 1.1.1.1 2004/10/23 00:38:29 tang Exp $

#//#
# Handles scanning of file-level and procedure-level comments.
# Identifies the various tags (<code>@author</code>,
# <code>@return</code>, etc) and formats them suitably for the file's
# annotation page.  Also identifies one-line summary for the item and
# adds it to the global summary table.  This file is parsed by {@link
# http://mini.net/tcl/fickle fickle} to create the actual scanner.
#
# @author Jason Tang (tang@jtang.org)
# @version 1.0
#//#

######
# Begin autogenerated fickle (version 2.01) routines.
# Although fickle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/fickle for other details.
######

# If yywrap() returns false (zero), then it is assumed that the
# function has gone ahead and set up yyin to point to another input
# file, and scanning continues.  If it returns true (non-zero), then
# the scanner terminates, returning 0 to its caller.  Note that in
# either case, the start condition remains unchanged; it does not
# revert to INITIAL.
#   -- from the flex(1) man page
proc yywrap {} {
    return 1
}

# ECHO copies yytext to the scanner's output if no arguments are
# given.  The scanner writes its ECHO output to the yyout global
# (default, stdout), which may be redefined by the user simply by
# assigning it to some other channel.
#   -- from the flex(1) man page
proc ECHO {{s ""}} {
    if {$s == ""} {
        puts -nonewline $::yyout $::yytext
    } else {
        puts -nonewline $::yyout $s
    }
}

# YY_FLUSH_BUFFER flushes the scanner's internal buffer so that the
# next time the scanner attempts to match a token, it will first
# refill the buffer using YY_INPUT.
#   -- from the flex(1) man page
proc YY_FLUSH_BUFFER {} {
    set ::yy_buffer ""
    set ::yy_index 0
    set ::yy_done 0
}

# yyrestart(new_file) may be called to point yyin at the new input
# file.  The switch-over to the new file is immediate (any previously
# buffered-up input is lost).  Note that calling yyrestart with yyin
# as an argument thus throws away the current input buffer and
# continues scanning the same input file.
#   -- from the flex(1) man page
proc yyrestart {new_file} {
    set yyin $new_file
    YY_FLUSH_BUFFER
}

# The nature of how it gets its input can be controlled by defining
# the YY_INPUT macro.  YY_INPUT's calling sequence is
# "YY_INPUT(buf,result,max_size)".  Its action is to place up to
# max_size characters in the character array buf and return in the
# integer variable result either the number of characters read or the
# constant YY_NULL (0 on Unix systems) to indicate EOF.  The default
# YY_INPUT reads from the global file-pointer "yyin".
#   -- from the flex(1) man page
proc YY_INPUT {buf result max_size} {
    upvar $result ret_val
    upvar $buf new_data
    if {$::yyin != ""} {
        set new_data [read $::yyin $max_size]
        set ret_val [string length $new_data]
    } else {
        set new_data ""
        set ret_val 0
    }
}

# yy_scan_string sets up input buffers for scanning in-memory
# strings instead of files.  Note that switching input sources does
# not change the start condition.
#   -- from the flex(1) man page
proc yy_scan_string {str} {
    append ::yy_buffer $str
    set ::yyin ""
}

# unput(c) puts the character c back onto the input stream.  It will
# be the next character scanned.  The following action will take the
# current token and cause it to be rescanned enclosed in parentheses.
#   -- from the flex(1) man page
proc unput {c} {
    set s [string range $::yy_buffer 0 [expr {$::yy_index - 1}]]
    append s $c
    set ::yy_buffer [append s [string range $::yy_buffer $::yy_index end]]
}

# Returns all but the first n characters of the current token back to
# the input stream, where they will be rescanned when the scanner
# looks for the next match.  yytext and yyleng are adjusted
# appropriately.
#   -- from the flex(1) man page
proc yyless {n} {
    set s [string range $::yy_buffer 0 [expr {$::yy_index - 1}]]
    append s [string range $::yytext $n end]
    set ::yy_buffer [append s [string range $::yy_buffer $::yy_index end]]
    set ::yytext [string range 0 [expr {$n - 1}]]
    set ::yyleng [string length $::yytext]
}

# input() reads the next character from the input stream.
#   -- from the flex(1) man page
proc input {} {
    if {[string length $::yy_buffer] - $::yy_index < 1024} {
       set new_buffer_size 0
       if {$::yy_done == 0} {
           YY_INPUT new_buffer new_buffer_size 1024
           append ::yy_buffer $new_buffer
           if {$new_buffer_size == 0} {
               set ::yy_done 1
           }
       }
       if $::yy_done {
           if {[yywrap] == 0} {
               return [input]
           } elseif {[string length $::yy_buffer] - $::yy_index == 0} {
               return {}
           }
        }
    }
    set c [string index $::yy_buffer $::yy_index]
    incr ::yy_index
    return $c
}

# Pushes the current start condition onto the top of the start
# condition stack and switches to new_state as though you had used
# BEGIN new_state.
#   -- from the flex(1) man page
proc yy_push_state {new_state} {
    lappend ::yy_state_stack $new_state
}

# Pops off the top of the state stack; if the stack is now empty, then
# pushes the state "INITIAL".
#   -- from the flex(1) man page
proc yy_pop_state {} {
    set ::yy_state_stack [lrange $::yy_state_stack 0 end-1]
    if {$::yy_state_stack == ""} {
        yy_push_state INITIAL
    }
}

# Returns the top of the stack without altering the stack's contents.
#   -- from the flex(1) man page
proc yy_top_state {} {
    return [lindex $::yy_state_stack end]
}

# BEGIN followed by the name of a start condition places the scanner
# in the corresponding start condition. . . .Until the next BEGIN
# action is executed, rules with the given start condition will be
# active and rules with other start conditions will be inactive.  If
# the start condition is inclusive, then rules with no start
# conditions at all will also be active.  If it is exclusive, then
# only rules qualified with the start condition will be active.
#   -- from the flex(1) man page
proc BEGIN {new_state {prefix yy}} {
    eval set ::${prefix}_state_stack [lrange \$::${prefix}_state_stack 0 end-1]
    eval lappend ::${prefix}_state_stack $new_state
}

# initialize values used by the lexer
set ::yy_buffer {}
set ::yy_index 0
set ::yytext {}
set ::yyleng 0
set ::yy_done 0
set ::yy_state_stack {}
BEGIN INITIAL
array set ::yy_state_table {SEE_L 0 SEE_A 0 LINK 0 INITIAL 1 SEE_S 0}
if {![info exists ::yyin]} {
    set ::yyin "stdin"
}
if {![info exists ::yyout]} {
    set ::yyout "stdout"
}

######
# autogenerated yylex function created by fickle
######

# Whenever yylex() is called, it scans tokens from the global input
# file yyin (which defaults to stdin).  It continues until it either
# reaches an end-of-file (at which point it returns the value 0) or
# one of its actions executes a return statement.
#   -- from the flex(1) man page
proc yylex {} {
    upvar #0 ::yytext yytext
    upvar #0 ::yyleng yyleng
    while {1} {
        set yy_current_state [yy_top_state]
        if {[string length $::yy_buffer] - $::yy_index < 1024} {
            if {$::yy_done == 0} {
                set yynew_buffer ""
                YY_INPUT yynew_buffer yy_buffer_size 1024
                append ::yy_buffer $yynew_buffer
                if {$yy_buffer_size == 0 && \
                        [string length $::yy_buffer] - $::yy_index == 0} {
                    set ::yy_done 1
                }
            }
            if $::yy_done {
                if {[yywrap] == 0} {
                    set ::yy_done 0
                    continue
                } elseif {[string length $::yy_buffer] - $::yy_index == 0} {
                    break
                }
            }            
        }
        set ::yyleng 0
        set yy_matched_rule -1
        # rule 0: @author\s+
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(@author\s+)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 0
        }
        # rule 1: @deprecated\s+
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(@deprecated\s+)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 1
        }
        # rule 2: @param\s+\S+\s+
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(@param\s+\S+\s+)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 2
        }
        # rule 3: @return\s+
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(@return\s+)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 3
        }
        # rule 4: @see\s+\"
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(@see\s+\")} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 4
        }
        # rule 5: @see\s+\<
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(@see\s+\<)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 5
        }
        # rule 6: @see\s+
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(@see\s+)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 6
        }
        # rule 7: @since\s+
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(@since\s+)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 7
        }
        # rule 8: @version\s+
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(@version\s+)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 8
        }
        # rule 9: <*>\{@docroot\}
        if {[regexp -start $::yy_index -indices -line  -- {\A(\{@docroot\})} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 9
        }
        # rule 10: <*>\{\s*@link\s+
        if {[regexp -start $::yy_index -indices -line  -- {\A(\{\s*@link\s+)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 10
        }
        # rule 11: <SEE_S>\"
        if {$yy_current_state == "SEE_S" && \
                [regexp -start $::yy_index -indices -line  -- {\A(\")} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 11
        }
        # rule 12: <SEE_A></a>
        if {$yy_current_state == "SEE_A" && \
                [regexp -start $::yy_index -indices -line  -- {\A(</a>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 12
        }
        # rule 13: <SEE_L>\S+(\s+\S+)?
        if {$yy_current_state == "SEE_L" && \
                [regexp -start $::yy_index -indices -line  -- {\A(\S+(\s+\S+)?)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 13
        }
        # rule 14: <LINK>[^\}]+\}
        if {$yy_current_state == "LINK" && \
                [regexp -start $::yy_index -indices -line  -- {\A([^\}]+\})} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 14
        }
        # rule 15: [^@\{]*
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A([^@\{]*)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 15
        }
        # rule 16: <*>.|\n
        if {[regexp -start $::yy_index -indices -line  -- {\A(.|\n)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 16
        }
        if {$yy_matched_rule == -1} {
            set ::yytext [string index $::yy_buffer $::yy_index]
            set ::yyleng 1
        }
        incr ::yy_index $::yyleng
        # workaround for Tcl's circumflex behavior
        if {[string index $::yytext end] == "\n"} {
            set ::yy_buffer [string range $::yy_buffer $::yy_index end]
            set ::yy_index 0
        }
        switch -- $yy_matched_rule {
            0 {
append ::annotrec(author) "\n<dd>"; set ::tag author
            }
            1 {
set ::annotrec(deprecated) ""; set ::tag deprecated
            }
            2 {
regexp -- {\A@param\s+(\S+)\s+} $yytext foo param_name
                    append ::annotrec(param) "\n<dd><code>$param_name</code> - "
                    set ::tag param
            }
            3 {
set ::annotrec(return) ""; set ::tag return
            }
            4 {
append ::annotrec(see) "<dd>&quot;"; set ::tag see; yy_push_state SEE_S
            }
            5 {
append ::annotrec(see) "<dd><"; set ::tag see; yy_push_state SEE_A
            }
            6 {
append ::annotrec(see) "<dd>"; set ::tag see; yy_push_state SEE_L
            }
            7 {
append ::annotrec(since) "\n<dd>"; set ::tag since
            }
            8 {
append ::annotrec(version) "\n<dd>"; set ::tag version
            }
            9 {
append ::annotrec($::tag) $::annotrec(docroot)
            }
            10 {
yy_push_state LINK
            }
            11 {
append ::annotrec(see) "&quot;"; set ::tag text; yy_pop_state
            }
            12 {
append ::annotrec(see) "</a>"; set ::tag text; yy_pop_state
            }
            13 {
interp_link $yytext see; set ::tag text; yy_pop_state
            }
            14 {
interp_link [string range $yytext 0 end-1] link; yy_pop_state
            }
            15 -
            16 {
append ::annotrec($::tag) $yytext
            }
            default
                { puts stderr "unmatched token: $::yytext in state `$yy_current_state'"; exit -1 }
        }
    }
    return 0
}
######
# end autogenerated fickle functions
######


# Flushes internal tables in preparation for writing a new annotation
# file.  This function must be called before using any other procedure
# within this file.
#
# @param dest I/O channel to write annotations
# @param basename name of source Tcl file being annotate
# @param annothtmlname name of file to where annotations are being
# written
# @param docroot documents root directory
proc new_annotation {dest basename annothtmlname docroot} {
    array unset ::annotfile
    set ::annotfile(dest) $dest
    set ::annotfile(basename) $basename
    set ::annotfile(annothtmlname) $annothtmlname
    set ::annotfile(docroot) $docroot
    array set ::annotfile {file_overview {} file_summary {} procs {}}
}

# Given the file-level comment (with <code>//#</code> markings
# removed) scans it for tags.  Generates the HTML code suitable for
# writing to the file's annotation page.  Adds a one-line summary for
# the file to the global summary table.
#
# @param header a contiguous block of comments sans hash marks
proc add_file_annotation {header} {
    YY_FLUSH_BUFFER
    yy_scan_string $header
    array unset ::annotrec
    set ::annotrec(text) ""
    set ::annotrec(docroot) $::annotfile(docroot)
    set ::annotrec(basename) $::annotfile(basename)
    set ::tag text
    yylex
    if {[yy_top_state] != "INITIAL"} {
        tcldoc_file_error "Tag not closed in file header"
    }

    set ::annotrec(text) [string trim $::annotrec(text)]
    set file_overview "<dl>\n"
    
    # calculate the file summary
    if [info exists ::annotrec(deprecated)] {
        set summary "<strong>Deprecated.</strong> <em>$::annotrec(deprecated)</em>\n"
        append file_overview "<dt><strong>Deprecated.</strong> <em>[string trim $::annotrec(deprecated)</em>]\n<dl>\n"
    } else {
        set summary [get_summary $::annotrec(text)]
        append file_overview "<dd>$::annotrec(text)\n<dl>\n"
        if [info exists ::annotrec(since)] {
            append file_overview "<dt><strong>Since:</strong><dd> [string trim $::annotrec(since)]\n"
        }
        if [info exists ::annotrec(version)] {
            append file_overview "<dt><strong>Version:</strong> [string trim $::annotrec(version)]\n"
        }        
    }
    if [info exists ::annotrec(author)] {
        append file_overview "<dt><strong>Author:</strong> [string trim $::annotrec(author)]\n"
    }
    if [info exists ::annotrec(see)] {
        append file_overview "<dt><strong>See Also:</strong> [string trim $::annotrec(see)]\n"
    }
    
    append file_overview "</dl></dl>\n<hr>\n"
    
    set ::annotfile(file_overview) $file_overview
    set ::annotfile(file_summary) $summary
}

# Given a procedure-level comment scans it for tags.  Generates the
# HTML code suitable for writing to the file's annotation page.  Adds
# a one-line summary for the procedure to the global summary table.
#
# @param header a contiguous block of comments sans hash marks
# @param procname name of the procedure being scanned
# @param procargs a {@link #flatten_args flattened} list of arguments
# to the procedure
# @param procline line number for procedure declaration within its
# source file
proc add_proc_annotation {header procname procargs procline} {
    YY_FLUSH_BUFFER
    yy_scan_string $header
    array unset ::annotrec
    set ::annotrec(text) ""
    set ::annotrec(docroot) $::annotfile(docroot)
    set ::annotrec(basename) $::annotfile(basename)
    set ::tag text
    yylex
    if {[yy_top_state] != "INITIAL"} {
        tcldoc_file_error "Tag not closed in procedure header"
    }
    
    set ::annotrec(text) [string trim $::annotrec(text)]
    set proc_detail "<h3><a name=\"$procname\">$procname</a></h3>
<pre>proc $procname \{ $procargs \}</pre>
<dl>\n"

    # calculate the procedure summary
    if [info exists ::annotrec(deprecated)] {
        set summary "<strong>Deprecated.</strong> <em>[string trim $::annotrec(deprecated)]</em>\n"
        append proc_detail "<dt><strong>Deprecated.</strong> <em>[string trim $::annotrec(deprecated)]</em>\n"
    } else {
        set summary [get_summary $::annotrec(text)]
        append proc_detail "<dd>$::annotrec(text)<dl>\n"
        if [info exists ::annotrec(param)] {
            append proc_detail "<dt><strong>Parameters:</strong>\n[string trim $::annotrec(param)]\n"
        }
        if [info exists ::annotrec(return)] {
            append proc_detail "<dt><strong>Returns:</strong>\n<dd> [string trim $::annotrec(return)]\n"
        }
        if [info exists ::annotrec(since)] {
            append proc_detail "<dt><strong>Since:</strong>\n<dd> [string trim $::annotrec(since)]\n"
        }
        if [info exists ::annotrec(version)] {
            append proc_detail "<dt><strong>Version:</strong> [string trim $::annotrec(version)]\n"
        }
    }
 
    set proc_summary "<code><a href=\"#$procname\">$procname</a> \{ $procargs \}</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$summary"

    if [info exists ::annotrec(author)] {
        append proc_detail "<dt><strong>Author:</strong>\n[strin trim $::annotrec(author)]\n"
    }
    if [info exists ::annotrec(see)] {
        append proc_detail "<dt><strong>See Also:</strong>\n[string trim $::annotrec(see)]\n"
    }

    set htmlname $::annotfile(basename).html
    set procid ${procname}_${procline}
    append proc_detail "<dt><strong>Defined in:</strong><dd><a href=\"$htmlname#$procid\">$::annotfile(basename), line $procline</a>
</dl></dl>\n"

    # summary entries are:  target, args, source, description, type
    add_summary $procname \
        "$::annotfile(annothtmlname)#$procname" "\{ $procargs \}" \
        "$::annotfile(basename)"                $summary \
        "proc"
    set ::annotfile($procname:s) $proc_summary
    set ::annotfile($procname:d) $proc_detail
    lappend ::annotfile(procs) $procname
}

# Helper function to the scanner that takes the arguments to a
# <code>@link</code> or the third form of <code>@see</code> and splits
# it into its component parts.  For the name portion attempts to
# resolve the procedure name as per the rules described in the {@link
# tcldoc.html Tcldoc manual}.  Checks if there is an optional label;
# if not then set the label equal to the name.  Finally adds the
# results of the interpretation to the current tag being scanned.
#
# @param text tag text to scan
# @param tag name of tag being scanned.
proc interp_link {text tag} {
    # first extract the name and optional label
    if {[regexp -- {\A(\S+)\s*(.*)} $text foo name label] == 0} {
        tcldoc_file_error "Malformed @${tag} tag"
    }
    if {$label == ""} {
        set label [sanitize $name]
    }
    set text "<a href=\""
    # try to split the name into a filename and procedure name
    set filename ""
    if {[string first "\#" $name] == -1} {
        set procname $name
    } else {
        foreach {filename procname} [split $name "\#"] {}
    }
    if {$filename == ""} {
        set filename $::annotrec(basename)
    }
    set procrecord [lookup_procrecord $procname $filename]
    if {$procrecord != {}} {
        foreach {procdest procline} $procrecord {}
        append text "${procdest}-annot.html\#$procname"
    } else {
        append text $name
    }
    append text "\">$label</a>"
    append ::annotrec($::tag) $text
}

# Actually writes the annotation file to disk at the location
# specified in a previous call to {@link new_annotation}.  If
# <code>new_annotation</code> has not been called yet then behavior is
# undetermined.
#
# @see new_annotation
proc write_annotation {} {
    # write the file overview
    puts $::annotfile(dest) "$::annotfile(file_overview)"
    
    # write the procedure summary
    set procnames [lsort -dictionary $::annotfile(procs)]
    puts $::annotfile(dest) "<table border=\"1\" cellpadding=\"3\" cellspacing=\"0\" width=\"100%\">
<tr bgcolor=\"$::table_bg_color\">
<!-- -------------------- PROCEDURE SUMMARY -------------------- -->
<td><font size=\"+2\"><strong><a name=\"proc_summary\">Procedure Summary</a></strong></font></td>
</tr>"
    foreach procname $procnames {
        puts $::annotfile(dest) "<tr><td>$::annotfile($procname:s)</td></tr>"
    }
    puts $::annotfile(dest) "</table>\n<p>"

    # write actual procedure details
    puts $::annotfile(dest) "<!-- -------------------- PROCEDURE DETAIL -------------------- -->
<table border=\"1\" cellpadding=\"3\" cellspacing=\"0\" width=\"100%\">
<tr bgcolor=\"$::table_bg_color\">
<td colspan=1><font size=\"+2\"><strong><a name=\"proc_detail\">Procedure Detail</a></strong></font></td>
</tr>
</table>"
    foreach procname [lrange $procnames 0 end-1] {
        puts $::annotfile(dest) "$::annotfile($procname:d)\n<hr>"
    }
    if [llength $procnames] {
        puts $::annotfile(dest) "$::annotfile([lindex $procnames end]:d)"
    }
}


# Determines the summary line given the file/procedure information.  A
# summary is the first sentence (text ending with a period and followed
# by whitespace), excluding all HTML tags.
#
# @param text Text from a comment block (either file or procedure
# level) from which to determine summary.
# @return Calculated summary.
proc get_summary {text} {
    set text [regsub -all {<[^>]*>} $text {}]
    if {[regexp -- {\A([^\.]*.)(\s|\n)} $text foo summary] == 0} {
        set summary $text
    }
    return [string trim $summary]
}
# $Id: tcldoc.tcl,v 1.1.1.1 2004/10/23 00:38:29 tang Exp $

#//#
# tcldoc parses the declarations and documentation comments in a set
# of Tcl source files and produces a corresponding set of HTML pages
# describing procedure declarations.  Run tcldoc on a set of files
# and/or directories.  It builds a rich internal representation of the
# files, determining both procedure declarations and procedure
# calls. tcldoc will run on .tcl and .tsh source files that are pure
# stub files with no procedure bodies.  This means you can write
# documentation comments and run tcldoc in the earliest stages of
# design while creating the API, before writing the implementation.
#
# @author Jason Tang (tang@jtang.org)
# @version 1.0
# @see http://mini.net/tcl/tcldoc
#//#

# nat-418: commenting out this line and catting the scanner to the beginning
# of this file instead.
#source "[file join [file dirname $argv0] tcldoc_scanner.tcl]"

######################################################################
# main tcldoc functions

# Initialize all of the various cross-reference tables used by tcldoc.
# If an import record was given then merge that record with these
# tables.
proc initialize_tables {} {
    set ::all_files ""
    foreach c { : 1 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z } {
        set ::toc_table($c) 0
    }
}

# Creates the destination directory as necessary.  Copy over the
# overview file (if <code>--overview</code> specified) and doc files
# (<code>--doc-files</code>) as necessary.
proc prepare_destination {} {
    # create the destination directory if needed
    print_status "Writing to directory $::dest_dir."
    if [file exists $::dest_dir] {
        if {![file isdir $::dest_dir]} {
            tcldoc_error "Destination is not a directory." $::IO_ERROR
        }
        if {!$::force_overwrite} {
            puts -nonewline "Warning: Destination already exists.  Proceed? "
            flush stdout
            gets stdin in
            if {![string equal -length 1 -nocase $in "y"]} {
                exit
            }
        }
    } elseif [catch {file mkdir $::dest_dir}] {
        tcldoc_error "Could not create directory $::dest_dir." $::IO_ERROR
    }
    if {$::doc_dir != ""} {
        print_status "Copying doc files..."
        foreach doc $::doc_dir {
            if {[file exists $doc] && [file isfile $doc]} {
                # copy invidiual file
                file copy -force -- $doc $::dest_dir
            } elseif {[file exists $doc] && [file isdirectory $doc]} {
                # copy entire directory
                set doc_dest_dir [file join $::dest_dir [file tail $doc]]
                if {![file exists $doc_dest_dir]} {
                    if [catch {file mkdir $doc_dest_dir}] {
                        tcldoc_error "Could not create $doc_dest_dir for doc-files." $::IO_ERROR
                    }
                }
                foreach doc_file [glob -directory $doc *] {
                    file copy -force -- $doc_file $doc_dest_dir
                }
            } else {
                tcldoc_error puts stderr "Invalid doc-files file or directory $doc." $::IO_ERROR
            }
        }
    }
    if {$::overview_file != ""} {
        print_status "Copying overview file..."
        if {[file exists $::overview_file] && [file isfile $::overview_file]} {
            if [catch {file copy -force $::overview_file $::dest_dir}] {
                tcldoc_error "Could not copy overview file $::overview_file." $::IO_ERROR
            }
        } else {
            tcldoc_error "Invalid overview file: $::overview_file." $::IO_ERROR
        }
    }
}


proc write_export_file {} {
}

######################################################################
# functions affecting individual files

# Scans a file for all instances of lines beginning with
# <code>proc</code> indicating a procedure declaration.  Add
# discovered declarations to the procedure table along with its line
# number in the file.
#
# @param filename file to scan for procedure declarations
proc declaration_scan {filename} {
    set basename [file tail $filename]
    set newhtmlname "${basename}.html"
    print_status "Scanning $filename:"
    if [catch {open $filename r} src] {
        puts stderr "  Unable to open $filename -- skipping."
        break
    }
    set ::current_file $filename
    set ::line_number 0
    while {[gets $src line] >= 0} {
        incr ::line_number
        if [regexp {\A\s*proc\s+([^\s\{]+)} $line foo procname] {
            # add the procedure and line number to the file index
            lappend ::file_table($basename) [list $procname $::line_number]
            # add the filename and line number to the procedure index
            lappend ::proc_table($procname) [list $basename $::line_number]
            print_status "  $procname"
        }
    }
    close $src
}

# Take a single source Tcl file and scan it intensively, generating
# its HTML version.  Identify comment blocks and highlight them in the
# HTML version.  If the comment is a procedure-level or file-level
# comment then pipe it through the scanner for annotation purposes.
# Identify procedure declarations, add &lt;a name&gt; anchors and add
# their parameters to the function table.  Identify procedure calls
# and add &lt;a href&gt; hypertext.  Substitute proper html codes for
# special symbols <, >, &, and &quot;.  Write the HTML marked version
# as well as the annotations.
#
# @param filename file to scan
# @see scan_recursively
proc deep_scan {filename} {
    set basename [file tail $filename]
    set htmlname "${basename}.html"
    set annothtmlname "${basename}-annot.html"
    set txtname "${basename}.txt"
    print_status "Building $htmlname..."
    
    # figure out my "docroot" path
    # *** FIX ME ***: until the notion of 'packages' is added
    # here, docroot will be set to nothing
    set docroot "."
    
    # read the entire source file into memory
    if [catch {open $filename r} src] {
        print_status "  Unable to open source file -- skipping."
        return
    }
    set srcbuf [read $src]
    close $src

    # start writing HTML version
    if [catch {open [file join $::dest_dir $htmlname] w} dest] {
        print_status "  Unable to create destination file -- skipping."
        return
    }
    write_header $dest $basename $basename
    puts $dest "<strong>$basename</strong>
\(<a href=\"$annothtmlname\">annotations</a> | <a href=\"$txtname\">original source</a>\)
<p>
<pre>"    

    # start writing the annotated file
    if [catch {open [file join $::dest_dir $annothtmlname] w} annot] {
        print_status "  Unable to create annotation file -- skipping."
        close $dest
        return
    }
    write_header $annot $basename "$basename annotations"
    puts $annot "<h2><a href=\"$htmlname\">$basename</a> Annotations</h2>"
    if {!$::hide_paths} {
        puts $annot "Created from <strong><code>[sanitize [file nativename $filename]]</strong></code>"
    }
    puts $annot "<hr>"
    new_annotation $annot $basename $annothtmlname $docroot
    
    set ::current_file $filename
    set ::line_number 1

    scan_recursively $dest $srcbuf $basename $annothtmlname

    # add this file to the summary table
    if $::hide_paths {
        set sourceloc ""
    } else {
        set sourceloc "[file nativename [file dirname $filename]]"
    }
    add_summary $basename \
        $annothtmlname "" $sourceloc $::annotfile(file_summary) file

    puts $dest "</pre>"
    write_footer $dest
    close $dest
    write_annotation
    write_footer $annot
    close $annot
}

# Given a buffer of Tcl code recursively examine each command within.
# Commands follow normal Tcl syntax -- they are either terminated by
# newlines or semicolons.  If a single command has multiple parts
# (such as an <code>if</code> statement) recursively examine each
# subpart.  In this way discover comment blocks, procedure
# declarations, and procedure calls.
# <p>
# There are limits to this scanner because it only does static
# analysis.  Mainly, things that make Tcl such a dynamic language
# (such as <code>eval</code> and <code>subst</code> commands) may
# potentially confuse this scanner.
#
# @param buffer buffer of Tcl code to examine
# @param basename source file from which this Tcl code originated
# @param dest I/O channel to write HTML-ized version of the buffer
proc scan_recursively {dest buffer basename annotname} {
    set comment_block ""
    while {$buffer != ""} {
        set output ""
        set line_complete 0
        set line ""
        # consume whitespace
        if [regexp -- {\A(\s+)(.*)} $buffer foo match buffer] {
            append output $match
            # file and procedure annoations must be contiguous; if
            # there are any newlines between then stop the block
            if {[string first "\n" $match] >= 0} {
                set comment_block ""
            }
        }
        # grab the next "command" from the src buffer
        while {!$line_complete && $buffer != ""} {
            if [regexp -- {\A([^;\n]+)(.*)} $buffer foo l buffer] {
                append line $l
            }
            # there are two special cases: the original line began
            # with a hash, in which I should consume the rest of the
            # line, or if $l ended with a backslash
            if {[string index $line 0] == "\#"} {
                # note how this will consume semicolons within the
                # comment
                regexp -- {\A([^\n]*)(.*)} $buffer foo l buffer
                append line $l
                set line_complete 1
            } elseif {![info complete $line] || [string index $line end] == "\\"} {
                append line [string index $buffer 0]
                set buffer [string range $buffer 1 end]
            } else {
                set line_complete 1
            }
        }
        if {!$line_complete && $output == ""} {
            tcldoc_file_error "Source does not appear to be valid Tcl code"
        }

        # analyze this "line" for comments, procedure declarations,
        # and procedure calls
        if {[string index $line 0] == "\#"} {
            append output "<font color=\"$::comment_color\">[sanitize $line]</font>"
            append comment_block [string range $line 1 end]
            # check to see if this is a file-level comment
            if [regexp -- {\A\/\/\#.*\/\/\#\Z} [string trim $comment_block]] {
                add_file_annotation \
                    [string range [string trim $comment_block] 3 end-3]
                set comment_block ""
            } else {
                append comment_block "\n"
            }
            set line ""
        } elseif {[regexp -- {\A(proc\s+)(\S+)(.*)} $line foo decl procname line]} {
            # using $::line_number below may lead to incorrect numbers
            # because $output may have newlines buffered within.  thus
            # first flush $output (and hence increment ::line_number).
            write_and_update $dest $output
            set output "<strong><a name=\"${procname}_${::line_number}\">$decl<a href=\"$annotname\#$procname\">$procname</a></a></strong>"
            # additionally, if this is the /last/ declaration for the
            # function add a normal <a name> anchor
            set procrecord [lookup_procrecord $procname $basename]
            if {[lindex $procrecord 1] == $::line_number} {
                append output "<a name=\"${procname}\"></a>"
            }
            add_proc_annotation [string trim $comment_block] $procname \
                [flatten_args [lindex $line 0]] $::line_number
            set comment_block ""
        } elseif {[regexp -- {\A([:A-Za-z_]\S*)(.*)} $line foo decl line]} {
            # check to see if line is a call to a previously declared
            # procedure
            set procrecord [lookup_procrecord $decl $basename]
            if {$procrecord != {}} {
                foreach {procdest procline} $procrecord {}
                set procdest \
                        "[file join [path_lookup $procdest] $procdest].html"
                set procid ${decl}_${procline}
                # add to the procedure call table this call
                set callcount 1
                if [info exists ::call_table($decl)] {
                    foreach call $::call_table($decl) {
                        if {[string match "$basename*" $call]} {
                            incr callcount
                        }
                    }
                }
                lappend ::call_table($decl) "${basename}($callcount)"
                append output "<a name=\"${decl}($callcount)\"><a href=\"$procdest#$procid\">$decl</a></a>"
            } else {
                # not a known command
                append output $decl
            }
            set comment_block ""
        } else {
            set comment_block ""
        }

        write_and_update $dest $output

        # the rest of the line may have more info, so recurse upon any
        # part which appears to be a sublist or a subcommand.  for
        # everything else write it to the destination
        while {$line != ""} {
            set c [string index $line 0]
            if {$c == "\{" || $c == "\["} {
                # find the matching brace/bracket
                set found_matching 0
                set subgroup "$c"
                set line [string range $line 1 end]
                while {!$found_matching && $line != ""} {
                    if [regexp -- {\A([^\}\]]*[\}\]])(.*)} $line foo s line] {
                        append subgroup $s
                    } else {
                        break
                    }
                    set found_matching [info complete $subgroup]
                }
                if $found_matching {
                    puts -nonewline $dest [string index $subgroup 0]
                    scan_recursively $dest [string range $subgroup 1 end-1] $basename $annotname
                    puts -nonewline $dest [string index $subgroup end]
                } else {
                    tcldoc_file_error "Unmatched $c"
                }
            } elseif [regexp -- {\A((\\.|[^\[\{])+)(.*)} $line foo match foo2 line] {
                write_and_update $dest [sanitize $match]
            }
        }
        
        # consume the next character from the buffer
        write_and_update $dest [string index $buffer 0]
        set buffer [string range $buffer 1 end]
    }
}


# Writes to channel <code>$dest</code> the contents of
# <code>$output</code>.  Updates the global <code>::line_number</code>
# to keep track of how many lines have been written; hopefully this
# number is the same as the lines read from the source file.
#
# @param dest channel to write <code>$output</code>
# @param output data to write
proc write_and_update {dest output} {
    # write to the destination file and update the line counter
    if {$output != ""} {
        puts -nonewline $dest $output
        incr ::line_number -1
        foreach x [split $output "\n"] {
            incr ::line_number
        }
    }
}

# Given a procedure name, look up within the procedure table for its
# declaration.  In case of ambiguity as to which function declaration
# to use prefer to use the last one declared within $basename.
# Otherwise just use the first one listed (and hope for the best!).
# Returns a two element list containing the Tcl source filename and
# line number where procedure was declared.  If the procedure is not
# declared at all return an empty list.
#
# @param procname procedure name to look up
# @param basename preferred file to use
# @return if entry found a 2-ple procedure record, else an empty list
proc lookup_procrecord {procname basename} {
    set procrecord ""
    if [info exists ::proc_table($procname)] {
        foreach pr $::proc_table($procname) {
            if {[lindex $pr 0] == $basename} {
                set procrecord $pr
            }
        }
        if {$procrecord == ""} {
            set procrecord [lindex $::proc_table($procname) 0]
        }
    }
    return $procrecord
}

# Given some text, replaces potentially dangerous characters with
# their HTML character code.  Returns the new string afterwards.
#
# @param s string to sanitize
# @return an HTML-friendly version of <code>$s</code>
proc sanitize {s} {
    regsub -all {\&} $s {\&amp;} s
    regsub -all {\<} $s {\&lt;} s
    regsub -all {\>} $s {\&gt;} s
    regsub -all {\"} $s {\&quot;} s
    return $s
}

# Outputs a common header for HTML-ized Tcl files.
#
# @param dest I/O channel to write HTML header
# @param basename Tcl source filename, sans any directory paths
# @param title HTML title to use for generated file
proc write_header {dest basename title} {
    puts $dest "<html>
<head><title>$title</title></head>
<body bgcolor=\"$::page_bg_color\">"
    if {$::header != ""} {
        puts $dest "$::header\n<hr>"
    }
    if {!$::hide_navbar} {
        puts $dest "<font size=\"-2\">"
        if {$::overview_file != ""} {
            puts -nonewline $dest "<a href=\"[file tail $::overview_file]\">Overview</a> | "
        }
        puts $dest "Index by:  <a href=\"index_main.html#$basename\">file name</a> |
<a href=\"index_main.html#byprocname\">procedure name</a> |
<a href=\"index_main.html#bycall\">procedure call</a> |
<a href=\"index_annot_full.html\">annotation</a>
</font>
<hr>"
    }
}

# Output a common header for HTML-ized Tcl files.  This same footer is
# also used for index_main.html.
#
# @param dest I/O channel to write HTML footer
proc write_footer {dest} {
    if {!$::hide_navbar} {
        puts $dest "<hr>\n<font size=\"-2\">"
        if {$::overview_file != ""} {
            puts -nonewline $dest "<a href=\"[file tail $::overview_file]\">Overview</a> | "
        }
        puts $dest "Index by:  <a href=\"index_main.html#byfilename\">file name</a> |
<a href=\"index_main.html#byprocname\">procedure name</a> |
<a href=\"index_main.html#bycall\">procedure call</a> |
<a href=\"index_annot_full.html\">annotation</a><br>
<cite>Index generated $::date.</cite>
</font>"
    }
    if {$::footer != ""} {
        puts $dest "<hr>\n$::footer"
    }
    puts $dest "</body>\n</html>"
}

######################################################################
# functions used when writing the index files

# Write the index of filenames.  Alphabetically list all source files
# along with procedures declared within.  Add hyperlinks from those
# procedure names to the line where they are declared.  Also write to
# the main index a similar list.
#
# @param mainindex I/O channel of index_main.html
proc write_index_byfile {mainindex} {
    print_status "  building index by file name"
    set fileindexname [file join $::dest_dir "index_file.html"]
    if [catch {open $fileindexname w} fileindex] {
        tcldoc_error "  Unable to create index_file.html" $::IO_ERROR
    }
    write_index_header $fileindex $::dest_dir \
        "<strong>file name</strong> |
<a href=\"index_proc.html\" target=\"sidebar\">procedure name</a> |
<a href=\"index_call.html\" target=\"sidebar\">procedure call</a> |
<a href=\"index_annot.html\" target=\"sidebar\">annotation</a>" "file name"

    # iterate through all files.  add an entry along with all
    # functions declared within that file.
    foreach filename $::all_files {
        set basename [file tail $filename]
        set dir [path_lookup $basename]
        set htmlname "[file join $dir $basename].html"
        set txtname "[file join $dir $basename].txt"
        set annothtmlname "[file join $dir $basename]-annot.html"
        
        puts $mainindex "<p>
<dt><strong><a name=\"$basename\"><a href=\"$htmlname\">$basename</a></a></strong>"
        puts $mainindex "(<a href=\"$annothtmlname\">annotations</a> | <a href=\"$txtname\">original source</a>)"
        puts $fileindex "<dt><strong><a name=\"$basename\"><a href=\"$htmlname\" target=\"main\">$basename</a></a></strong>"
        puts $fileindex "<font size=\"-2\">(<a href=\"$annothtmlname\" target=\"main\">annotations</a> | <a href=\"$txtname\" target=\"main\">original</a>)</font>"
        
        # list all procedure declarations in that file, if any
        if [info exists ::file_table($basename)] {
            foreach procrecord [lsort -dictionary -index 0 $::file_table($basename)] {
                foreach {procname line} $procrecord {}
                set procid ${procname}_${line}
                puts $mainindex "<dd><a href=\"$htmlname#$procid\">$procname</a>"
                puts $fileindex "<dd><a href=\"$htmlname#$procid\" target=\"main\">$procname</a>"
            }
        }
    }
    
    write_index_footer $fileindex
    close $fileindex
}

# Write the index of procedures.  Alphabetically list all procedure
# declarations; if a procedure is declared multiple times list all of
# them.  Add hyperlinks from those procedure names to the line where
# they are declared.  Also write to the main index a similar list.
#
# @param mainindex I/O channel of index_main.html
proc write_index_byproc {mainindex} {
    print_status "  building index by procedure name"
    set procindexname [file join $::dest_dir "index_proc.html"]
    if [catch {open $procindexname w} procindex] {
        tcldoc_error "  Unable to create index_proc.html" $::IO_ERROR
    }
    write_index_header $procindex $::dest_dir \
        "<a href=\"index_file.html\" target=\"sidebar\">file name</a> |
<strong>procedure name</strong> |
<a href=\"index_call.html\" target=\"sidebar\">procedure call</a> |
<a href=\"index_annot.html\" target\"sidebar\">annotation</a>" "procedure name"

    # iterate through all procedures declarations.  add an entry along
    # with the Tcl file and line containing its declaration
    set firstlet "\0"
    foreach procname [lsort -dictionary [array names ::proc_table]] {
        set filenames $::proc_table($procname)
        if {[string compare -nocase -length 1 $firstlet $procname] < 0} {
            set firstlet [string tolower [string index $procname 0]]
            puts $mainindex "<dt><strong>$firstlet</strong>"
        }
        puts -nonewline $mainindex "<dd>$procname: "

        # if the procedure has multiple declarations (for some
        # reason), list each instance on a separate line within
        # index_proc.html.  for index_main.html, however, give the
        # procedure name followed by a comma separated list of source
        # files
        if {[llength $filenames] == 1} {
            # only one declaration; set a link straight from the procedure name
            foreach {filename line} [lindex $filenames 0] {}
            set procid ${procname}_${line}
            set htmlname "[file join [path_lookup $filename] $filename].html"
            puts $procindex "<a href=\"$htmlname#$procid\" target=\"main\">$procname</a><br>"
        } else {
            puts $procindex "$procname:"
            foreach filerecord [lsort -dictionary -index 0 $filenames] {
                foreach {filename line} $filerecord {}
                set procid ${procname}_${line}
                set htmlname "[file join [path_lookup $filename] $filename].html"
                puts $procindex " <li><a href=\"$htmlname#$procid\" target=\"main\">$filename</a>"
            }
            puts $procindex "<br>"
        }
        set filelist ""
        foreach filerecord [lsort -dictionary -index 0 $filenames] {
            foreach {filename line} $filerecord {}
            set procid ${procname}_${line}
            set htmlname "[file join [path_lookup $filename] $filename].html"
            lappend filelist "<a href=\"$htmlname#$procid\">$filename</a>"
        }
        puts $mainindex [join $filelist ", "]
    }
    write_index_footer $procindex
    close $procindex
}

# Write the index of procedure calls.  Alphabetically list every
# procedure that is called.  Add hyperlinks to the line where that
# call is made.  Also write to the main index a similar list.
#
# @param mainindex I/O channel of index_main.html
proc write_index_bycall {mainindex} {
    print_status "  building index by procedure call"
    set callindexname [file join $::dest_dir "index_call.html"]
    if [catch {open $callindexname w} callindex] {
        tcldoc_error "  Unable to create index_call.html" $::IO_ERROR
    }
    write_index_header $callindex $::dest_dir \
        "<a href=\"index_file.html\" target=\"sidebar\">file name</a> |
<a href=\"index_proc.html\" target=\"sidebar\">procedure name</a> |
<strong>procedure call</strong> |
<a href=\"index_annot.html\" target=\"sidebar\">annotation</a>" "procedure call"

    # iterate through all procedure calls.  add an entry along with
    # the Tcl file(s) that make that call.
    set firstlet "\0"
    foreach procname [lsort -dictionary [array names ::call_table]] {
        set calls $::call_table($procname)
        if {[string compare -nocase -length 1 $firstlet $procname] < 0} {
            set firstlet [string tolower [string range $procname 0 0]]
            puts $mainindex "<dt><strong>$firstlet</strong>"
        }
        puts -nonewline $mainindex "<dd><strong>$procname:</strong> "
        puts -nonewline $callindex "<dt><strong>$procname</strong>"
        set filelist_main ""
        set filelist_call ""
        foreach call [lsort -dictionary $calls] {
            # each entry in ::call_table is of the form `foo(x)' where
            # foo is the source file and (x) is an identifier
            regexp {(.*)(\(\d+\)$)} $call foo filename callnum
            set callid "${procname}$callnum"
            set htmlname "[file join [path_lookup $filename] $filename].html"
            lappend filelist_main "<a href=\"$htmlname#$callid\">$call</a>"
            lappend filelist_call "<dd><a href=\"$htmlname#$callid\" target=\"main\">$call</a>"
        }
        puts $mainindex [join $filelist_main ", "]
        puts $callindex [join $filelist_call ", "]
    }
    write_index_footer $callindex
    close $callindex
}


# Write two indices of all declared procedures and source files.  The
# big index (index_annot_full.html) alphabetizes everything and
# displays a one-line summary along with a hyperlink to the item.  The
# smaller index, index_annot.html, has just the item names and
# hyperlinks.
proc write_index_annotations {} {
    print_status "Building annotation indices..."
    set annotindexname [file join $::dest_dir "index_annot.html"]
    if [catch {open $annotindexname w} annotindex] {
        tcldoc_error "  Unable to create index_annot.html." $::IO_ERROR
    }
    set annotfullindexname [file join $::dest_dir "index_annot_full.html"]
    if [catch {open $annotfullindexname w} annotfullindex] {
        tcldoc_error "  Unable to create index_annot_full.html." $::IO_ERROR
    }
    write_index_header $annotindex $::dest_dir \
        "<a href=\"index_file.html\" target=\"sidebar\">file name</a> |
<a href=\"index_proc.html\" target=\"sidebar\">procedure name</a> |
<a href=\"index_call.html\" target=\"sidebar\">procedure call</a> |
<strong>annotation</strong>" "annotation"
    write_index_header $annotfullindex $::dest_dir \
        "<a href=\"index_main.html#byfilename\">file name</a> |
<a href=\"index_main.html#byprocname\">procedure name</a> |
<a href=\"index_main.html#bycall\">procedure call</a> |
<strong>annotation</strong>" ""

    foreach c { : 1 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z } {
        if $::toc_table($c) {
            puts $annotfullindex "<a href=\"#$c\">$c</a>"
        } else {
            puts $annotfullindex $c
        }
    }

    puts $annotfullindex "<h1>Index of annotations</h1>\n<dl>"
    set firstlet " "
    foreach summary_name [lsort -dictionary [array names ::summary_table]] {
        set new_firstlet [string toupper [string index $summary_name 0]]
        if {$new_firstlet != ":"} {
            if {[string compare $new_firstlet "A"] < 0} {
                set new_firstlet "1"
            } elseif {[string compare $new_firstlet "Z"] > 0} {
                set new_firstlet "Z"
            }
        }
        if {[string compare $firstlet $new_firstlet] < 0} {
            set firstlet $new_firstlet
            puts $annotfullindex "<dt><h3><a name=\"$firstlet\">$firstlet</a></h3>"
        }
        set summary_entry_list $::summary_table($summary_name)
        # if more than one entry with the same summary_name, then show
        # each one using a bulleted list
        if {[llength $summary_entry_list] > 1} {
            puts $annotindex "<dt>$summary_name:"
        }
        foreach summary_entry $summary_entry_list {
            # a summary is:  target, args, source, description, type, new/old
            foreach {target args source desc type} $summary_entry {}
            set markup_start ""
            set markup_stop ""
            if {$type == "file"} {
                set markup_start "<strong>"
                set markup_stop "</strong>"
            }
            if {[llength $summary_entry_list] == 1} {
                puts $annotindex "<dt>$markup_start<a href=\"$target\" target=\"main\">$summary_name</a>$markup_stop"
            } else {
                puts $annotindex "<li>$markup_start<a href=\"$target\" target=\"main\">$source</a>$markup_stop"
            }
            puts $annotfullindex "<dt>$markup_start<a href=\"$target\"\>$summary_name</a>$markup_stop $args - "
            if {$type == "file"} {
                if {$source == ""} {
                    puts $annotfullindex "Tcl source code"
                } else {
                    puts $annotfullindex "file found in <code>$source</code>"
                }
            } else {
                puts $annotfullindex "<a href=\"[file join [path_lookup $source] $source]-annot.html\">$source</a>"
            }
            puts $annotfullindex "<dd>$desc"
        }
    }
    write_index_footer $annotindex
    puts $annotfullindex "</dl>"
    write_footer $annotfullindex
    close $annotindex
    close $annotfullindex
}

# Writes the overall index.html that defines the frames.  If an
# overview file was specified (with <code>--overview</code>) then have
# the index load the overview; otherwise just load index_main.html.
proc write_index_master {} {
    print_status "Building index.html..."
    set indexname [file join $::dest_dir "index.html"]
    if [catch {open $indexname w} index] {
        tcldoc_error "  Unable to create index.html." $::IO_ERROR
    }
    puts $index "
<html>
<head>
<title>$::title</title>
</head>
<frameset rows=\"*\" cols=\"25%, *\">
<frame src=\"index_file.html\" name=\"sidebar\">"
    if {$::overview_file != ""} {
        puts $index "<frame src=\"[file tail $::overview_file]\" name=\"main\">
<noframes>
You want to go <a href=\"[file tail $::overview_file]\">here</a>."
    } else {
        puts $index "<frame src=\"index_main.html\" name=\"main\">
<noframes>
You want to go <a href=\"index_main.html\">here</a>."
    }
    puts $index "</noframes>
</frameset>
</html>"

    close $index
}

# Outputs a common header for the various generated index files.
#
# @param dest I/O channel to write HTML footer
# @param page_title HTML title to use for generated file
# @param index_line HTML source to print for the <code>Index by:</code> line
# @param page_header an optional title to put at the top of the page
proc write_index_header {dest page_title index_line {page_header ""}} {
    puts $dest "<html>
<head>
<title>$page_title</title>
</head>
<body bgcolor=\"$::page_bg_color\">
<script type=\"text/javascript\">
<!--
if (top == self) {
    location.href=\"index.html\"
}
//-->
</script>"
    if {$::header != ""} {
        puts $dest "$::header\n<hr>"
    }
    puts $dest "<font size=\"-2\">"
    if {$::overview_file != ""} {
        puts -nonewline $dest "<a href=\"[file tail $::overview_file]\" target=\"main\">Overview</a> | "
    }
    puts $dest "Index by:  $index_line</font><br>\n<hr>"
    if {$page_header != ""} {
        puts $dest "<strong>Index by $page_header:</strong>\n<dl>"
    }
}

# Outputs a common footer for the various generated index files.
#
# @param dest I/O channel to write HTML footer
proc write_index_footer {dest} {
    puts $dest "</dl>
<p>
<hr>
<font size=\"-2\"><cite>Index generated $::date.</cite></font>
</body>
</html>"
}

######################################################################
# File Utilities

# Glob recursively across a directory and its subdirectory for all
# files matching a list of extensions.  Return all matches as a flat
# list.
#
# @param dir root directory to scan
# @param exts list of extension (e.g., <code>*.tcl</code>) to search
# @return list of matching files
proc glob_all {dir exts} {
    set all_files [glob -nocomplain -directory $dir *]
    set retval ""
    foreach ext $exts {
        set foundfiles [glob -nocomplain -directory $dir $ext]
        foreach file $foundfiles {
            if {[file isfile $file] && [file readable $file]} {
                lappend retval $file
            }
        }
    }
    foreach file $all_files {
        if [file isdirectory $file] {
            set retval [concat $retval [glob_all [file join $dir $file] $exts]]
        }
    }
    return $retval
}

# Compares the last part of a filename (i.e., sans directory paths).
# Returns-1, 0, 1 if respectively <code>$a</code> occurs lexically
# before, with, or after <code>$b</code>.
#
# @param a first file to compare
# @param b second file to compare
# @return -1, 0, or 1
proc filecomp {a b} {
    return [string compare -nocase [file tail $a] [file tail $b]]
}

# Given a filename returns the location of where its tcldoc'ed files
# are located.  The path may not necessarily be the same as
# <code>$::dest_dir</code>, especially if the file is being imported
# from elsewhere by way of <code>--import</code>.
#
# @param orig_file filename to find
# @return path to where tcldoc wrote its file
proc path_lookup {orig_file} {
    if [info exists ::path_table($orig_file)] {
        return $::path_table($orig_file);
    } else {
        return "."
    }
}


######################################################################
# miscellaneous tcldoc utilities

# If running in verbose mode print to standard output its arguments.
# Otherwise do nothing.
#
# @param args any valid string suitable to be passed to <code>puts</code>
proc print_status {args} {
    if $::verbose {
        eval puts $args
    }
}

# Given an arbitrary length list (such as the one supplying arguments
# to a procedure declaration) remove excess spaces between arguments.
# This is very similar to Lisp's flatten function.
#
# @param x list to flatten
# @return a flattend list
proc flatten_args {x} {
    if {![info complete $x]} {
        tcldoc_error "ERROR: Attempting to flatten $x"
    }    
    if {[string index $x 0] == "\{"} {
        return [flatten_args [string range $x 1 end-1]]
    } else {
        set new_list ""
        foreach elem $x {
            if {[llength $elem] > 1} {
                lappend new_list [flatten_args $elem]
            } else {
                lappend new_list $elem
            }
        }
        return $new_list
    }
}

# Adds an entry to the global summary table.  The entry will
# eventually be written to the global summary indices.
#
# @param entry brief entry name
# @param target for file entries the HTML version of the file; for
# procedures the file containing its declaration
# @param arguments for procedures a list or arguments to it; ignored
# for files
# @param source source Tcl file for the entry
# @param description a one line summary describing the entry
# @param type type of entry; currently just <code>file</code> and
# <code>proc</code> are understood.
# @see write_index_annotations
proc add_summary {entry target arguments source description type} {
    lappend ::summary_table($entry) \
        [list $target $arguments $source $description $type]    
    set firstchar [string toupper [string index $entry 0]]
    if {$firstchar == ":"} {
        incr ::toc_table(:)
    } elseif {[string compare $firstchar "A"] < 0} {
        incr ::toc_table(1)
    } elseif {[string compare $firstchar "Z"] > 0} {
        incr ::toc_table(Z)
    } else {
        incr ::toc_table($firstchar)
    }
}

# Called to abort whenever tcldoc discovers a problem with a
# particular input file.  Print to standard error the message along
# with the source file and line number where that error occured.
# Finally abort program.
#
# @param message message to display
proc tcldoc_file_error {message} {
    puts stderr "$message (file $::current_file, line $::line_number)"
    exit $::SYNTAX_ERROR
}

# Called to abort tcldoc upon all other errors.  Print to standard
# error the error message then abort tcldoc.
#
# @param message message to display
# @param returnvalue exit code
proc tcldoc_error {message {returnvalue -1}} {
    puts stderr $message
    exit $returnvalue
}

# Retrives a parameter from the options list.  If no parameter exists
# then abort with an error very reminisicent of C's
# <code>getopt</code> function; otherwise increment
# <code>param_num</code> by one.
#
# @param param_list list of parameters from the command line
# @param param_num index into <code>param_list</code> to retrieve
# @param param_name name of the parameter, used when reporting an error
# @return the <code>$param_num</code>'th element into <code>$param_list</code>
proc get_param {param_list param_num param_name} {
    upvar $param_num pn
    incr pn
    if {$pn >= [llength $param_list]} {
        tcldoc_error "tcldoc: option requires an argument -- $param_name" $::PARAM_ERROR
    }
    return [lindex $param_list $pn]
}

# Print tcldoc's usage to a channel.
#
# @param chan I/O channel to print usage documentation
proc print_tcldoc_help {chan} {
    puts $chan "tcldoc: a Tcl API Documentation Generator
Usage:  tcldoc \[options\] DESTDIR SRC \[SRC...\]
  DESTDIR           direction to which write generated files
  SRC               Tcl source code file to parse

General Options:
  -h, --help           print this help message and quit
  -v, --verbose        be verbose while generating files
  -f, --force          don't prompt before overwriting files in DESTDIR
  --                   marks end of options

Overall File Generation Options:
  --overview FILE      use FILE as an overview page
  --doc-files NAME     copy NAME (file or directory) verbatim to DESTDIR\[*\]
  --dont-copy          don't copy original source files to DESTDIR

Individual File Generation Options:
  --title TITLE        use TITLE for the main index.html page
  --header HTML        use HTML text in the header
  --footer HTML        use HTML text in the footer
  --hide-paths         prevent showing path names on annotated pages
  --no-navbar          disable navigation bar at top and bottom of pages
  --date FORMAT        write time stamp using FORMAT \(see \[clock format\]\)
  --comment COLOR      hex COLOR for comments \(default \"208020\"\)
  --page-bg COLOR      hex COLOR for page backgrounds \(default \"ffffff\"\)
  --table-bg COLOR     hex COLOR for table annotations \(default \"ccccff\"\)

Import/Export Options: \(not implemented yet\)
  --import FILE        \[*\]
  --include FILE       \[*\]
  --export FILE      
  --export-loc NEWDIR
\[*\] Multiple invocations of this option allowed."
}


######################################################################
# other tcldoc functions

# Parse the command line and set global options.
#
# @param argv list of options from the command line
proc tcldoc_args {argv} {
    set argvp 0
    set ::verbose 0
    set ::force_overwrite 0
    set ::overview_file ""
    set ::dont_copy_files 0
    set ::doc_dir ""
    set ::title "tcldoc Documentation"
    set ::header ""
    set ::footer ""
    set ::hide_paths 0
    set ::hide_navbar 0
    set ::import_file ""
    set ::export_file ""
    set ::export_dir ""
    set date_format "%Y-%m-%d at %H:%M"
    set ::comment_color "\#208020";     # a pale green color
    set ::page_bg_color "\#ffffff";     # pearly white
    set ::table_bg_color "\#ccccff";    # pale blue
    while {$argvp < [llength $argv]} {
        set arg [lindex $argv $argvp]
        switch -- $arg {
            "-h" - "--help"      { print_tcldoc_help stdout; exit }
            "-v" - "--verbose"   { set ::verbose 1}
            "-f" - "--force"     { set ::force_overwrite 1 }
            "--overview" {
                set ::overview_file [get_param $argv argvp "overview"]
            }
            "--doc-files" { lappend ::doc_dir [get_param $argv argvp "doc-files"] }
            "--dont-copy" { set ::dont_copy_files 1 }
            "--title"     { set ::title [get_param $argv argvp "title"] }
            "--header"    { set ::header [get_param $argv argvp "header"] }
            "--footer"    { set ::footer [get_param $argv argvp "footer"] }
            "--hide-paths" { set ::hide_paths 1 }
            "--no-navbar"  { set ::hide_navbar 1 }
            "--date"       { set date_format [get_param $argv argvp "date"] }
            "--comment" {
                set ::comment_color "\#[get_param $argv argvp "comment"]"
            }
            "--page-bg" {
                set ::page_bg_color "\#[get_param $argv argvp "page-bg"]"
            }
            "--table-bg" {
                set ::table_bg_color "\#[get_param $argv argvp "table-bg"]"
            }
            "--import"   { set ::import_file [get_param $argv argvp "import"] }
            "--export"   { set ::export_file [get_param $argv argvp "export"] }
            "--export-loc" {
                set ::export_dir [get_param $argv argvp "export-loc"]
            }
            "--"           { incr argvp; break }
            default {
                if {[string index $arg 0] != "-"} {
                    break
                } else {
                    puts stderr "tcldoc: unknown option $arg"
                    print_tcldoc_help stderr
                    exit $::PARAM_ERROR
                }
            }
        }
        incr argvp
    }
    if {$argvp + 2 > [llength $argv]} {
        puts stderr "Must specify a destination directory and at least one source file."
        print_tcldoc_help stderr
        exit $::PARAM_ERROR
    }
    set ::date [clock format [clock seconds] -format $date_format]
    set ::dest_dir [lindex $argv $argvp]
    set ::srcs [lrange $argv [expr {$argvp + 1}] end]
    if {$::export_dir != ""} {
        set ::export_dir [file join [pwd] $::dest_dir]
    }    
}

# Actually run tcldoc across requested files and directories.  Scan
# them and generate HTML markup versions.  Scan file and procedure
# comments to build the annotated files.  Cross-reference procedure
# calls with the declarations.  Finally write indices to everything.
proc tcldoc_main {} {
    # first build a list of all tcl scripts which are defined as
    # those with filenames *.tcl or *.tsh
    set ::todo_files ""
    foreach src $::srcs {
        if [file isfile $src] {
            lappend ::todo_files $src
        } else {
            foreach srcf [glob_all $src {*.tcl *.tsh}] {
                lappend ::todo_files $srcf
            }
        }
    }
    set ::todo_files [lsort -ascii -command filecomp $::todo_files]
    set ::all_files [lsort -ascii -command filecomp [concat $::all_files $::todo_files]]

    # open each file and scan for procedure declarations
    foreach filename $::todo_files {
        declaration_scan $filename
    }
    
    # rescan each file, this time identifying procedure calls and
    # other markups.  write both its HTML version and its annotated
    # version.
    foreach filename $::todo_files {
        deep_scan $filename
        set basename [file tail $filename]
        set newtxtname "[file join [path_lookup $basename] $basename].txt"
        if {!$::dont_copy_files} {
            file copy -force $filename [file join $::dest_dir $newtxtname]
        }        
    }

    # begin constructing the main index page, which is the combination
    # of all three major indices (by file name, by procedure name, by
    # procedure call) group onto a single page.
    print_status "Building index_main.html..."
    set mainindexname [file join $::dest_dir "index_main.html"]
    if [catch {open $mainindexname w} mainindex] {
        tcldoc_error "  Unable to create index_main.html." $::IO_ERROR
    }
    write_index_header $mainindex $::dest_dir \
        "<a href=\"index_main.html#byfilename\">file name</a> |
<a href=\"index_main.html#byprocname\">procedure name</a> |
<a href=\"index_main.html#bycall\">procedure call</a> |
<a href=\"index_annot_full.html\">annotation</a>"
    puts $mainindex "<h1>tcldoc of <em>$::dest_dir</em></h1>"

    # construct the index by file name page
    puts $mainindex "<h2>Index by <a name=\"byfilename\">file name</a>:</h2>\n<dl>"
    write_index_byfile $mainindex

    # construct the index by procedure name
    puts $mainindex "
</dl>
<hr>
<h2>Index by <a name=\"byprocname\">procedure name</a>:</h2>
<dl>"
    write_index_byproc $mainindex

    # construct the index by procedure call
    puts $mainindex "
</dl>
<hr>
<h2>Index by <a name=\"bycall\">procedure call</a>:</h2>
<dl>"
    write_index_bycall $mainindex

    puts $mainindex "</dl>"
    write_footer $mainindex
    close $mainindex

    # build the annotations index
    write_index_annotations
    
    # finally, build the master index_main.html page
    write_index_master
}

######################################################################
# start of main script

set ::IO_ERROR 1
set ::SYNTAX_ERROR 2
set ::PARAM_ERROR 3
set ::GRAMMAR_ERROR 4

tcldoc_args $argv
initialize_tables
prepare_destination
tcldoc_main
write_export_file
